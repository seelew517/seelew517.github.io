<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Q</title>
      <link href="/2025/03/25/Q/"/>
      <url>/2025/03/25/Q/</url>
      
        <content type="html"><![CDATA[<h5 id="过滤器和拦截器的区别是啥？执行顺序是啥？以及实现原理的区别？"><a href="#过滤器和拦截器的区别是啥？执行顺序是啥？以及实现原理的区别？" class="headerlink" title="过滤器和拦截器的区别是啥？执行顺序是啥？以及实现原理的区别？"></a>过滤器和拦截器的区别是啥？执行顺序是啥？以及实现原理的区别？</h5><p>概念层面</p><ul><li><strong>过滤器（Filter）</strong>：是 Servlet 规范中的一部分，用于对请求和响应进行预处理和后处理。它可以在请求到达 Servlet 之前或响应返回客户端之前对请求和响应进行修改，常用于字符编码转换、日志记录、权限验证等功能。</li><li><strong>拦截器（Interceptor）</strong>：是 Spring 框架提供的功能，用于对 Controller 方法进行拦截。它可以在 Controller 方法执行前后进行额外的处理，常用于权限检查、日志记录、性能监控等。</li></ul><p>应用范围</p><ul><li><strong>过滤器</strong>：基于 Servlet 容器，适用于所有的 Web 请求，无论是 Servlet、JSP 还是其他基于 Servlet 的框架。</li><li><strong>拦截器</strong>：基于 Spring 框架，只能用于 Spring MVC 的请求处理流程中，只有在 Spring MVC 的 DispatcherServlet 接收到请求后才会起作用。</li></ul><p>功能粒度</p><ul><li><strong>过滤器</strong>：主要针对请求和响应进行全局的处理，无法获取 Spring 容器中的 Bean，对请求的处理相对较为底层，通常用于对请求和响应的基本操作，如字符编码设置、请求参数过滤等。</li><li><strong>拦截器</strong>：可以获取 Spring 容器中的 Bean，能够对 Controller 方法进行更细粒度的控制，可以在方法执行前后进行拦截，并且可以获取方法的参数、返回值等信息，适合实现一些与业务逻辑相关的功能，如权限验证、日志记录等。</li></ul><p>配置方式</p><ul><li><strong>过滤器</strong>：可以通过 web.xml 文件或注解（如<code>@WebFilter</code>）进行配置。</li><li><strong>拦截器</strong>：需要在 Spring MVC 的配置类中进行配置，通过实现<code>HandlerInterceptor</code>接口并重写相应的方法，然后将拦截器注册到<code>InterceptorRegistry</code>中。</li></ul><p>执行顺序</p><ul><li><strong>过滤器</strong>：过滤器的执行顺序是根据在 web.xml 文件中配置的顺序或者注解的加载顺序来确定的。一般来说，先配置的过滤器会先执行，在请求进入 Servlet 之前，过滤器按照配置顺序依次执行；在响应返回客户端之前，过滤器按照相反的顺序依次执行。</li><li><strong>拦截器</strong>：拦截器的执行顺序是根据在<code>InterceptorRegistry</code>中注册的顺序来确定的。先注册的拦截器会先执行，在请求进入 Controller 方法之前，拦截器按照注册顺序依次执行<code>preHandle</code>方法；在 Controller 方法执行完成后，拦截器按照相反的顺序依次执行<code>postHandle</code>方法；在视图渲染完成后，拦截器按照相反的顺序依次执行<code>afterCompletion</code>方法。</li><li><strong>整体顺序</strong>：过滤器的执行顺序在拦截器之前。当一个请求进入 Web 应用时，首先会经过过滤器的处理，然后再进入 Spring MVC 的 DispatcherServlet，接着才会触发拦截器的执行。</li></ul><p>实现原理的区别</p><p><strong>过滤器</strong></p><ul><li><strong>基于 Servlet 容器</strong>：过滤器是基于 Servlet 规范实现的，由 Servlet 容器负责管理和调用。当请求到达 Servlet 容器时，容器会根据配置的过滤器链，依次调用每个过滤器的<code>doFilter</code>方法。在<code>doFilter</code>方法中，可以对请求和响应进行预处理和后处理，然后调用<code>FilterChain</code>的<code>doFilter</code>方法将请求传递给下一个过滤器或 Servlet。</li><li><strong>生命周期管理</strong>：过滤器的生命周期由 Servlet 容器管理，包括初始化（<code>init</code>方法）、执行过滤任务（<code>doFilter</code>方法）和销毁（<code>destroy</code>方法）。</li></ul><p><strong>拦截器</strong></p><ul><li><strong>基于 Spring MVC 框架</strong>：拦截器是 Spring MVC 框架提供的功能，由 Spring 容器负责管理和调用。当请求进入 Spring MVC 的 DispatcherServlet 时，DispatcherServlet 会根据配置的拦截器链，依次调用每个拦截器的<code>preHandle</code>方法。如果<code>preHandle</code>方法返回<code>true</code>，则继续执行后续的拦截器和 Controller 方法；如果返回<code>false</code>，则中断请求处理流程。在 Controller 方法执行完成后，会依次调用拦截器的<code>postHandle</code>方法；在视图渲染完成后，会依次调用拦截器的<code>afterCompletion</code>方法。</li><li><strong>依赖注入</strong>：拦截器可以使用 Spring 的依赖注入功能，获取 Spring 容器中的 Bean，从而可以方便地使用 Spring 框架提供的各种服务和组件。</li></ul><h5 id="spring-security是基于过滤器还是拦截器？"><a href="#spring-security是基于过滤器还是拦截器？" class="headerlink" title="spring security是基于过滤器还是拦截器？"></a>spring security是基于过滤器还是拦截器？</h5><p><strong>核心原理</strong>：在 Servlet 容器里，Spring Security 借助一系列过滤器组成过滤器链。请求进入时，依次经过这些过滤器，进行身份验证、授权等安全检查。</p><p><strong>与拦截器对比</strong>：拦截器是 Spring MVC 框架的功能，主要用于拦截 Controller 方法，而 Spring Security 需在请求进入 MVC 处理前就进行安全控制，过滤器更符合其在请求处理流程早期介入的需求。</p><p><strong>过滤器链示例</strong>：如 <code>UsernamePasswordAuthenticationFilter</code> 处理表单登录认证，<code>BasicAuthenticationFilter</code> 处理 HTTP Basic 认证。</p><ul><li><h5 id="spring-security有什么过滤器？"><a href="#spring-security有什么过滤器？" class="headerlink" title="spring security有什么过滤器？"></a>spring security有什么过滤器？</h5><p><strong>UsernamePasswordAuthenticationFilter</strong>：处理基于表单的用户名和密码登录认证。</p><p><strong>BasicAuthenticationFilter</strong>：处理 HTTP Basic 认证，验证请求中的基本认证信息。</p><p><strong>LogoutFilter</strong>：处理用户的注销请求，清除用户的认证信息和会话。</p><p><strong>CsrfFilter</strong>：处理跨站请求伪造（CSRF）保护，验证请求中的 CSRF 令牌。</p></li></ul><h5 id="springboot如何自定义一个starter？比方说像MySQLstarter之类的"><a href="#springboot如何自定义一个starter？比方说像MySQLstarter之类的" class="headerlink" title="springboot如何自定义一个starter？比方说像MySQLstarter之类的"></a>springboot如何自定义一个starter？比方说像MySQLstarter之类的</h5><ol><li><strong>项目搭建</strong>：创建 Maven 项目，设定基本的目录结构，包含 <code>autoconfigure</code>、<code>properties</code>、<code>service</code> 包以及 <code>META - INF</code> 资源目录。</li><li><strong>依赖配置</strong>：在 <code>pom.xml</code> 里添加 Spring Boot 自动配置及相关功能所需依赖。</li><li><strong>属性定义</strong>：创建配置属性类，使用 <code>@ConfigurationProperties</code> 注解指定配置前缀，定义可配置的属性。</li><li><strong>服务编写</strong>：编写实现具体功能的服务类，该类可使用配置属性类中的配置。</li><li><strong>自动配置</strong>：创建自动配置类，使用 <code>@Configuration</code> 注解，借助 <code>@ConditionalOnClass</code> 等条件注解，结合 <code>@EnableConfigurationProperties</code> 启用配置属性类，按需配置 Bean。</li><li><strong>工厂配置</strong>：在 <code>META - INF/spring.factories</code> 文件中指定自动配置类，让 Spring Boot 能够识别。</li><li><strong>打包使用</strong>：通过 <code>mvn clean install</code> 打包到本地 Maven 仓库，在其他 Spring Boot 项目的 <code>pom.xml</code> 中添加依赖，在 <code>application.properties</code> 里配置自定义属性，最后在代码中注入并使用服务类。</li></ol><ul><li><h5 id="MetaInfo的配置以及用来做什么的"><a href="#MetaInfo的配置以及用来做什么的" class="headerlink" title="MetaInfo的配置以及用来做什么的"></a>MetaInfo的配置以及用来做什么的</h5><ol><li><strong>spring.factories</strong>：指定自动配置类，Spring Boot 启动扫描加载，实现自动配置。</li><li><strong>spring - org.springframework.boot.autoconfigure.AutoConfiguration.imports（3.0 及后）</strong>：替代前者指定自动配置类，加载性能更好。</li><li><strong>additional - spring - configuration - metadata.json</strong>：提供配置属性元数据，助 IDE 实现自动补全与提示。</li><li><strong>spring - schema.xsd 和 spring.handlers（少用）</strong>：前者定义 XML 配置规则，后者指定命名空间处理器，支持 XML 配置 Bean。</li></ol></li><li><h5 id="starter的设计模式有哪些？"><a href="#starter的设计模式有哪些？" class="headerlink" title="starter的设计模式有哪些？"></a>starter的设计模式有哪些？</h5><ul><li>工厂模式<ul><li><strong>应用场景</strong>：在 Starter 中，通常会有一个工厂类负责创建各种 Bean 实例。例如，自定义 Starter 中创建数据库连接对象的工厂，根据配置信息创建不同类型的数据库连接。</li><li><strong>作用</strong>：将对象的创建和使用分离，使得代码的耦合度降低，提高了代码的可维护性和可扩展性。用户只需要关心如何使用对象，而不必了解对象的具体创建过程。</li></ul></li><li>单例模式<ul><li><strong>应用场景</strong>：对于一些全局共享的资源或配置对象，常采用单例模式。如在 Starter 中配置的全局属性对象，整个应用中只有一个实例，供各个模块访问和使用。</li><li><strong>作用</strong>：确保在整个应用程序中，某个类只有一个实例存在，节省系统资源，同时方便全局访问和管理共享资源。</li></ul></li><li>代理模式<ul><li><strong>应用场景</strong>：在 Starter 中，当需要对某些 Bean 的方法进行增强或控制访问时，可能会使用代理模式。例如，对服务层方法进行性能监控、事务管理等。</li><li><strong>作用</strong>：通过代理对象来代理目标对象，在不修改目标对象代码的情况下，对目标对象的行为进行扩展和控制，实现功能的增强和复用。</li></ul></li></ul></li></ul><h5 id="认证和鉴权的区别是什么？"><a href="#认证和鉴权的区别是什么？" class="headerlink" title="认证和鉴权的区别是什么？"></a>认证和鉴权的区别是什么？</h5><p>认证确认用户是谁的过程，验证用户的身份。例如用户名密码登录、手机验证码等。</p><p>鉴权确定用户能做什么的过程，验证用户是否有权限执行特定操作。例如普通用户不能访问管理员页面。</p><h5 id="为什么开发者要自创线程池而不是直接用springboot的线程池？？"><a href="#为什么开发者要自创线程池而不是直接用springboot的线程池？？" class="headerlink" title="为什么开发者要自创线程池而不是直接用springboot的线程池？？"></a>为什么开发者要自创线程池而不是直接用springboot的线程池？？</h5><ul><li>自创线程池可以让开发者完全按照业务需求来定制这些参数，而不受 Spring Boot 默认配置的限制。例如，根据业务的并发特性，精确设置核心线程数、最大线程数、线程存活时间等参数，以达到最佳的性能和资源利用效率。</li><li>自创线程池可以方便开发者添加自定义的线程工厂、线程命名规则、线程状态监控等功能。例如，为线程设置有意义的名称，便于在日志中追踪和排查问题；或者实现自定义的线程工厂，根据业务需求创建具有特定属性的线程</li><li>当应用架构中已经存在一些自定义的组件或框架，需要与线程池进行深度集成时，自创线程池可以更好地与这些现有架构进行适配。例如，与自定义的任务调度框架、分布式锁机制等进行无缝集成，以实现更复杂的业务逻辑和并发控制。</li></ul><h5 id="自建线程池有哪些指标需要去监控？"><a href="#自建线程池有哪些指标需要去监控？" class="headerlink" title="自建线程池有哪些指标需要去监控？"></a>自建线程池有哪些指标需要去监控？</h5><ul><li>线程池大小</li><li>活跃线程数</li><li>任务队列长度</li><li>任务提交数/完成数</li><li>线程池状态</li><li>线程等待/执行时间</li><li>拒绝任务数    </li></ul><h5 id="集群相对于单机来说，有什么不同点"><a href="#集群相对于单机来说，有什么不同点" class="headerlink" title="集群相对于单机来说，有什么不同点"></a>集群相对于单机来说，有什么不同点</h5><p>集群相对于单机的不同点：易于扩展，高性能，高可用性，但是需要额外维护成本</p><h5 id="集群是如何进行同步数据的"><a href="#集群是如何进行同步数据的" class="headerlink" title="集群是如何进行同步数据的"></a>集群是如何进行同步数据的</h5><p>主从同步，增量同步，全量同步，异步复制</p><p>同步的时候有一个replication buffer缓冲区，会写入同步期间新增的数据，同步完rdb之后再同步这个命令，然后重放一次</p><h5 id="集群模式是否容易丢失数据？以及如何解决丢失数据的情况？"><a href="#集群模式是否容易丢失数据？以及如何解决丢失数据的情况？" class="headerlink" title="集群模式是否容易丢失数据？以及如何解决丢失数据的情况？"></a>集群模式是否容易丢失数据？以及如何解决丢失数据的情况？</h5><p>集群模式可能丢失数据，主要原因是异步复制。</p><p>解决方法：开启持久化(RDB/AOF) 调整min-slaves-to-write和min-slaves-max-lag参数（拒绝写入</p><h5 id="rdb和aof在使用的时候应该怎么选"><a href="#rdb和aof在使用的时候应该怎么选" class="headerlink" title="rdb和aof在使用的时候应该怎么选"></a>rdb和aof在使用的时候应该怎么选</h5><p>RDB：适合数据备份，恢复速度快，对性能影响小，但可能丢失最后一次快照后的数据 </p><p>AOF：数据安全性高，支持秒级持久化，但文件较大，恢复速度慢</p><p>建议同时使用：RDB做冷备，AOF做热备，利用各自优势</p><h5 id="缓存穿透如果用空值法的话，如何避免大面积的内存被白白占用？"><a href="#缓存穿透如果用空值法的话，如何避免大面积的内存被白白占用？" class="headerlink" title="缓存穿透如果用空值法的话，如何避免大面积的内存被白白占用？"></a>缓存穿透如果用空值法的话，如何避免大面积的内存被白白占用？</h5><ul><li>空值设置较短的TTL</li><li>布隆过滤器</li><li>后台任务定期检查和清理空值</li></ul><h5 id="redisson相比于setnx灵活在哪？"><a href="#redisson相比于setnx灵活在哪？" class="headerlink" title="redisson相比于setnx灵活在哪？"></a>redisson相比于setnx灵活在哪？</h5><ul><li>同一线程可多次获取锁</li><li>自动续期</li><li>锁超时</li><li>分布式支持</li></ul><h5 id="采用延迟双删的情况下，如果MySQL数据库操作失败了怎么办？"><a href="#采用延迟双删的情况下，如果MySQL数据库操作失败了怎么办？" class="headerlink" title="采用延迟双删的情况下，如果MySQL数据库操作失败了怎么办？"></a>采用延迟双删的情况下，如果MySQL数据库操作失败了怎么办？</h5><ol><li><strong>事务回滚</strong>：借助数据库事务特性，在操作失败时进行回滚。在 Java 里可使用 Spring 的 <code>@Transactional</code> 注解达成，确保数据库操作的原子性，防止部分操作成功而部分失败。</li><li><strong>重试机制</strong>：对失败的数据库操作设定重试次数与间隔时间。例如，可使用循环和异常捕获实现重试逻辑，避免因临时性问题（如网络抖动）造成的失败。</li><li><strong>日志记录</strong>：把失败的操作记录到日志中，内容涵盖操作类型、数据信息、错误信息等。这样有助于后续排查问题，定位故障原因。</li><li><strong>消息队列补偿</strong>：将失败的操作信息发送到消息队列。创建一个消费者服务，从消息队列接收这些信息，持续尝试执行数据库操作，直至成功。</li></ol><h5 id="redis刷新token是如何保证用户无感的"><a href="#redis刷新token是如何保证用户无感的" class="headerlink" title="redis刷新token是如何保证用户无感的"></a>redis刷新token是如何保证用户无感的</h5><ol><li>使用access_token和refresh_token</li><li>在access_token即将过期前自动刷新 </li><li>用户活跃时延长token有效期（<strong>滑动过期机制</strong>）。当用户进行操作时，不仅仅是检查 Token 是否有效，同时也更新 Token 的过期时间</li><li>客户端在后台异步刷新token </li><li>token过期后短时间内仍可使用，同时刷新</li></ol><h5 id="mybatisplus和mybatis的区别"><a href="#mybatisplus和mybatis的区别" class="headerlink" title="mybatisplus和mybatis的区别"></a>mybatisplus和mybatis的区别</h5><p><strong>MyBatis-Plus</strong>：在 MyBatis 基础上进行了增强，提供了大量的内置方法，如单表的增删改查操作基本无需编写 SQL，通过调用框架提供的方法就能实现。同时，它还支持代码生成器，可自动生成实体类、Mapper 接口等代码，提高开发效率。</p><p>代码复杂度</p><ul><li><strong>MyBatis</strong>：开发过程中需要开发者手动编写大量的 SQL 语句和 Mapper 接口方法，对于复杂的业务逻辑，SQL 语句的编写和维护会变得十分繁琐，代码量也会相应增加。</li><li><strong>MyBatis-Plus</strong>：提供了很多便捷的方法，减少了 SQL 的编写量。开发者只需关注业务逻辑，通过调用框架提供的方法就能完成常见的数据库操作，代码更加简洁，开发效率更高。</li></ul><p>性能</p><ul><li><strong>MyBatis</strong>：由于开发者可以手动优化 SQL 语句，对于复杂的业务场景，能够通过精细的 SQL 优化实现较高的性能。</li><li><strong>MyBatis-Plus</strong>：虽然内置方法方便，但在处理复杂业务时，生成的 SQL 可能不是最优的，性能上可能会有一定的损失。不过，对于大多数简单业务场景，其性能足以满足需求。</li></ul><h5 id="有没用过jpa"><a href="#有没用过jpa" class="headerlink" title="有没用过jpa"></a>有没用过jpa</h5><h5 id="mybatisplus用到了很多queryweb？"><a href="#mybatisplus用到了很多queryweb？" class="headerlink" title="mybatisplus用到了很多queryweb？"></a>mybatisplus用到了很多queryweb？</h5><h5 id="mybatisplus如何实现分页"><a href="#mybatisplus如何实现分页" class="headerlink" title="mybatisplus如何实现分页"></a>mybatisplus如何实现分页</h5><h5 id="多表连接怎么优化"><a href="#多表连接怎么优化" class="headerlink" title="多表连接怎么优化"></a>多表连接怎么优化</h5><ol><li>减少连接表数量</li><li>索引优化</li><li>小表驱动大表 </li><li>尽量使用内连接而非外连接</li><li>将过滤条件尽量下推到基表</li><li>避免笛卡尔积</li></ol><h5 id="多表连接的情况下，如果要分页查询该怎么改造？"><a href="#多表连接的情况下，如果要分页查询该怎么改造？" class="headerlink" title="多表连接的情况下，如果要分页查询该怎么改造？"></a>多表连接的情况下，如果要分页查询该怎么改造？</h5><ol><li>先获取分页ID，再关联查询详细数据</li><li>先对主表分页，再与其他表连接</li><li>尽量使用索引覆盖避免回表</li><li>将WHERE条件提前执行</li><li>使用临时表存储中间结果</li></ol><h5 id="多表连接如何创建索引？联合索引是作用在哪里？"><a href="#多表连接如何创建索引？联合索引是作用在哪里？" class="headerlink" title="多表连接如何创建索引？联合索引是作用在哪里？"></a>多表连接如何创建索引？联合索引是作用在哪里？</h5><ol><li>在所有JOIN条件字段上创建索引</li><li>WHERE条件字段创建索引</li><li>ORDER BY字段创建索引 </li></ol><p>联合索引作用最左前缀匹配 索引覆盖 减少回表次数 提高连接效率</p><h5 id="join-from-groupby-order的执行顺序"><a href="#join-from-groupby-order的执行顺序" class="headerlink" title="join from groupby order的执行顺序"></a>join from groupby order的执行顺序</h5><p>SQL执行顺序： FROM &gt; JOIN &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</p><h5 id="MySQL内部如何提高扫描效率？"><a href="#MySQL内部如何提高扫描效率？" class="headerlink" title="MySQL内部如何提高扫描效率？"></a><strong>MySQL内部如何提高扫描效率？</strong></h5><ol><li>B+树索引减少磁盘IO次数</li><li>根据成本选择最优执行计划</li><li>InnoDB buffer pool缓存热数据</li><li>提前读取可能需要的数据页 </li></ol><ul><li><h5 id="有什么优化器？"><a href="#有什么优化器？" class="headerlink" title="有什么优化器？"></a>有什么优化器？</h5></li></ul><h5 id="点赞排行如何实现？用zset的话是不是只能存储短期的数据？那如果一周之后没了该怎么办？要如何刷新？"><a href="#点赞排行如何实现？用zset的话是不是只能存储短期的数据？那如果一周之后没了该怎么办？要如何刷新？" class="headerlink" title="点赞排行如何实现？用zset的话是不是只能存储短期的数据？那如果一周之后没了该怎么办？要如何刷新？"></a>点赞排行如何实现？用zset的话是不是只能存储短期的数据？那如果一周之后没了该怎么办？要如何刷新？</h5><ol><li>使用ZSET存储，score为点赞数</li><li>定期将热门数据持久化到MySQL </li><li>热数据保存在Redis，冷数据存入MySQL </li><li>设置定时任务每天/周从MySQL加载基础数据到Redis</li><li>只更新有变化的数据，而非全量刷新</li></ol><h5 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h5><ol><li>表中增加version字段，更新时检查版本</li><li>条件更新 UPDATE table SET data=?, version=version+1 WHERE id=? AND version=? SQL优化问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNotes</title>
      <link href="/2025/03/10/JavaNotes/"/>
      <url>/2025/03/10/JavaNotes/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="/loadingPostImg.gif" data-original="image-20250306151456542-1741597095526-1.png" alt="image-20250306151456542"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306144558842-1741597095528-2.png" alt="image-20250306144558842"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306150818653-1741597095528-3.png" alt="image-20250306150818653"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306151445437-1741597095529-4.png" alt="image-20250306151445437"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306154511211-1741597095530-7.png" alt="image-20250306154511211"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306152355564-1741597095529-5.png" alt="image-20250306152355564"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306152750934-1741597095529-6.png" alt="image-20250306152750934"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306152815333-1741597095530-8.png" alt="image-20250306152815333"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306154553633-1741597095530-9.png" alt="image-20250306154553633"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306153445925-1741597095530-10.png" alt="image-20250306153445925"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306153656998-1741597095532-14.png" alt="image-20250306153656998"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306154609961-1741597095532-12.png" alt="image-20250306154609961"></p><blockquote><p>《缓存三兄弟》<br>穿透无中生有key，布隆过滤nuIl隔离<br>缓存击穿过期key，锁与非期解难题。<br>雪崩大量过期key，过期时间要随机。<br>面试必考三兄弟，可用限流来保底。</p></blockquote><h3 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306154856297-1741597095532-13.png" alt="image-20250306154856297"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306154941737-1741597095531-11.png" alt="image-20250306154941737"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306155020173-1741597095533-18.png" alt="image-20250306155020173"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306155028019-1741597095533-17.png" alt="image-20250306155028019"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306155036261-1741597095532-15.png" alt="image-20250306155036261"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306155212392-1741597095536-33.png" alt="image-20250306155212392"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306155358774-1741597095533-16.png" alt="image-20250306155358774"></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p><img src="/loadingPostImg.gif" data-original="image-20250306155552970-1741597095533-19.png" alt="image-20250306155552970"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306160327277-1741597095534-23.png" alt="image-20250306160327277"></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p><img src="/loadingPostImg.gif" data-original="image-20250306160532753-1741597095533-20.png" alt="image-20250306160532753"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306160641824-1741597095534-21.png" alt="image-20250306160641824"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306160852116-1741597095534-22.png" alt="image-20250306160852116"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306161043037-1741597095534-24.png" alt="image-20250306161043037"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306161238513-1741597095534-25.png" alt="image-20250306161238513"></p><h3 id="数据过期策略"><a href="#数据过期策略" class="headerlink" title="数据过期策略"></a>数据过期策略</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306161359221-1741597095535-26.png" alt="image-20250306161359221"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306161542987-1741597095535-27.png" alt="image-20250306161542987"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306161648652-1741597095535-28.png" alt="image-20250306161648652"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306161722349-1741597095535-29.png" alt="image-20250306161722349"></p><h3 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306161952545-1741597095535-30.png" alt="image-20250306161952545"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306162242033-1741597095535-31.png" alt="image-20250306162242033"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306162317059-1741597095536-32.png" alt="image-20250306162317059"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306162345171-1741597095536-34.png" alt="image-20250306162345171"><img src="/loadingPostImg.gif" data-original="image-20250306162432906-1741597095537-35.png" alt="image-20250306162432906"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>集群情况下的定时任务、抢单、幂等性场景</p><p><img src="/loadingPostImg.gif" data-original="image-20250306163538074-1741597095537-37.png" alt="image-20250306163538074"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306164718988-1741597095537-36.png" alt="image-20250306164718988"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306164934198-1741597095537-38.png" alt="image-20250306164934198"></p><p>新增特性：重试机制（while循环尝试等待）</p><p><img src="/loadingPostImg.gif" data-original="image-20250306165146726-1741597095537-39.png" alt="image-20250306165146726"></p><p>lua脚本最大的作用是调用Redis命令来保证多条命令执行的原子性。</p><p><img src="/loadingPostImg.gif" data-original="image-20250306165843162-1741597095537-40.png" alt="image-20250306165843162"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306170011886-1741597095537-41.png" alt="image-20250306170011886"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306165953099-1741597095538-47.png" alt="image-20250306165953099"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306170508232-1741597095537-43.png" alt="image-20250306170508232"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306170551246-1741597095537-42.png" alt="image-20250306170551246"></p><p>redis集群整体思想是AP，优先保证高可用性，可以做到最终的一致；需要数据强一致性的业务可以采用CP思想的zookeeper实现分布式锁。</p><p><img src="/loadingPostImg.gif" data-original="image-20250306170821106-1741597095538-44.png" alt="image-20250306170821106"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306170910547-1741597095538-45.png" alt="image-20250306170910547"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306171217318-1741597095538-46.png" alt="image-20250306171217318"></p><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306171613449-1741597095539-56.png" alt="image-20250306171613449"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306171701717-1741597095538-48.png" alt="image-20250306171701717"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306171859259-1741597095538-50.png" alt="image-20250306171859259"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306171923048-1741597095538-49.png" alt="image-20250306171923048"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306224936520-1741597095538-51.png" alt="image-20250306224936520"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306225344839-1741597095538-52.png" alt="image-20250306225344839"></p><h3 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306225647115-1741597095538-53.png" alt="image-20250306225647115"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306230000506-1741597095538-54.png" alt="image-20250306230000506"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306230058437-1741597095538-55.png" alt="image-20250306230058437"></p><h3 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h3><p><img src="/loadingPostImg.gif" data-original="image-20250306231043918-1741597095539-58.png" alt="image-20250306231043918"></p><h3 id="数据读写规则"><a href="#数据读写规则" class="headerlink" title="数据读写规则"></a>数据读写规则</h3><p>路由规则</p><p><img src="/loadingPostImg.gif" data-original="image-20250306231731046-1741597095539-57.png" alt="image-20250306231731046"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306232043028-1741597095539-59.png" alt="image-20250306232043028"></p><p><img src="/loadingPostImg.gif" data-original="image-20250306232103020-1741597095539-60.png" alt="image-20250306232103020"></p><h3 id="单线程的Redis，为何那么快？"><a href="#单线程的Redis，为何那么快？" class="headerlink" title="单线程的Redis，为何那么快？"></a>单线程的Redis，为何那么快？</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307103130952-1741597095539-62.png" alt="image-20250307103130952"></p><ul><li>减少无效等待</li><li>减少用户空间和内核空间的数据拷贝</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250307103513177-1741597095539-61.png" alt="image-20250307103513177"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307103555946-1741597095539-63.png" alt="image-20250307103555946"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307103646394-1741597095540-64.png" alt="image-20250307103646394"></p><p>socket：客户端的连接</p><p><img src="/loadingPostImg.gif" data-original="image-20250307103907734-1741597095540-65.png" alt="image-20250307103907734"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307104033787-1741597095540-66.png" alt="image-20250307104033787"></p><p>影响性能的永远是io</p><p><img src="/loadingPostImg.gif" data-original="image-20250307104353369-1741597095540-67.png" alt="image-20250307104353369"></p><p>主要减少了网络io导致的性能变慢</p><p><img src="/loadingPostImg.gif" data-original="image-20250307104605197-1741597095540-68.png" alt="image-20250307104605197"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307104657405-1741597095540-69.png" alt="image-20250307104657405"></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307104933187-1741597095541-70.png" alt="image-20250307104933187"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307105049847-1741597095541-71.png" alt="image-20250307105049847"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307105230866-1741597095541-72.png" alt="image-20250307105230866"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307105315548-1741597095541-73.png" alt="image-20250307105315548"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307105333718-1741597095541-74.png" alt="image-20250307105333718"></p><h3 id="SQL执行慢，如何分析？"><a href="#SQL执行慢，如何分析？" class="headerlink" title="SQL执行慢，如何分析？"></a>SQL执行慢，如何分析？</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307113223040-1741597095541-75.png" alt="image-20250307113223040"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307113411741-1741597095541-76.png" alt="image-20250307113411741"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307113639851-1741597095542-79.png" alt="image-20250307113639851"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307113828942-1741597095541-77.png" alt="image-20250307113828942"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307114022293-1741597095542-78.png" alt="image-20250307114022293"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307114240501-1741597095542-80.png" alt="image-20250307114240501"></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307114626429-1741597095542-81.png" alt="image-20250307114626429"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307131955893-1741597095542-82.png" alt="image-20250307131955893"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307132513960-1741597095542-83.png" alt="image-20250307132513960"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307132716283-1741597095542-85.png" alt="image-20250307132716283"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307132824751-1741597095542-84.png" alt="image-20250307132824751"></p><h3 id="聚集索引-回表查询"><a href="#聚集索引-回表查询" class="headerlink" title="聚集索引 回表查询"></a>聚集索引 回表查询</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307145403027-1741597095543-86.png" alt="image-20250307145403027"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307145524115-1741597095543-87.png" alt="image-20250307145524115">       </p><p><img src="/loadingPostImg.gif" data-original="image-20250307145812061-1741597095543-88.png" alt="image-20250307145812061"></p><p>单独给字段创建的索引大部分都是二级索引</p><p><img src="/loadingPostImg.gif" data-original="image-20250307145934766-1741597095543-89.png" alt="image-20250307145934766"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307150014194-1741597095543-90.png" alt="image-20250307150014194"></p><h3 id="覆盖索引-超大分页优化"><a href="#覆盖索引-超大分页优化" class="headerlink" title="覆盖索引 超大分页优化"></a>覆盖索引 超大分页优化</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307150400421-1741597095544-92.png" alt="image-20250307150400421"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307150817237-1741597095544-91.png" alt="image-20250307150817237"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307150930546-1741597095544-93.png" alt="image-20250307150930546"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307151029185-1741597095544-94.png" alt="image-20250307151029185"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307151059960-1741597095544-95.png" alt="image-20250307151059960"></p><h3 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307151606657-1741597095544-96.png" alt="image-20250307151606657"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307151751332-1741597095545-97.png" alt="image-20250307151751332"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307152249752-1741597095545-98.png" alt="image-20250307152249752"></p><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307152615143-1741597095545-99.png" alt="image-20250307152615143"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307152804448-1741597095545-100.png" alt="image-20250307152804448"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307152824137-1741597095545-101.png" alt="image-20250307152824137"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307152922851-1741597095545-102.png" alt="image-20250307152922851"></p><p>索引上发生任何的类型转换，会造成索引失效。</p><p><img src="/loadingPostImg.gif" data-original="image-20250307153035878-1741597095546-107.png" alt="image-20250307153035878"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307153107460-1741597095545-103.png" alt="image-20250307153107460"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307153206228-1741597095545-104.png" alt="image-20250307153206228"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307153221683-1741597095546-105.png" alt="image-20250307153221683"></p><h3 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307153312551-1741597095546-106.png" alt="image-20250307153312551"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307154555340-1741597095546-108.png" alt="image-20250307154555340"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307154811869-1741597095546-109.png" alt="image-20250307154811869"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307155226331-1741597095546-110.png" alt="image-20250307155226331"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307155333818-1741597095546-111.png" alt="image-20250307155333818"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307155805512-1741597095546-112.png" alt="image-20250307155805512"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>ACID</p><p><img src="/loadingPostImg.gif" data-original="image-20250307155453675-1741597095547-113.png" alt="image-20250307155453675"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307155557238-1741597095547-115.png" alt="image-20250307155557238"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307155816381-1741597095547-114.png" alt="image-20250307155816381"></p><h3 id="并发事务问题-amp-隔离级别"><a href="#并发事务问题-amp-隔离级别" class="headerlink" title="并发事务问题&amp;隔离级别"></a>并发事务问题&amp;隔离级别</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307160218559-1741597095548-119.png" alt="image-20250307160218559"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307160227494-1741597095547-116.png" alt="image-20250307160227494"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307160345863-1741597095547-117.png" alt="image-20250307160345863"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307160439018-1741597095548-118.png" alt="image-20250307160439018"></p><p>前提：已解决不可重复读，在一个事务内查询同一条数据，不管多少次都是相同的数据。</p><p>解决方案：隔离</p><p><img src="/loadingPostImg.gif" data-original="image-20250307160904374-1741597095548-120.png" alt="image-20250307160904374"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307161031545-1741597095548-121.png" alt="image-20250307161031545"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307161118980-1741597095548-122.png" alt="image-20250307161118980"></p><h3 id="undo-log-amp-redo-log"><a href="#undo-log-amp-redo-log" class="headerlink" title="undo log &amp; redo log"></a>undo log &amp; redo log</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307161712513-1741597095548-123.png" alt="image-20250307161712513"></p><p>随机磁盘io 👉 顺序磁盘io</p><p><img src="/loadingPostImg.gif" data-original="image-20250307161903678-1741597095549-124.png" alt="image-20250307161903678"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307162029181-1741597095549-125.png" alt="image-20250307162029181"></p><p> <img src="/loadingPostImg.gif" data-original="image-20250307162059599-1741597095549-126.png" alt="image-20250307162059599"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307162114522-1741597095549-127.png" alt="image-20250307162114522"></p><h3 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307162325506-1741597095549-128.png" alt="image-20250307162325506"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307163341613-1741597095549-129.png" alt="image-20250307163341613"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307163621360-1741597095549-130.png" alt="image-20250307163621360"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307163836494-1741597095550-131.png" alt="image-20250307163836494"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307164409055-1741597095550-132.png" alt="image-20250307164409055"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307164547053-1741597095550-133.png" alt="image-20250307164547053"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307165250656-1741597095550-134.png" alt="image-20250307165250656"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307165344781-1741597095550-135.png" alt="image-20250307165344781"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307165725444-1741597095550-136.png" alt="image-20250307165725444"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307165810614-1741597095550-137.png" alt="image-20250307165810614"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170025268-1741597095550-138.png" alt="image-20250307170025268"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170048020-1741597095550-139.png" alt="image-20250307170048020"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307170206100-1741597095551-140.png" alt="image-20250307170206100"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170455146-1741597095551-141.png" alt="image-20250307170455146"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170523328-1741597095551-142.png" alt="image-20250307170523328"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170532191-1741597095551-143.png" alt="image-20250307170532191"></p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307170655694-1741597095552-144.png" alt="image-20250307170655694"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307170907038-1741597095552-145.png" alt="image-20250307170907038"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171055700-1741597095552-146.png" alt="image-20250307171055700"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171201494-1741597095552-147.png" alt="image-20250307171201494"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171256410-1741597095552-148.png" alt="image-20250307171256410"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171453949-1741597095552-149.png" alt="image-20250307171453949"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171716780-1741597095552-152.png" alt="image-20250307171716780"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307171752353-1741597095552-150.png" alt="image-20250307171752353"></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="单例bean是线程安全的吗？"><a href="#单例bean是线程安全的吗？" class="headerlink" title="单例bean是线程安全的吗？"></a>单例bean是线程安全的吗？</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307172034398-1741597095552-151.png" alt="image-20250307172034398"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307172621964-1741597095553-155.png" alt="image-20250307172621964"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307172737731-1741597095552-153.png" alt="image-20250307172737731"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307172753838-1741597095553-154.png" alt="image-20250307172753838"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>Spring管理的事务底层用AOP，AOP底层为动态代理。</p><p><img src="/loadingPostImg.gif" data-original="image-20250307173025081-1741597095553-157.png" alt="image-20250307173025081"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307173736823-1741597095553-156.png" alt="image-20250307173736823"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307173944864-1741597095553-158.png" alt="image-20250307173944864"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307174101768-1741597095553-161.png" alt="image-20250307174101768"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307174121112-1741597095553-159.png" alt="image-20250307174121112"></p><h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><p><img src="/loadingPostImg.gif" data-original="image-20250307213608889-1741597095553-160.png" alt="image-20250307213608889"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307214705740-1741597095554-162.png" alt="image-20250307214705740"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307214716672-1741597095554-163.png" alt="image-20250307214716672"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307215338576-1741597095554-165.png" alt="image-20250307215338576"></p><p><img src="/loadingPostImg.gif" data-original="image-20250307215925288-1741597095554-164.png" alt="image-20250307215925288"></p><h3 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h3><p><img src="/loadingPostImg.gif" data-original="image-20250308152022023-1741597095554-170.png" alt="image-20250308152022023"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308153221548-1741597095554-168.png" alt="image-20250308153221548"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308155441165-1741597095554-166.png" alt="image-20250308155441165"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308155450456-1741597095554-167.png" alt="image-20250308155450456"></p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p><img src="/loadingPostImg.gif" data-original="image-20250308155554496-1741597095554-169.png" alt="image-20250308155554496"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308160022728-1741597095555-176.png" alt="image-20250308160022728"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308160203423-1741597095554-171.png" alt="image-20250308160203423"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308160526443-1741597095554-172.png" alt="image-20250308160526443"></p><p>三缓解决初始化过程中的循环依赖，不能解决构造函数产生的循环依赖。</p><p><img src="/loadingPostImg.gif" data-original="image-20250308160717992-1741597095554-173.png" alt="image-20250308160717992"></p><p>解决：延迟加载@Lazy</p><p><img src="/loadingPostImg.gif" data-original="image-20250308160754000-1741597095554-174.png" alt="image-20250308160754000"></p><p>工厂生成的对象统一放在二级缓存，直接从二级缓存获取a对象，而不是一直调用ObjectFactory创建，which可能产生多例。</p><p><img src="/loadingPostImg.gif" data-original="image-20250308161133969-1741597095554-175.png" alt="image-20250308161133969"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308161209008-1741597095555-177.png" alt="image-20250308161209008"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308161444245-1741597095555-178.png" alt="image-20250308161444245"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308161454396-1741597095555-179.png" alt="image-20250308161454396"></p><h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><p><img src="/loadingPostImg.gif" data-original="image-20250308162236478-1741597095555-183.png" alt="image-20250308162236478"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308162246433-1741597095555-180.png" alt="image-20250308162246433"></p><ul><li>DispatcherServlet：调度中心</li><li>具体的处理器：Controller中的某个方法</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250308162618199-1741597095555-181.png" alt="image-20250308162618199"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308162656986-1741597095555-182.png" alt="image-20250308162656986"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308162728461-1741597095555-184.png" alt="image-20250308162728461"></p><h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p><img src="/loadingPostImg.gif" data-original="image-20250308162859691-1741597095555-185.png" alt="image-20250308162859691"></p><p>@Bean 当前方法返回值放到Spring容器中</p><p><img src="/loadingPostImg.gif" data-original="image-20250308163352509-1741597095555-186.png" alt="image-20250308163352509"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163325442-1741597095556-190.png" alt="image-20250308163325442"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163413687-1741597095555-187.png" alt="image-20250308163413687"></p><h3 id="Spring框架常见注解"><a href="#Spring框架常见注解" class="headerlink" title="Spring框架常见注解"></a>Spring框架常见注解</h3><p>@Scope 作用范围 singleton prototype 一般开发为单例</p><p><img src="/loadingPostImg.gif" data-original="image-20250308163656782-1741597095556-188.png" alt="image-20250308163656782"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163827842-1741597095556-189.png" alt="image-20250308163827842"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163854864-1741597095556-192.png" alt="image-20250308163854864"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163923580-1741597095556-191.png" alt="image-20250308163923580"></p><p><img src="/loadingPostImg.gif" data-original="image-20250308163935761-1741597095556-193.png" alt="image-20250308163935761"></p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/loadingPostImg.gif" data-original="image-20250309143519508-1741597095556-196.png" alt="image-20250309143519508"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309143236490-1741597095556-194.png" alt="image-20250309143236490"></p><ul><li>MappedStatement对象定义了某些标签中的信息</li><li><p>resultMaps接收返回结果的封装</p></li><li><p>java类型转换为数据库支持类型，执行完成后再由数据库支持类型转换为java类型</p></li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250309143608604-1741597095556-195.png" alt="image-20250309143608604"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309143738469-1741597095557-199.png" alt="image-20250309143738469"></p><h3 id="延迟加载使用及原理"><a href="#延迟加载使用及原理" class="headerlink" title="延迟加载使用及原理"></a>延迟加载使用及原理</h3><p><img src="/loadingPostImg.gif" data-original="image-20250309144807610-1741597095556-197.png" alt="image-20250309144807610"></p><p>局部设置：</p><p><img src="/loadingPostImg.gif" data-original="image-20250309145017519-1741597095556-198.png" alt="image-20250309145017519"></p><p>全局设置：</p><p><img src="/loadingPostImg.gif" data-original="image-20250309145138444-1741597095557-205.png" alt="image-20250309145138444"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309145243825-1741597095557-200.png" alt="image-20250309145243825"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309145427154-1741597095557-201.png" alt="image-20250309145427154"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309145441269-1741597095557-210.png" alt="image-20250309145441269"></p><h3 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h3><p><img src="/loadingPostImg.gif" data-original="image-20250309145752963-1741597095557-202.png" alt="image-20250309145752963"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309150605298-1741597095557-203.png" alt="image-20250309150605298"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309150828057-1741597095557-204.png" alt="image-20250309150828057"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309151206459-1741597095557-206.png" alt="image-20250309151206459"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309151138302-1741597095557-207.png" alt="image-20250309151138302"></p><p><img src="/loadingPostImg.gif" data-original="image-20250309151241247-1741597095557-208.png" alt="image-20250309151241247"></p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h3 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310093515632-1741597095557-209.png" alt="image-20250310093515632"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310093534691-1741597095557-211.png" alt="image-20250310093534691"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310093556338-1741597095558-214.png" alt="image-20250310093556338"></p><p>注册中心Eureka、Nacos</p><p><img src="/loadingPostImg.gif" data-original="image-20250310100324432-1741597095558-217.png" alt="image-20250310100324432"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310100444068-1741597095558-212.png" alt="image-20250310100444068"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310100529000-1741597095558-213.png" alt="image-20250310100529000"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310100821686-1741597095558-215.png" alt="image-20250310100821686"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310100942620-1741597095558-216.png" alt="image-20250310100942620"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310102254100-1741597095558-218.png" alt="image-20250310102254100"></p><h3 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310102925263-1741597095558-219.png" alt="image-20250310102925263"></p><blockquote><ul><li><code>BestAvailableRule</code> 只关注服务器的并发连接数，直接选择连接数最少的服务器。</li><li><code>AvailabilityFilteringRule</code> 先过滤掉不可用（熔断）和高负载的服务器，然后使用轮询算法从剩余的可用服务器中选择。</li></ul></blockquote><p>默认策略<strong>ZoneAvoidanceRule</strong></p><p><img src="/loadingPostImg.gif" data-original="image-20250310103755630-1741597095559-220.png" alt="image-20250310103755630"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104000565-1741597095559-221.png" alt="image-20250310104000565"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104013246-1741597095559-222.png" alt="image-20250310104013246"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104119058-1741597095559-223.png" alt="image-20250310104119058"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104137360-1741597095559-224.png" alt="image-20250310104137360"></p><h3 id="服务雪崩、熔断降级"><a href="#服务雪崩、熔断降级" class="headerlink" title="服务雪崩、熔断降级"></a>服务雪崩、熔断降级</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310104338600-1741597095560-227.png" alt="image-20250310104338600"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104556384-1741597095559-226.png" alt="image-20250310104556384"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104748316-1741597095559-225.png" alt="image-20250310104748316"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104854173-1741597095560-234.png" alt="image-20250310104854173"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310104908365-1741597095560-228.png" alt="image-20250310104908365"></p><h3 id="微服务监控"><a href="#微服务监控" class="headerlink" title="微服务监控"></a>微服务监控</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310113801490-1741597095560-231.png" alt="image-20250310113801490"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310114224763-1741597095560-229.png" alt="image-20250310114224763"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310114633171-1741597095560-230.png" alt="image-20250310114633171"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310114642810-1741597095561-237.png" alt="image-20250310114642810"></p><h2 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h2><h3 id="微服务限流"><a href="#微服务限流" class="headerlink" title="微服务限流"></a>微服务限流</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310143412720-1741597095560-232.png" alt="image-20250310143412720"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310143706292-1741597095562-246.png" alt="image-20250310143706292"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310145212785-1741597095560-233.png" alt="image-20250310145212785"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310145608449-1741597095561-235.png" alt="image-20250310145608449"></p><p>令牌存储到Redis，网关配置文件需要配置Redis连接。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310145935134-1741597095561-236.png" alt="image-20250310145935134"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310145952301-1741597095561-238.png" alt="image-20250310145952301"></p><h3 id="分布式系统理论"><a href="#分布式系统理论" class="headerlink" title="分布式系统理论"></a>分布式系统理论</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310150122038-1741597095561-239.png" alt="image-20250310150122038"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310150158684-1741597095561-241.png" alt="image-20250310150158684"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310150806457-1741597095561-240.png" alt="image-20250310150806457"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310150958149-1741597095561-242.png" alt="image-20250310150958149"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310151318734-1741597095561-243.png" alt="image-20250310151318734"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310151620954-1741597095562-245.png" alt=""></p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310151847712-1741597095562-247.png" alt="image-20250310151847712"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310151826273-1741597095561-244.png" alt="image-20250310151826273"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310154220497-1741597095562-248.png" alt="image-20250310154220497"></p><p>主要采用cp模式</p><p><img src="/loadingPostImg.gif" data-original="image-20250310154347413-1741597095562-251.png" alt="image-20250310154347413"></p><p>用的最多的模式，主要采用AP模式</p><p><img src="/loadingPostImg.gif" data-original="image-20250310154548453-1741597095563-259.png" alt="image-20250310154548453"></p><p>AP模式。但是tcc三步操作都需要代码完成，而非XA和AT框架自动完成。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310154848063-1741597095562-249.png" alt="image-20250310154848063"></p><p>保证事务最终一致性，并没有特别强一致。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310155125612-1741597095562-250.png" alt="image-20250310155125612"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310155153620-1741597095562-253.png" alt="image-20250310155153620"></p><h3 id="分布式服务的接口幂等性设计"><a href="#分布式服务的接口幂等性设计" class="headerlink" title="分布式服务的接口幂等性设计"></a>分布式服务的接口幂等性设计</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310155254660-1741597095562-252.png" alt="image-20250310155254660"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310160117118-1741597095562-254.png" alt="image-20250310160117118"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310160322350-1741597095562-255.png" alt="image-20250310160322350"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310160512495-1741597095563-256.png" alt="image-20250310160512495"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310161027626-1741597095563-257.png" alt="image-20250310161027626"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310161106640-1741597095563-258.png" alt="image-20250310161106640"></p><h3 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h3><ul><li>SpringTask集群之后可能多个实例都会执行同一个任务</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250310161407759-1741597095563-261.png" alt="image-20250310161407759"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310161552359-1741597095563-260.png" alt="image-20250310161552359"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310161821956-1741597095563-262.png" alt="image-20250310161821956"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310162053525-1741597095563-263.png" alt="image-20250310162053525"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310162151380-1741597095563-264.png" alt="image-20250310162151380"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310162204317-1741597095564-265.png" alt="image-20250310162204317"></p><h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p><img src="/loadingPostImg.gif" data-original="image-20250310163011125-1741597095564-266.png" alt="image-20250310163011125"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>MQ在微服务中必不可少，微服务异步调用需要MQ技术。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310163546503-1741597095564-268.png" alt="image-20250310163546503"></p><h3 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310163723524-1741597095564-267.png" alt="image-20250310163723524"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310164245134-1741597095564-270.png" alt="image-20250310164245134"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310164501497-1741597095564-269.png" alt="image-20250310164501497"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310164752103-1741597095565-271.png" alt="image-20250310164752103"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310164947879-1741597095565-272.png" alt="image-20250310164947879"></p><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310171205621.png" alt="image-20250310171205621"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310172455163.png" alt="image-20250310172455163"></p><h3 id="死信交换机（延迟队列）"><a href="#死信交换机（延迟队列）" class="headerlink" title="死信交换机（延迟队列）"></a>死信交换机（延迟队列）</h3><ul><li>使用死信交换机实现延迟队列</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250310172730295.png" alt="image-20250310172730295"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310172923737.png" alt="image-20250310172923737"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310172957243.png" alt="image-20250310172957243"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310173043273.png" alt="image-20250310173043273"></p><ul><li>以消息和队列间较短的TTL为准</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250310173147596.png" alt="image-20250310173147596"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310173350288.png" alt="image-20250310173350288"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310173552850.png" alt="image-20250310173552850"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310173614389.png" alt="image-20250310173614389"></p><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310195457932.png" alt="image-20250310195457932"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310195702609.png" alt="image-20250310195702609"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310195934436.png" alt="image-20250310195934436"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310195912683.png" alt="image-20250310195912683"></p><h3 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310200213476.png" alt="image-20250310200213476"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310200625374.png" alt="image-20250310200625374"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310200848240.png" alt="image-20250310200848240"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310200937264.png" alt="image-20250310200937264"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310200951423.png" alt="image-20250310200951423"></p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li>Kafka集群由多个broker组成，每个broker就是一个Kafka实例</li></ul><h3 id="消息不丢失-1"><a href="#消息不丢失-1" class="headerlink" title="消息不丢失"></a>消息不丢失</h3><p><img src="/loadingPostImg.gif" data-original="image-20250310201059691.png" alt="image-20250310201059691"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310215550671.png" alt="image-20250310215550671"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310215731416.png" alt="image-20250310215731416"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310215917187.png" alt="image-20250310215917187"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310222416379.png" alt="image-20250310222416379"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310222445688.png" alt="image-20250310222445688"></p><p>消费完消息后设置异步提交，在finally代码块中设置同步提交。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310222636324.png" alt="image-20250310222636324"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310222705855.png" alt="image-20250310222705855"></p><h3 id="消费顺序性"><a href="#消费顺序性" class="headerlink" title="消费顺序性"></a>消费顺序性</h3><p>默认情况计算key的Hashcode值，根据哈希值找到不同分区进行存储。</p><p><img src="/loadingPostImg.gif" data-original="image-20250310230039553.png" alt="image-20250310230039553"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310230103713.png" alt="image-20250310230103713"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310230139078.png" alt="image-20250310230139078"></p><p><img src="/loadingPostImg.gif" data-original="image-20250310230151136.png" alt="image-20250310230151136"></p><h3 id="高可用机制-1"><a href="#高可用机制-1" class="headerlink" title="高可用机制"></a>高可用机制</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311001833193.png" alt="image-20250311001833193"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311003435252.png" alt="image-20250311003435252"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101054849.png" alt="image-20250311101054849"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101238798.png" alt="image-20250311101238798"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101313068.png" alt="image-20250311101313068"></p><h3 id="数据清理机制"><a href="#数据清理机制" class="headerlink" title="数据清理机制"></a>数据清理机制</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311101517878.png" alt="image-20250311101517878"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101615598.png" alt="image-20250311101615598"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101659226.png" alt="image-20250311101659226"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311101712007.png" alt="image-20250311101712007"></p><h3 id="高性能的设计"><a href="#高性能的设计" class="headerlink" title="高性能的设计"></a>高性能的设计</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311102134636.png" alt="image-20250311102134636"></p><ul><li>拷贝次数相比socket连接由4👉2</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250311102259149.png" alt="image-20250311102259149"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311102325016.png" alt="image-20250311102325016"></p><h1 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h1><p><img src="/loadingPostImg.gif" data-original="image-20250311112954909.png" alt="image-20250311112954909"></p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p><img src="/loadingPostImg.gif" data-original="image-20250311113514655.png" alt="image-20250311113514655"></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311114126497.png" alt="image-20250311114126497"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311114502566.png" alt="image-20250311114502566"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311143343885.png" alt="image-20250311143343885"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311143553926.png" alt="image-20250311143553926"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311143616691.png" alt="image-20250311143616691"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311143703721.png" alt="image-20250311143703721"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311145653306.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="image-20250311151342926.png" alt="image-20250311151342926"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311151705722.png" alt="image-20250311151705722"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311153049286.png" alt="image-20250311153049286"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311153120878.png" alt="image-20250311153120878"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311153323710.png" alt="image-20250311153323710"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311153634872.png" alt="image-20250311153634872"></p><p>通过System.arraycopy()进行数组拷贝，是两个不同的对象。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311153857924.png" alt="image-20250311153857924"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311153936813.png" alt="image-20250311153936813"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311154006913.png" alt="image-20250311154006913"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311154125156.png" alt="image-20250311154125156"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311154256836.png" alt="image-20250311154256836"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311154406387.png" alt="image-20250311154406387"></p><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311155214126.png" alt="image-20250311155214126"></p><ol><li>内存空间占用<ul><li>ArrayList底层是数组，内存连续，节省内存</li><li>LinkedList是双向链表，需要存储数据和两个指针，更占用内存</li></ul></li></ol><p><img src="/loadingPostImg.gif" data-original="image-20250311155431857.png" alt="image-20250311155431857"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311155703642.png" alt="image-20250311155703642"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311155747120.png" alt="image-20250311155747120"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311155834158.png" alt="image-20250311155834158"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311155908978.png" alt="image-20250311155908978"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311160004892.png" alt="image-20250311160004892"></p><p>为什么使用红黑树？</p><p><img src="/loadingPostImg.gif" data-original="image-20250311160046194.png" alt="image-20250311160046194"><img src="/loadingPostImg.gif" data-original="image-20250311160503061.png" alt="image-20250311160503061"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311160659279.png" alt="image-20250311160659279"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311160830800.png" alt="image-20250311160830800"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311161752502.png" alt="image-20250311161752502"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162116944.png" alt="image-20250311162116944"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162052422.png" alt="image-20250311162052422"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162511258.png" alt="image-20250311162511258"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162549463.png" alt="image-20250311162549463"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162631836.png" alt="image-20250311162631836"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311162745444.png" alt="image-20250311162745444"></p><ul><li>伪造很多key造成哈希冲突在数组中产生大量链表</li></ul><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311164947608.png" alt="image-20250311164947608"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311165051388.png" alt="image-20250311165051388"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311165328772.png" alt="image-20250311165328772"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311171044003.png" alt="image-20250311171044003"></p><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311164110247.png" alt="image-20250311164110247"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311164211472.png" alt="image-20250311164211472"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311170551749.png" alt="image-20250311170551749"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311172021155.png" alt="image-20250311172021155"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311172834412.png" alt="image-20250311172834412"></p><ul><li>计算对象的hashCode()</li><li>调用hash()方法进行二次哈希，hashcode值右移16位再异或运算，让哈希分布更均匀</li><li>最后(capacity - 1) &amp; hash 得到索引</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250311172906746.png" alt="image-20250311172906746"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311173313177-1741685594241-1.png" alt="image-20250311173313177"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311173709689.png" alt="image-20250311173709689"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311173845769.png" alt="image-20250311173845769"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><h3 id="Java常见的集合类"><a href="#Java常见的集合类" class="headerlink" title="Java常见的集合类"></a>Java常见的集合类</h3></li></ul><blockquote><p><strong>面试官</strong>：说一说Java提供的常见集合？（画一下集合结构图）</p><p><strong>候选人</strong>：</p><p>嗯~~，好的。</p><p>在java中提供了两大类的集合框架，主要分为两类：</p><p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p><ul><li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrayList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。</li><li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li></ul></blockquote><ul><li><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3></li></ul><blockquote><p><strong>面试官</strong>：ArrayList底层是如何实现的？</p><p><strong>候选人</strong>：</p><p>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧</p><p>第一：确保数组已使用长度（size）加1之后足够存下下一个数据 </p><p>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p><p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 </p><p>第四：返回添加成功布尔值。 </p><p><strong>面试官</strong>：ArrayList list=new ArrayList(10)中的list扩容几次</p><p><strong>候选人</strong>：</p><p>​        是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)</p><p><strong>面试官</strong>：是的</p><p><strong>候选人</strong>：</p><p>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p><hr><p><strong>面试官</strong>：如何实现数组和List之间的转换</p><p><strong>候选人</strong>：</p><p>​        嗯，这个在我们平时开发很常见</p><p>​    数组转list，可以使用jdk自动的一个工具类Arrays，里面有一个asList方法可以转换为数组</p><p>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p><p><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p><strong>候选人</strong>：</p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><hr><p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p><p><strong>候选人</strong>：</p><p>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p><p>1，从操作数据效率来说</p><p>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</p><p>查找（未知索引）： ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</p><p>新增和删除</p><ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul><p>2，从内存空间占用来说</p><p>ArrayList底层是数组，内存连续，节省内存</p><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p><p>3，从线程安全来说，ArrayList和LinkedList都不是线程安全的</p><p><strong>面试官</strong>：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p><p><strong>候选人</strong>：</p><p>嗯，是这样的，主要有两种解决方案：</p><p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p><p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p><p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p><p>LinkedList 换成ConcurrentLinkedQueue来使用</p></blockquote><ul><li><h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3></li></ul><blockquote><p><strong>面试官</strong>：说一下HashMap的实现原理？</p><p><strong>候选人</strong>：</p><p>​        嗯。它主要分为了以下几个部分：</p><p>1，底层使用hash表数据结构，即数组+（链表 | 红黑树）</p><p>2，添加数据时，计算key的值确定元素在数组中的下标</p><p>​        key相同则替换</p><p>​        不同则存入链表或红黑树中</p><p>3，获取数据通过key的hash计算数组下标获取元素</p><p><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别</p><p><strong>候选人</strong>：</p><ul><li>JDK1.8之前采用的拉链法，数组+链表</li><li>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</li></ul><p><strong>面试官</strong>：好的，你能说下HashMap的put方法的具体流程吗？</p><p><strong>候选人</strong>：</p><p>嗯好的。</p><ol><li>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</li><li>根据键值key计算hash值得到数组索引</li><li>判断table[i]==null，条件成立，直接新建节点添加</li><li>如果table[i]==null ,不成立</li></ol><p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p><ol><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li></ol><p><strong>面试官</strong>：好的，刚才你多次介绍了hashmap的扩容，能讲一讲HashMap的扩容机制吗？</p><p><strong>候选人</strong>：</p><p>好的</p><ul><li>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li><li>每次扩容的时候，都是扩容之前容量的2倍； </li><li>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</li><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul><p><strong>面试官</strong>：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？</p><p><strong>候选人</strong>：</p><p>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p><p>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。</p><p><strong>面试官</strong>：为何HashMap的数组长度一定是2的次幂？</p><p><strong>候选人</strong>：</p><p>嗯，好的。hashmap这么设计主要有两个原因：</p><p>第一：</p><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p><p>第二：</p><p>扩容时重新计算索引效率更高：在进行扩容时会进行判断 hash值按位与运算旧数组长租是否 == 0 </p><p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p><p><strong>面试官</strong>：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？</p><p><strong>候选人</strong>：</p><p>嗯，知道的。是这样</p><p>jdk7的的数据结构是：数组+链表</p><p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：<strong>读取</strong>到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p><p>当线程一再继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p><p><strong>面试官</strong>：好的，hashmap是线程安全的吗？</p><p><strong>候选人</strong>：不是线程安全的</p><p><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</p><p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p><p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p><p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解</p><hr><p><strong>面试官</strong>：HashSet与HashMap的区别？</p><p><strong>候选人</strong>：嗯，是这样。</p><p>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p><p><strong>面试官</strong>：HashTable与HashMap的区别</p><p><strong>候选人</strong>：</p><p>嗯，他们的主要区别是有几个吧</p><p>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树</p><p>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的</p><p>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash</p><p>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍</p><p>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些</p><p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p></blockquote><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p><p><img src="/loadingPostImg.gif" data-original="image-20250311210359674.png" alt="image-20250311210359674"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311210430013.png" alt="image-20250311210430013"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311210643481.png" alt="image-20250311210643481"></p><h3 id="并行与并发的区别"><a href="#并行与并发的区别" class="headerlink" title="并行与并发的区别"></a>并行与并发的区别</h3><p><img src="/loadingPostImg.gif" data-original="image-20250311233201252.png" alt="image-20250311233201252"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311233242807.png" alt="image-20250311233242807"></p><p><img src="/loadingPostImg.gif" data-original="image-20250311233354123.png" alt="image-20250311233354123"></p><blockquote><p><strong>参考回答</strong></p><p>现在都是多核CPU，在多核CPU下</p><p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p><p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p></blockquote><h3 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312110640151.png" alt="image-20250312110640151"></p><p><img src="/loadingPostImg.gif" data-original="image-20250312110610061.png" alt="image-20250312110610061"><img src="/loadingPostImg.gif" data-original="image-20250312110716286.png" alt="image-20250312110716286"></p><p><img src="/loadingPostImg.gif" data-original="image-20250312112757199.png" alt="image-20250312112757199"></p><ul><li>提交任务直接执行线程（项目中使用）</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20250312113030380.png" alt="image-20250312113030380"></p><p><img src="/loadingPostImg.gif" data-original="image-20250312113650342.png" alt="image-20250312113650342"><img src="/loadingPostImg.gif" data-original="image-20250312113714397.png" alt="image-20250312113714397"></p><blockquote><p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p><ol><li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ol><p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p><p>run(): 封装了要被线程执行的代码，可以被调用多次。</p></blockquote><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312120356907.png" alt="image-20250312120356907"></p><p><img src="/loadingPostImg.gif" data-original="image-20250312114525213.png" alt="image-20250312114525213"></p><blockquote><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p></blockquote><h3 id="线程按序执行"><a href="#线程按序执行" class="headerlink" title="线程按序执行"></a>线程按序执行</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312121225580.png" alt="image-20250312121225580"><img src="/loadingPostImg.gif" data-original="image-20250312121426696.png" alt="image-20250312121426696"></p><blockquote><p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p><p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>比如说：</p><p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p><p>notifyAll：唤醒所有wait的线程</p><p>notify：只随机唤醒一个 wait 线程</p></blockquote><h3 id="wait和sleep方法区别"><a href="#wait和sleep方法区别" class="headerlink" title="wait和sleep方法区别"></a>wait和sleep方法区别</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312121929832.png" alt="image-20250312121929832"></p><blockquote><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li>方法归属不同<ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li>醒来时机不同<ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li>锁特性不同（重点）<ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul></blockquote><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312123634831.png" alt="image-20250312123634831"></p><blockquote><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程</li></ul></blockquote><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="synchronized关键字底层原理"><a href="#synchronized关键字底层原理" class="headerlink" title="synchronized关键字底层原理"></a>synchronized关键字底层原理</h3><p>字节码：</p><blockquote><ul><li>monitorenter    上锁开始的地方</li><li>monitorexit        解锁的地方</li><li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li><li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li></ul></blockquote><p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p><p>monitor主要就是跟这个对象产生关联，如下图</p><p><img src="/loadingPostImg.gif" data-original="image-20250312144824680.png" alt="image-20250312144824680"></p><p>具体的流程：</p><ul><li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li><li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li><li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li><li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li></ul><p>参考回答：</p><ul><li>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li><li>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</li><li>在monitor内部有三个属性，分别是owner、entrylist、waitset</li><li>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</li></ul><blockquote><p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p><p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p><p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁。</p><p>monitor内部维护了三个变量</p><ul><li>WaitSet：保存处于Waiting状态的线程</li><li>EntryList：保存处于Blocked状态的线程</li><li>Owner：持有锁的线程</li></ul><p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p><p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p></blockquote><p><strong>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</strong></p><ul><li>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</li><li>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</li></ul><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p><p><img src="/loadingPostImg.gif" data-original="1741762895515-1.png" alt="img"></p><p>我们需要重点分析MarkWord对象头</p><h4 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h4><p><img src="/loadingPostImg.gif" data-original="1741763289880-4.png" alt="img"></p><blockquote><ul><li>hashcode：25位的对象标识Hash码</li><li>age：对象分代年龄占4位</li><li>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</li><li>thread：持有偏向锁的线程ID，占23位</li><li>epoch：偏向时间戳，占2位</li><li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</li><li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</li></ul></blockquote><p>我们可以通过lock的标识，来判断是哪一种锁的等级</p><ul><li>后三位是001表示无锁</li><li>后三位是101表示偏向锁</li><li>后两位是00表示轻量级锁</li><li>后两位是10表示重量级锁</li></ul><h4 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p><p><img src="/loadingPostImg.gif" data-original="1741763289880-5.png" alt="img"></p><p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img src="/loadingPostImg.gif" data-original="1741763289881-6.png" alt="img"></p><p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p><p><img src="/loadingPostImg.gif" data-original="1741763289881-7.png" alt="img"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p><p><img src="/loadingPostImg.gif" data-original="1741763289881-8.png" alt="img"></p><p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p><p><strong>解锁过程</strong></p><p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p><p><img src="/loadingPostImg.gif" data-original="1741763289881-9.png" alt="img"></p><p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p><p><img src="/loadingPostImg.gif" data-original="1741763289881-10.png" alt="img"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p><p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img src="/loadingPostImg.gif" data-original="1741763289882-11.png" alt="img"></p><p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p><p><img src="/loadingPostImg.gif" data-original="1741763289882-12.png" alt="img"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p><p><img src="/loadingPostImg.gif" data-original="1741763289882-13.png" alt="img"></p><p>解锁流程参考轻量级锁</p><blockquote><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p><p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p><p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p><p>一旦锁发生了竞争，都会升级为重量级锁</p></blockquote><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p><img src="/loadingPostImg.gif" data-original="image-20250312154625028.png" alt="image-20250312154625028"></p><p><img src="/loadingPostImg.gif" data-original="1741765633826-34.png" alt="img"></p><p>特点：</p><ol><li>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li><li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li><li>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</li></ol><blockquote><p>Java内存模型是Java虚拟机规范中定义的一种非常重要的内存模型。它的主要作用是描述Java程序中线程共享变量的访问规则，以及这些变量在JVM中是如何被存储和读取的，涉及到一些底层的细节。</p><p>这个模型有几个核心的特点。首先，所有的共享变量，包括实例变量和类变量，都被存储在主内存中，也就是计算机的RAM。需要注意的是，局部变量并不包含在内，因为它们是线程私有的，所以不存在竞争问题。</p><p>其次，每个线程都有自己的工作内存，这里保留了线程所使用的变量的工作副本。这意味着，线程对变量的所有操作，无论是读还是写，都必须在自己的工作内存中完成，而不能直接读写主内存中的变量。</p><p>最后，不同线程之间不能直接访问对方工作内存中的变量。如果线程间需要传递变量的值，那么这个过程必须通过主内存来完成。</p></blockquote><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="概述及基本工作流程"><a href="#概述及基本工作流程" class="headerlink" title="概述及基本工作流程"></a>概述及基本工作流程</h4><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p><p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p><ul><li>AbstractQueuedSynchronizer（AQS框架）</li><li>AtomicXXX类</li></ul><p>例子：</p><p>我们还是基于刚才学习过的JMM内存模型进行说明</p><ul><li>线程1与线程2都从主内存中获取变量int a = 100,同时放到各个线程的工作内存中</li></ul><p><img src="/loadingPostImg.gif" data-original="1741765849110-37.png" alt="img"></p><blockquote><p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p></blockquote><ul><li>线程1操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 101 (a++)<ul><li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li><li>如果相等，则把B的值101更新到主内存中</li></ul></li></ul><p><img src="/loadingPostImg.gif" data-original="1741765849110-38.png" alt="img"></p><ul><li>线程2操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 99(a—)<ul><li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)</li><li>不相等，则线程2更新失败</li></ul></li></ul><p><img src="/loadingPostImg.gif" data-original="1741765849110-39.png" alt="img"></p><ul><li>自旋锁操作<ul><li>因为没有加锁，所以线程不会陷入阻塞，效率较高</li><li>如果竞争激烈，重试频繁发生，效率会受影响</li></ul></li></ul><p><img src="/loadingPostImg.gif" data-original="1741765849111-40.png" alt="img"></p><p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p><h4 id="CAS-底层实现"><a href="#CAS-底层实现" class="headerlink" title="CAS 底层实现"></a>CAS 底层实现</h4><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p><p><img src="/loadingPostImg.gif" data-original="1741765849111-41.png" alt="img"></p><p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p><p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p><ul><li>ReentrantLock中的一段CAS代码</li></ul><p><img src="/loadingPostImg.gif" data-original="1741765849111-42.png" alt="img"></p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li></ul><p><strong>参考回答</strong></p><blockquote><p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p><ul><li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li><li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li><li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li></ul></blockquote><h3 id="请谈谈你对-volatile-的理解"><a href="#请谈谈你对-volatile-的理解" class="headerlink" title="请谈谈你对 volatile 的理解"></a>请谈谈你对 volatile 的理解</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><h4 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h4><blockquote><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>一个典型的例子：永不停止的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见性例子</span></span><br><span class="line"><span class="comment">// -Xint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stopped... c:&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p><p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p><p>上述代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p></blockquote><p>解决方案：</p><p>第一：在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p><p>第二：在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，</p><p>代码如下：<code>static volatile boolean stop = false;</code></p><h4 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h4><blockquote><p>@Actor保证方法内的代码在同一个线程下执行</p></blockquote><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><p><img src="/loadingPostImg.gif" data-original="1741766417465-55.png" alt="img"></p><p>在去获取上面的结果的时候，有可能会出现4种情况</p><p>情况一：先执行actor2获取结果—-&gt;0,0(正常)</p><p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—-&gt;0,1(正常)</p><p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—-&gt;1,1(正常)</p><p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—-&gt;1,0(发生了指令重排序，影响结果)</p><p><strong>解决方案</strong></p><p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p><p><img src="/loadingPostImg.gif" data-original="1741766417465-56.png" alt="img"></p><p>屏障添加的示意图</p><p><img src="/loadingPostImg.gif" data-original="1741766417466-57.png" alt="img"></p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p><strong>其他补充</strong></p><p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p><p>下面代码使用volatile修饰了x变量</p><p><img src="/loadingPostImg.gif" data-original="1741766417466-58.png" alt="img"></p><p>屏障添加的示意图</p><p><img src="/loadingPostImg.gif" data-original="1741766417466-59.png" alt="img"></p><p>这样显然是不行的，主要是因为下面两个原则：</p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p>所以，现在我们就可以总结一个volatile使用的小妙招：</p><ul><li>写变量让volatile修饰的变量的在代码最后位置</li><li>读变量让volatile修饰的变量的在代码最开始位置</li></ul><p><strong>参考回答</strong></p><blockquote><p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p><p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主内存。</p><p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化。</p></blockquote><h3 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别</p><div class="table-container"><table><thead><tr><th>synchronized</th><th>AQS</th></tr></thead><tbody><tr><td>关键字，c++ 语言实现</td><td>java 语言实现</td></tr><tr><td>悲观锁，自动释放锁</td><td>悲观锁，手动开启和关闭</td></tr><tr><td>锁竞争激烈都是重量级锁，性能差</td><td>锁竞争激烈的情况下，提供了多种解决方案</td></tr></tbody></table></div><p>AQS常见的实现类</p><ul><li>ReentrantLock      阻塞式锁</li><li>Semaphore        信号量</li><li>CountDownLatch   倒计时锁</li></ul><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ul><li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p><img src="/loadingPostImg.gif" data-original="1741767744891-70.png" alt="img"></p><blockquote><ul><li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li><li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li><li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li></ul></blockquote><p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p><p><img src="/loadingPostImg.gif" data-original="1741767744891-71.png" alt="img"></p><p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p><p><strong>AQS是公平锁吗，还是非公平锁？</strong></p><ul><li>新的线程与队列中的线程共同来抢资源，是非公平锁</li><li>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</li></ul><p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p><p><strong>参考回答</strong></p><blockquote><p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p><p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p><p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p><ul><li>tail 指向队列最后一个元素</li><li>head  指向队列中最久的一个元素</li></ul><p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p></blockquote><h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量</li><li>与synchronized一样，都支持重入</li></ul><p><img src="/loadingPostImg.gif" data-original="1741768258476-76.png" alt="img"></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p><p>查看ReentrantLock源码中的构造方法：</p><p><img src="/loadingPostImg.gif" data-original="1741768258476-77.png" alt="img"></p><p>提供了两个构造方法，不带参数的默认为非公平</p><p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p><p>其中NonfairSync和FairSync这两个类父类都是Sync</p><p><img src="/loadingPostImg.gif" data-original="1741768258476-78.png" alt="img"></p><p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p><p><img src="/loadingPostImg.gif" data-original="1741768258476-79.png" alt="img"></p><p><strong>工作流程</strong></p><p><img src="/loadingPostImg.gif" data-original="1741768258476-80.png" alt="img"></p><ul><li>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</li><li>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</li><li>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</li><li>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</li></ul><p><strong>参考回答</strong></p><blockquote><p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p><p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p><p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p></blockquote><h3 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别 ?"></a>synchronized和Lock有什么区别 ?</h3><p><strong>参考回答</strong></p><blockquote><p>第一，语法层面</p><ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li></ul><p>第二，功能层面</p><ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li></ul><p>第三，性能层面</p><ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul><p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p></blockquote><h3 id="死锁产生的条件是什么？"><a href="#死锁产生的条件是什么？" class="headerlink" title="死锁产生的条件是什么？"></a>死锁产生的条件是什么？</h3><p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p>例如：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><p><img src="/loadingPostImg.gif" data-original="1741768258476-81.png" alt="img"></p><p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p><p><strong>参考回答</strong></p><blockquote><p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p><p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p></blockquote><h3 id="如何进行死锁诊断？"><a href="#如何进行死锁诊断？" class="headerlink" title="如何进行死锁诊断？"></a>如何进行死锁诊断？</h3><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p><p>步骤如下：</p><p>第一：查看运行的线程</p><p><img src="/loadingPostImg.gif" data-original="1741768258476-82.png" alt="img"></p><p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p><p>运行命令：<code>jstack -l 46032</code></p><p><img src="/loadingPostImg.gif" data-original="1741768258476-83.png" alt="img"></p><p><strong>其他解决工具，可视化工具</strong></p><ul><li>jconsole</li></ul><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><ul><li>VisualVM：故障处理工具</li></ul><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><p><strong>参考回答</strong></p><blockquote><p>我们只需要通过jdk自动的工具就能搞定</p><p>我们可以先通过jps来查看当前java程序运行的进程id</p><p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li></ul><h4 id="JDK1-7中concurrentHashMap"><a href="#JDK1-7中concurrentHashMap" class="headerlink" title="JDK1.7中concurrentHashMap"></a>JDK1.7中concurrentHashMap</h4><p>数据结构</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-84.png" alt="img"></p><blockquote><ul><li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li><li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li><li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li></ul></blockquote><p>存储流程</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-85.png" alt="img"></p><ul><li>先去计算key的hash值，然后确定segment数组下标</li><li>再通过hash值确定hashEntry数组中的下标存储数据</li><li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li></ul><h4 id="JDK1-8中concurrentHashMap"><a href="#JDK1-8中concurrentHashMap" class="headerlink" title="JDK1.8中concurrentHashMap"></a>JDK1.8中concurrentHashMap</h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p><p>采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li>CAS控制数组节点的添加</li><li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</li></ul><p><img src="/loadingPostImg.gif" data-original="1741768258477-86.png" alt="img"></p><p><strong>参考回答</strong></p><blockquote><p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li></ul><p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p><p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p></blockquote><h3 id="导致并发程序出现问题的根本原因是什么"><a href="#导致并发程序出现问题的根本原因是什么" class="headerlink" title="导致并发程序出现问题的根本原因是什么"></a>导致并发程序出现问题的根本原因是什么</h3><p>Java并发编程三大特性</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>比如，如下代码能保证原子性吗？</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-87.png" alt="img"></p><p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p><p>解决方案：</p><p>1.synchronized：同步加锁</p><p>2.JUC里面的lock：加锁</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-88.png" alt="img"></p><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p><p>比如，以下代码不能保证内存可见性</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-89.png" alt="img"></p><p>解决方案：</p><ul><li>synchronized</li><li>volatile（推荐）</li><li>LOCK</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>还是之前的例子，如下代码：</p><p><img src="/loadingPostImg.gif" data-original="1741768258477-90.png" alt="img"></p><p>解决方案：</p><ul><li>volatile</li></ul><p><strong>参考回答</strong></p><blockquote><p>Java并发编程有三大核心特性，分别是原子性、可见性和有序性。</p><p>首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。</p><p>其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。</p><p>最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>说一下线程池的核心参数（线程池的执行原理知道嘛）</h3><p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p><p><img src="/loadingPostImg.gif" data-original="1741770488190-121.png" alt="img"></p><ul><li>corePoolSize 核心线程数目</li><li>maximumPoolSize 最大线程数目 = (核心线程+救急线程的最大数目)</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li></ul><p><strong>工作流程</strong></p><p><img src="/loadingPostImg.gif" data-original="1741770488190-122.png" alt="img"></p><p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p><p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p><p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p><p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p><p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p><p>拒绝策略：</p><p>1.AbortPolicy：直接抛出异常，默认策略；</p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><p>4.DiscardPolicy：直接丢弃任务；</p><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(name, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name, <span class="type">long</span> duration)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;myThread&quot;</span>).debug(<span class="string">&quot;running...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                queue,</span><br><span class="line">                r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread&quot;</span> + c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;1&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;2&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;5&quot;</span>,<span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;6&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showState</span><span class="params">(ArrayBlockingQueue&lt;Runnable&gt; queue, ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Object&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Runnable runnable : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">callable</span> <span class="operator">=</span> FutureTask.class.getDeclaredField(<span class="string">&quot;callable&quot;</span>);</span><br><span class="line">                callable.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">adapter</span> <span class="operator">=</span> callable.get(runnable);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.concurrent.Executors$RunnableAdapter&quot;</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">task</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">                task.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get(adapter);</span><br><span class="line">                tasks.add(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LoggerUtils.main.debug(<span class="string">&quot;pool size: &#123;&#125;, queue: &#123;&#125;&quot;</span>, threadPool.getPoolSize(), tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考回答</strong></p><blockquote><p>在线程池中一共有7个核心参数：</p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p><p>拒绝策略有4种，当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p></li></ol></blockquote><h3 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h3><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p><p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p><p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p><div class="table-container"><table><thead><tr><th>LinkedBlockingQueue</th><th>ArrayBlockingQueue</th></tr></thead><tbody><tr><td>默认无界，支持有界</td><td>强制有界</td></tr><tr><td>底层是链表</td><td>底层是数组</td></tr><tr><td>是懒惰的，创建节点的时候添加数据</td><td>提前初始化 Node 数组</td></tr><tr><td>入队会生成新 Node</td><td>Node需要是提前创建好的</td></tr><tr><td>两把锁（头尾）</td><td>一把锁</td></tr></tbody></table></div><p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p><ul><li>LinkedBlockingQueue读和写各有一把锁，性能相对较好</li><li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li></ul><p><img src="/loadingPostImg.gif" data-original="1741770488191-123.png" alt="img"></p><p><strong>参考回答</strong></p><blockquote><p>Jdk中提供了很多阻塞队列，开发中常见的有两个：<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code></p><p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>是Java中两种常见的阻塞队列，它们在实现和使用上有一些关键的区别。</p><p>首先，<code>ArrayBlockingQueue</code>是一个有界队列，它在创建时必须指定容量，并且这个容量不能改变。而<code>LinkedBlockingQueue</code>默认是无界的，但也可以在创建时指定最大容量，使其变为有界队列。</p><p>其次，它们在内部数据结构上也有所不同。<code>ArrayBlockingQueue</code>是基于数组实现的，而<code>LinkedBlockingQueue</code>则是基于链表实现的。这意味着<code>ArrayBlockingQueue</code>在访问元素时可能会更快，因为它可以直接通过索引访问数组中的元素。而<code>LinkedBlockingQueue</code>则在添加和删除元素时可能更快，因为它不需要移动其他元素来填充空间。</p><p>另外，它们在加锁机制上也有所不同。<code>ArrayBlockingQueue</code>使用一把锁来控制对队列的访问，这意味着读写操作都是互斥的。而<code>LinkedBlockingQueue</code>则使用两把锁，一把用于控制读操作，另一把用于控制写操作，这样可以提高并发性能。</p></blockquote><h3 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h3><p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p><ul><li>IO密集型任务</li></ul><p>一般来说：文件读写、DB读写、网络请求等</p><p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p><ul><li>CPU密集型任务</li></ul><p>一般来说：计算型代码、Bitmap转换、Gson转换等</p><p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p><p>java代码查看CPU核数</p><p><img src="/loadingPostImg.gif" data-original="1741770488191-124.png" alt="img"></p><p><strong>参考回答</strong></p><blockquote><p>① 高并发、任务执行时间短 —&gt;（ CPU核数+1 ），减少线程上下文的切换</p><p>② 并发不高、任务执行时间长</p><ul><li>IO密集型的任务 —&gt; (CPU核数 * 2 + 1)</li><li>计算密集型任务 —&gt; （ CPU核数+1 ）</li></ul><p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考②</p></blockquote><h3 id="线程池的种类有哪些"><a href="#线程池的种类有哪些" class="headerlink" title="线程池的种类有哪些"></a>线程池的种类有哪些</h3><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p><ol><li><p>创建使用固定线程数的线程池</p><ul><li>核心线程数与最大线程数一样，没有救急线程</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li><li>适用场景：适用于任务量已知，相对耗时的任务</li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p><p><img src="/loadingPostImg.gif" data-original="1741770488191-125.png" alt="img"></p><ul><li>核心线程数和最大线程数都是1</li><li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li><li>适用场景：适用于按照顺序执行的任务</li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可缓存线程池</p><p><img src="/loadingPostImg.gif" data-original="1741770488191-126.png" alt="img"></p><ul><li>核心线程数为0</li><li>最大线程数是Integer.MAX_VALUE</li><li>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li><li>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p><p><img src="/loadingPostImg.gif" data-original="1741770488191-127.png" alt="img"></p><ul><li>适用场景：有定时和延迟执行的任务</li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>参考回答</strong></p><blockquote><p>在jdk中默认提供了4中方式创建线程池</p><p>第一个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>第二个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>第三个是： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </p><p>第四个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p></blockquote><h3 id="为什么不建议用Executors创建线程池"><a href="#为什么不建议用Executors创建线程池" class="headerlink" title="为什么不建议用Executors创建线程池"></a>为什么不建议用Executors创建线程池</h3><p>参考阿里开发手册《Java开发手册-嵩山版》</p><p><img src="/loadingPostImg.gif" data-original="1741770488191-128.png" alt="img"></p><p><strong>参考回答</strong></p><blockquote><p>其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p><p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p><p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"><a href="#线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）" class="headerlink" title="线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"></a>线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p><ul><li>其中构造参数用来初始化等待计数值</li><li>await() 用来等待计数归零</li><li>countDown() 用来让计数减一</li></ul><p><img src="/loadingPostImg.gif" data-original="1741772740822-145.png" alt="img"></p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//初始化了一个倒计时锁 参数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-waiting...&quot;</span>);</span><br><span class="line">        <span class="comment">//等待其他线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-wait end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例一（es数据批量导入）"><a href="#案例一（es数据批量导入）" class="headerlink" title="案例一（es数据批量导入）"></a>案例一（es数据批量导入）</h4><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><p>整体流程就是通过CountDownLatch+线程池配合去执行</p><p><img src="/loadingPostImg.gif" data-original="1741772740822-146.png" alt="img"></p><p>详细实现流程：</p><p><img src="/loadingPostImg.gif" data-original="1741772740822-147.png" alt="img"></p><h4 id="案例二（数据汇总）"><a href="#案例二（数据汇总）" class="headerlink" title="案例二（数据汇总）"></a>案例二（数据汇总）</h4><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p><p><img src="/loadingPostImg.gif" data-original="1741778829301-10.png" alt="img"></p><ul><li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</li><li>报表汇总</li></ul><p><img src="/loadingPostImg.gif" data-original="1741778829296-1.png" alt="img"></p><h4 id="案例三（异步调用）"><a href="#案例三（异步调用）" class="headerlink" title="案例三（异步调用）"></a>案例三（异步调用）</h4><p><img src="/loadingPostImg.gif" data-original="1741778829296-2.png" alt="img"></p><p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p><p><strong>参考回答</strong></p><blockquote><p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p><p>参考场景一：</p><p>es数据批量导入</p><p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p><p>参考场景二：</p><p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p><p>参考场景三：</p><p>《黑马头条》项目中使用的</p><p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p></blockquote><h3 id="如何控制某个方法允许并发访问线程的数量？"><a href="#如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="如何控制某个方法允许并发访问线程的数量？"></a>如何控制某个方法允许并发访问线程的数量？</h3><p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p><p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p><p>Semaphore两个重要的方法</p><p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p><p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p><p>线程任务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考回答</strong></p><blockquote><p>嗯~~，我想一下</p><p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p><p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p><p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>ThreadLocal是多线程中对于解决线程安全的一个<strong>操作类</strong>，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p><p><img src="/loadingPostImg.gif" data-original="1741778829296-3.png" alt="img"></p><h4 id="ThreadLocal基本使用"><a href="#ThreadLocal基本使用" class="headerlink" title="ThreadLocal基本使用"></a>ThreadLocal基本使用</h4><p>三个主要方法：</p><ul><li>set(value) 设置值</li><li>get() 获取值</li><li>remove() 清除值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadLocal的实现原理-amp-源码解析"><a href="#ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="ThreadLocal的实现原理&amp;源码解析"></a>ThreadLocal的实现原理&amp;源码解析</h4><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p><p><img src="/loadingPostImg.gif" data-original="1741778829296-4.png" alt="img"></p><p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p><p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p><p><strong>set方法</strong></p><p><img src="/loadingPostImg.gif" data-original="1741778829296-5.png" alt="img"></p><p><strong>get方法/remove方法</strong></p><p><img src="/loadingPostImg.gif" data-original="1741778829297-6.png" alt="img"></p><h4 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal-内存泄露问题"></a>ThreadLocal-内存泄露问题</h4><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul><li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li></ul><p><img src="/loadingPostImg.gif" data-original="1741778829297-7.png" alt="img"></p><ul><li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li></ul><p><img src="/loadingPostImg.gif" data-original="1741778829297-8.png" alt="img"></p><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p><p><img src="/loadingPostImg.gif" data-original="1741778829297-9.png" alt="img"></p><p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p><p><strong>参考回答</strong></p><blockquote><p><strong>面试官</strong>：谈谈你对ThreadLocal的理解</p><p><strong>候选人</strong>：</p><p>嗯，是这样的~~</p><p>ThreadLocal 主要功能有两个，第一个是可以实现<strong>资源对象</strong>的线程隔离，让每个线程各用各的<strong>资源对象</strong>，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p><p><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</p><p><strong>候选人</strong>：</p><p>嗯，知道一些~</p><p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p><p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p><p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p><p><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</p><p><strong>候选人</strong>：</p><p>嗯，我之前看过源码，我想一下~~</p><p>是因为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p><p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放key和value，这样就能避免内存溢出。</p></blockquote><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="JVM由那些部分组成，运行流程是什么？"><a href="#JVM由那些部分组成，运行流程是什么？" class="headerlink" title="JVM由那些部分组成，运行流程是什么？"></a>JVM由那些部分组成，运行流程是什么？</h3><p><strong>JVM是什么</strong></p><p>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</p><p>好处：</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li></ul><p><img src="/loadingPostImg.gif" data-original="1741832910567-14.png" alt="img"></p><p><strong>JVM由哪些部分组成，运行流程是什么？</strong></p><p><img src="/loadingPostImg.gif" data-original="1741832910550-1.png" alt="img"></p><p>从图中可以看出 JVM 的主要组成部分</p><ul><li>ClassLoader（类加载器）</li><li>Runtime Data Area（运行时数据区，内存分区）</li><li>Execution Engine（执行引擎）</li><li>Native Method Library（本地库接口）</li></ul><p>运行流程：</p><p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p><p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是由执行引擎运行</p><p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><h3 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h3><blockquote><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p><p>javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</p></blockquote><p><img src="/loadingPostImg.gif" data-original="1741832910550-2.png" alt="img"></p><p>​        java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。</p><p>​        那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。</p><p>​        程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</p><h3 id="你能给我详细的介绍Java堆吗"><a href="#你能给我详细的介绍Java堆吗" class="headerlink" title="你能给我详细的介绍Java堆吗?"></a>你能给我详细的介绍Java堆吗?</h3><p>线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出<strong>OutOfMemoryError</strong>异常。</p><p><img src="/loadingPostImg.gif" data-original="1741832910550-3.png" alt="img"></p><ul><li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li><li>元空间保存类信息、静态变量、常量、编译后的代码</li></ul><p>为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p><p><img src="/loadingPostImg.gif" data-original="1741832910551-4.png" alt="img"></p><h5 id="元空间-MetaSpace-介绍"><a href="#元空间-MetaSpace-介绍" class="headerlink" title="元空间(MetaSpace)介绍"></a>元空间(MetaSpace)介绍</h5><p>​        在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>​        永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。</p><p>​        那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p><p>官网给出了解释：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p><blockquote><p>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p></blockquote><p> 移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p><p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p><p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p><p>​        准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。</p><p>​        元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h3 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h3><p>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="/loadingPostImg.gif" data-original="1741832910551-5.png" alt="img"></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p></li><li><p>栈内存分配越大越好吗？</p><p>未必，默认的栈内存通常为1024k</p><p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p></li><li><p>方法内的局部变量是否线程安全？</p><p>被多线程共同调用，可能会出现线程不安全的问题。</p><ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li><li>比如以下代码：</li></ul><p><img src="/loadingPostImg.gif" data-original="1741832910551-6.png" alt="img"></p></li></ol><p><strong>栈内存溢出情况</strong></p><ul><li>栈帧过多导致栈内存溢出，典型问题：递归调用</li></ul><p><img src="/loadingPostImg.gif" data-original="1741832910551-7.png" alt="img"></p><ul><li>栈帧过大导致栈内存溢出</li></ul><h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会。</p><p>2、栈内存是线程私有的，而堆内存是线程共有的。</p><p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p><h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h3><p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p><p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</p><p>2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</p><p>3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</p><p>5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p><h3 id="能不能解释一下方法区？"><a href="#能不能解释一下方法区？" class="headerlink" title="能不能解释一下方法区？"></a>能不能解释一下方法区？</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul><li>方法区(Method Area)是各个线程共享的内存区域</li><li>主要存储类的信息、运行时常量池</li><li>虚拟机启动的时候创建，关闭虚拟机时释放</li><li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</li></ul><p><img src="/loadingPostImg.gif" data-original="1741832910551-8.png" alt="img"></p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ul><li>属于某一个类</li></ul><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p><p>比如下面是一个Application类的main方法执行，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>找到类对应的class文件存放目录，执行命令：<code>javap -v Application.class</code>   查看字节码结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">D:\code\jvm-demo\target\classes\com\heima\jvm&gt;javap -v Application.<span class="keyword">class</span></span><br><span class="line"> <span class="title class_">Classfile</span> /D:/code/jvm-demo/target/classes/com/heima/jvm/Application.<span class="keyword">class</span></span><br><span class="line">   <span class="title class_">Last</span> modified <span class="number">2023</span>-<span class="number">05</span>-<span class="number">07</span>; size <span class="number">564</span> bytes    <span class="comment">//最后修改的时间</span></span><br><span class="line">   MD5 checksum c1b64ed6491b9a16c2baab5061c64f88   <span class="comment">//签名</span></span><br><span class="line">   Compiled from <span class="string">&quot;Application.java&quot;</span>   <span class="comment">//从哪个源码编译</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.heima.jvm.Application   <span class="comment">//包名，类名</span></span><br><span class="line">   minor version: <span class="number">0</span></span><br><span class="line">   major version: <span class="number">52</span>     <span class="comment">//jdk版本</span></span><br><span class="line">   flags: ACC_PUBLIC, ACC_SUPER  <span class="comment">//修饰符</span></span><br><span class="line"> Constant pool:   <span class="comment">//常量池</span></span><br><span class="line">    #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    #<span class="number">2</span> = Fieldref           #<span class="number">21.</span>#<span class="number">22</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">    #<span class="number">3</span> = String             #<span class="number">23</span>            <span class="comment">// hello world</span></span><br><span class="line">    #<span class="number">4</span> = Methodref          #<span class="number">24.</span>#<span class="number">25</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">    #<span class="number">5</span> = Class              #<span class="number">26</span>            <span class="comment">// com/heima/jvm/Application</span></span><br><span class="line">    #<span class="number">6</span> = Class              #<span class="number">27</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">    #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">    #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">    #<span class="number">9</span> = Utf8               Code</span><br><span class="line">   #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">   #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">   #<span class="number">13</span> = Utf8               Lcom/heima/jvm/Application;</span><br><span class="line">   #<span class="number">14</span> = Utf8               main</span><br><span class="line">   #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #<span class="number">16</span> = Utf8               args</span><br><span class="line">   #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">   #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">   #<span class="number">19</span> = Utf8               Application.java</span><br><span class="line">   #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">21</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">   #<span class="number">22</span> = NameAndType        #<span class="number">29</span>:#<span class="number">30</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">23</span> = Utf8               hello world</span><br><span class="line">   #<span class="number">24</span> = Class              #<span class="number">31</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">   #<span class="number">25</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">26</span> = Utf8               com/heima/jvm/Application</span><br><span class="line">   #<span class="number">27</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">28</span> = Utf8               java/lang/System</span><br><span class="line">   #<span class="number">29</span> = Utf8               out</span><br><span class="line">   #<span class="number">30</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">   #<span class="number">31</span> = Utf8               java/io/PrintStream</span><br><span class="line">   #<span class="number">32</span> = Utf8               println</span><br><span class="line">   #<span class="number">33</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">public</span> com.heima.jvm.Application();  <span class="comment">//构造方法</span></span><br><span class="line">     descriptor: ()V</span><br><span class="line">     flags: ACC_PUBLIC</span><br><span class="line">     Code:</span><br><span class="line">       stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">          <span class="number">0</span>: aload_0</span><br><span class="line">          <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">          <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">         line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">       LocalVariableTable:</span><br><span class="line">         Start  Length  Slot  Name   Signature</span><br><span class="line">             <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/heima/jvm/Application;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;  <span class="comment">//main方法</span></span><br><span class="line">     descriptor: ([Ljava/lang/String;)V</span><br><span class="line">     flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">     Code:</span><br><span class="line">       stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">          <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">          <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">          <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">          <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">         line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">         line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">       LocalVariableTable:</span><br><span class="line">         Start  Length  Slot  Name   Signature</span><br><span class="line">             <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"> &#125;</span><br><span class="line"> SourceFile: <span class="string">&quot;Application.java&quot;</span></span><br></pre></td></tr></table></figure><p>下图，左侧是main方法的指令信息，右侧constant pool  是常量池</p><p>main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行</p><p><img src="/loadingPostImg.gif" data-original="1741832910551-9.png" alt="img"></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池是 <em>.class 文件中的，当<strong>该类被加载</strong>，它的常量池信息就会放入<strong>运行时常量池</strong>，并把里面的<em>*符号地址变为真实地址</em></em></p><p><img src="/loadingPostImg.gif" data-original="1741832910551-10.png" alt="img"></p><h3 id="你听过直接内存吗？"><a href="#你听过直接内存吗？" class="headerlink" title="你听过直接内存吗？"></a>你听过直接内存吗？</h3><ul><li><p>不属于JVM内存结构，是虚拟机的系统内存（操作系统内存）</p></li><li><p>常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理。</p></li></ul><p>举例：</p><p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p><p><img src="/loadingPostImg.gif" data-original="1741832910551-11.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">演示 ByteBuffer 作用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_9</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;E:\\a.mp4&quot;</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     io(); <span class="comment">// io 用时：1535.586957 1766.963399 1359.240226</span></span><br><span class="line">     directBuffer(); <span class="comment">// directBuffer 用时：479.295165 702.291454 562.56592</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">     <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">          <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">     ) &#123;</span><br><span class="line">         <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(bb);</span><br><span class="line">             <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             bb.flip();</span><br><span class="line">             to.write(bb);</span><br><span class="line">             bb.clear();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">     System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">io</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">     <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM);</span><br><span class="line">          <span class="type">FileOutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO);</span><br><span class="line">     ) &#123;</span><br><span class="line">         <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[_1Mb];</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buf);</span><br><span class="line">             <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">     System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p><p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p><p><img src="/loadingPostImg.gif" data-original="1741832910552-12.png" alt="img"></p><p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p><p><img src="/loadingPostImg.gif" data-original="1741832910552-13.png" alt="img"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-43.png" alt="img"></p><ul><li>类加载器：用于装载字节码文件(.class文件)</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li></ul><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p><p><strong>类加载器种类</strong></p><p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><p><strong>启动类加载器(BootStrap ClassLoader)：</strong></p><p>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME/jre/lib</strong>目录下的类库。</p></li><li><p><strong>扩展类加载器(ExtClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME/jre/lib/ext</strong>目录中的类库。</p></li><li><p><strong>应用类加载器(AppClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。</p></li><li><p><strong>自定义类加载器：</strong></p><p>开发者自定义类继承ClassLoader，实现自定义类加载规则。</p></li></ul><p>上述三种类加载器的层次结构如下如下：</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-44.png" alt="img"></p><p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p><h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p><p><img src="/loadingPostImg.gif" data-original="1741836879910-45.png" alt="img"></p><h3 id="JVM为什么采用双亲委派机制"><a href="#JVM为什么采用双亲委派机制" class="headerlink" title="JVM为什么采用双亲委派机制"></a>JVM为什么采用双亲委派机制</h3><p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>（2）为了安全，保证类库API不会被修改</p><p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">         System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-46.png" alt="img"></p><p>出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能<strong>防止恶意篡改核心API库</strong>。</p><h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-47.png" alt="img"></p><p><strong>类加载过程详解</strong></p><p>1.加载</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-48.png" alt="img"></p><ul><li>通过类的全名，获取类的二进制数据流。</li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型） </li><li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><p><img src="/loadingPostImg.gif" data-original="1741836879910-49.png" alt="img"></p><p>2.验证</p><p><img src="/loadingPostImg.gif" data-original="1741836879910-50.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="image-20250321171900355.png" alt="image-20250321171900355"></p><p><strong>验证类是否符合JVM规范，安全性检查</strong></p><p>(1)文件格式验证:是否符合Class文件的规范</p><p>(2)元数据验证</p><p>​        这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）</p><p>​        这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）</p><p>​        类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）                                                </p><p>(3)字节码验证</p><p>​        主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。</p><p>(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><p>比如：int i = 3;</p><p>字面量：3</p><p>符号引用：i</p><p>3.准备</p><p><img src="/loadingPostImg.gif" data-original="1741836879911-51.png" alt="img"></p><p><strong>为类变量分配内存并设置类变量初始值</strong></p><ul><li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li><li>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li></ul><p><img src="/loadingPostImg.gif" data-original="1741836879913-52.png" alt="img"></p><p>4.解析</p><p><img src="/loadingPostImg.gif" data-original="1741836879913-53.png" alt="img"></p><p><strong>把类中的符号引用转换为直接引用</strong></p><p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p><p><img src="/loadingPostImg.gif" data-original="1741836879913-54.png" alt="img"></p><p>5.初始化</p><p><img src="/loadingPostImg.gif" data-original="1741836879913-55.png" alt="img"></p><p><strong>对类的静态变量，静态代码块执行初始化操作</strong></p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li><li>子类访问父类静态变量，只触发父类初始化。</li></ul><p>6.使用</p><p><img src="/loadingPostImg.gif" data-original="1741836879913-56.png" alt="img"></p><p>JVM 开始从入口方法开始执行用户的程序代码</p><ul><li>调用静态类成员信息（比如：静态字段、静态方法）</li><li>使用new关键字为其创建对象实例</li></ul><p>7.卸载</p><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><p><img src="/loadingPostImg.gif" data-original="image-20250321174229058.png" alt="image-20250321174229058"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="什么是GC？"><a href="#什么是GC？" class="headerlink" title="什么是GC？"></a>什么是GC？</h3><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p><p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p><h3 id="对象什么时候可以被垃圾器回收"><a href="#对象什么时候可以被垃圾器回收" class="headerlink" title="对象什么时候可以被垃圾器回收"></a>对象什么时候可以被垃圾器回收<img src="/loadingPostImg.gif" data-original="1742798094336-37.png" alt="img"></h3><p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742798094288-1.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742798094288-2.png" alt="img"></p><p>当对象间出现了循环引用的话，则引用计数法就会失效</p><p><img src="/loadingPostImg.gif" data-original="1742798094288-3.png" alt="img"></p><p>先执行右侧代码的前4行代码</p><p><img src="/loadingPostImg.gif" data-original="1742798094289-4.png" alt="img"></p><p>目前上方的引用关系和计数都是没问题的，但是，如果代码继续往下执行，如下图</p><p><img src="/loadingPostImg.gif" data-original="1742798094289-5.png" alt="img"></p><p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p><p>优点：</p><ul><li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li><li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销。 </li><li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li><li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点） </li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p><p>会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</p><blockquote><p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p><p>局部变量，静态方法，静态变量，类信息</p><p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p></blockquote><p><img src="/loadingPostImg.gif" data-original="1742798094289-6.png" alt="img"></p><p>X,Y这两个节点是可回收的，但是<strong>并不会马上的被回收！！</strong> 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先<strong>会判断这个对象是否执行了finalize方法</strong>，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。</p><p>​        finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</p><p><strong>GC ROOTS：</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">     demo = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法区中类静态属性引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b.a = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法区中常量引用的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Demo</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        demo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h3 id="JVM-垃圾回收算法有哪些"><a href="#JVM-垃圾回收算法有哪些" class="headerlink" title="JVM 垃圾回收算法有哪些"></a>JVM 垃圾回收算法有哪些</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p><p>1.根据可达性分析算法得出的垃圾进行标记</p><p>2.对这些标记为可回收的内容进行垃圾回收</p><p><img src="/loadingPostImg.gif" data-original="1742798094289-7.png" alt="img"></p><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p><p>同样，标记清除算法也是有缺点的：</p><ul><li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>​        复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><p>​        如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 </p><p><img src="/loadingPostImg.gif" data-original="1742798094289-8.png" alt="img"></p><p>1）将内存区域分成两部分，每次操作其中一个。</p><p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p><p>3）周而复始。</p><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><ul><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li></ul><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>​        标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><p><img src="/loadingPostImg.gif" data-original="1742798094289-9.png" alt="img"></p><p>1）标记垃圾。</p><p>2）需要清除向右边走，不需要清除的向左边走。</p><p>3）清除边界以外的垃圾。</p><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p><p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p><p><img src="/loadingPostImg.gif" data-original="1742798094289-10.png" alt="img"></p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p><p>当对新生代产生GC：MinorGC【young GC】</p><p>当对老年代产生GC：Major GC </p><p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h4 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h4><p><img src="/loadingPostImg.gif" data-original="1742798094289-11.png" alt="img"></p><ul><li>新创建的对象，都会先分配到eden区</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-12.png" alt="img"></p><ul><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-13.png" alt="img"></p><ul><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-14.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094290-15.png" alt="img"></p><ul><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><p><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么</strong></p><p><img src="/loadingPostImg.gif" data-original="1742798094290-16.png" alt="img"></p><ul><li>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</li><li>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</li><li>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？</li></ul><blockquote><p>名词解释：</p><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p></blockquote><p><img src="/loadingPostImg.gif" data-original="image-20250324161955997.png" alt="image-20250324161955997"></p><h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h3><p>在jvm中，实现了多种垃圾收集器，包括：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS（并发）垃圾收集器</li><li>G1垃圾收集器</li></ul><h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p><ul><li>Serial 作用于新生代，采用复制算法</li><li>Serial Old 作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img src="/loadingPostImg.gif" data-original="1742798094290-17.png" alt="img"></p><h4 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li>Parallel New作用于新生代，采用复制算法</li><li>Parallel Old作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img src="/loadingPostImg.gif" data-original="1742798094290-18.png" alt="img"></p><h4 id="CMS（并发）垃圾收集器"><a href="#CMS（并发）垃圾收集器" class="headerlink" title="CMS（并发）垃圾收集器"></a>CMS（并发）垃圾收集器</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p><p><img src="/loadingPostImg.gif" data-original="1742798094290-19.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094290-20.png" alt="img"></p><p>重新标记：X可能被引用不再回收，D可能需要被回收。</p><h3 id="详细聊一下G1垃圾回收器"><a href="#详细聊一下G1垃圾回收器" class="headerlink" title="详细聊一下G1垃圾回收器"></a>详细聊一下G1垃圾回收器</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><ul><li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>采用复制算法</li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：新生代回收(stw)、并发标记(重新标记stw)、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-21.png" alt="img"></p><h4 id="Young-Collection-年轻代垃圾回收"><a href="#Young-Collection-年轻代垃圾回收" class="headerlink" title="Young Collection(年轻代垃圾回收)"></a>Young Collection(年轻代垃圾回收)</h4><ul><li>初始时，所有区域都处于空闲状态</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-22.png" alt="img"></p><ul><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094290-23.png" alt="img"></p><ul><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094291-24.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094291-25.png" alt="img"></p><ul><li>随着时间流逝，伊甸园的内存又有不足</li><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094291-26.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094291-27.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094291-28.png" alt="img"></p><h4 id="Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记"><a href="#Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记" class="headerlink" title="Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)"></a>Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</h4><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程</p><p><img src="/loadingPostImg.gif" data-original="1742798094291-29.png" alt="img"></p><ul><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</li><li>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li></ul><p><img src="/loadingPostImg.gif" data-original="1742798094291-30.png" alt="img"></p><h4 id="Mixed-Collection-混合垃圾回收"><a href="#Mixed-Collection-混合垃圾回收" class="headerlink" title="Mixed Collection (混合垃圾回收)"></a>Mixed Collection (混合垃圾回收)</h4><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><p><img src="/loadingPostImg.gif" data-original="1742798094291-31.png" alt="img"></p><p>其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象</p><p><img src="/loadingPostImg.gif" data-original="1742798094291-32.png" alt="img"></p><h3 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742798094291-33.png" alt="img"></p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">softReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(user);</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742798094292-34.png" alt="img"></p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure><p>延伸话题：ThreadLocal内存泄漏问题</p><p>ThreadLocal用的就是弱引用，看以下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">         <span class="built_in">super</span>(k);</span><br><span class="line">         value = v; <span class="comment">//强引用，不会被回收</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p><p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p><blockquote><p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p></blockquote><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><p><img src="/loadingPostImg.gif" data-original="1742798094292-35.png" alt="img"></p><p><img src="/loadingPostImg.gif" data-original="1742798094292-36.png" alt="img"></p><p>软引用和弱引用也可以通过引用队列释放资源。</p><h2 id="JVM实践（调优）"><a href="#JVM实践（调优）" class="headerlink" title="JVM实践（调优）"></a>JVM实践（调优）</h2><h3 id="JVM-调优的参数可以在哪里设置参数值？"><a href="#JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM 调优的参数可以在哪里设置参数值？"></a>JVM 调优的参数可以在哪里设置参数值？</h3><h4 id="tomcat的设置vm参数"><a href="#tomcat的设置vm参数" class="headerlink" title="tomcat的设置vm参数"></a>tomcat的设置vm参数</h4><p>修改TOMCAT_HOME/bin/catalina.sh文件，如下图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742807410580-112.png" alt="img"></p><h4 id="springboot项目jar文件启动"><a href="#springboot项目jar文件启动" class="headerlink" title="springboot项目jar文件启动"></a>springboot项目jar文件启动</h4><p>通常在linux系统下直接加参数启动springboot项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure><blockquote><p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p><p>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h3 id="用的-JVM-调优的参数都有哪些？"><a href="#用的-JVM-调优的参数都有哪些？" class="headerlink" title="用的 JVM 调优的参数都有哪些？"></a>用的 JVM 调优的参数都有哪些？</h3><p>对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</p><p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p><p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><blockquote><p>-Xms：设置堆的初始化大小</p><p>-Xmx：设置堆的最大大小</p></blockquote><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p><p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><blockquote><p>-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</p></blockquote><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p><blockquote><p>-XX:newSize   设置年轻代的初始大小</p><p>-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</p></blockquote><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><blockquote><p>-Xss   对每个线程stack大小的调整,-Xss128k</p></blockquote><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold=1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><blockquote><p>（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。</p><p>（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</p></blockquote><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><blockquote><p>-XX:+LargePageSizeInBytes 设置内存页的大小</p></blockquote><p>10）使用非占用的垃圾收集器。</p><blockquote><p>-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</p></blockquote><h3 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h3><h4 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h4><h5 id="jps（Java-Process-Status）"><a href="#jps（Java-Process-Status）" class="headerlink" title="jps（Java Process Status）"></a>jps（Java Process Status）</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p><p><img src="/loadingPostImg.gif" data-original="1742807410580-113.png" alt="img"></p><h5 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] &lt;pid&gt;  </span><br></pre></td></tr></table></figure><p>java案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用jstack查看进行堆栈运行信息</p><p><img src="/loadingPostImg.gif" data-original="1742807410580-114.png" alt="img"></p><h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h5><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid  内存映像信息</p><p>jmap -heap pid   显示Java堆的信息</p><p><strong>jmap -dump:format=b,file=heap.hprof pid</strong></p><p>​                format=b表示以hprof二进制格式转储Java堆的内存</p><p>​                file=<filename>用于指定快照dump文件的文件名。</p></blockquote><p>例：显示了某一个java运行的堆信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yuhon&gt;jmap -heap <span class="number">53280</span></span><br><span class="line">Attaching to process ID <span class="number">53280</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.321</span>-b07</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)   <span class="comment">//并行的垃圾回收器</span></span><br><span class="line"></span><br><span class="line">Heap Configuration:  <span class="comment">//堆配置</span></span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span>   <span class="comment">//空闲堆空间的最小百分比</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span>  <span class="comment">//空闲堆空间的最大百分比</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8524922880</span> (<span class="number">8130.</span>0MB) <span class="comment">//堆空间允许的最大值</span></span><br><span class="line">   NewSize                  = <span class="number">178257920</span> (<span class="number">170.</span>0MB) <span class="comment">//新生代堆空间的默认值</span></span><br><span class="line">   MaxNewSize               = <span class="number">2841640960</span> (<span class="number">2710.</span>0MB) <span class="comment">//新生代堆空间允许的最大值</span></span><br><span class="line">   OldSize                  = <span class="number">356515840</span> (<span class="number">340.</span>0MB) <span class="comment">//老年代堆空间的默认值</span></span><br><span class="line">   NewRatio                 = <span class="number">2</span> <span class="comment">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span> <span class="comment">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB) <span class="comment">//元空间的默认值</span></span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB) <span class="comment">//压缩类使用空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB <span class="comment">//元空间允许的最大值</span></span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)<span class="comment">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span></span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: <span class="comment">//Eden使用情况</span></span><br><span class="line">   capacity = <span class="number">134217728</span> (<span class="number">128.</span>0MB)</span><br><span class="line">   used     = <span class="number">10737496</span> (<span class="number">10.</span>240074157714844MB)</span><br><span class="line">   free     = <span class="number">123480232</span> (<span class="number">117.</span>75992584228516MB)</span><br><span class="line">   <span class="number">8.000057935714722</span>% used</span><br><span class="line">From Space: <span class="comment">//Survivor-From 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space: <span class="comment">//Survivor-To 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation  <span class="comment">//老年代 使用情况</span></span><br><span class="line">   capacity = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">3185</span> interned Strings occupying <span class="number">261264</span> bytes.</span><br></pre></td></tr></table></figure><h5 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h5 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p><p><strong>常见参数</strong>：</p><p>①总结垃圾回收统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil pid</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742807410580-115.png" alt="img"></p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></div><p>②垃圾回收统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742807410580-116.png" alt="img"></p><h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><h5 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h5><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><p><img src="/loadingPostImg.gif" data-original="1742807410580-117.png" alt="img"></p><p>可以内存、线程、类等信息</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-118.png" alt="img"></p><h5 id="VisualVM：故障处理工具"><a href="#VisualVM：故障处理工具" class="headerlink" title="VisualVM：故障处理工具"></a>VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-119.png" alt="img"></p><p>监控程序运行情况</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-120.png" alt="img"></p><p>查看运行中的dump</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-121.png" alt="img"></p><p>查看堆中的信息</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-122.png" alt="img"></p><h3 id="java内存泄露的排查思路？"><a href="#java内存泄露的排查思路？" class="headerlink" title="java内存泄露的排查思路？"></a>java内存泄露的排查思路？</h3><p>原因：</p><p>如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常</p><p>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常</p><p>如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-123.png" alt="img"></p><p>1、通过jmap指定打印他的内存快照 dump</p><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p><blockquote><p>-XX:+HeapDumpOnOutOfMemoryError</p><p>-XX:HeapDumpPath=/home/app/dumps/      指定生成后文件的保存目录</p></blockquote><p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p><p>VisualVM可以加载离线的dump文件，如下图</p><p>文件—&gt;装入—-&gt;选择dump文件即可查看堆快照信息</p><p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-124.png" alt="img"></p><p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p><img src="/loadingPostImg.gif" data-original="1742807410581-125.png" alt="img"></p><p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p><p><img src="/loadingPostImg.gif" data-original="image-20250324212555481.png" alt="image-20250324212555481"></p><h3 id="CPU飙高排查方案与思路？"><a href="#CPU飙高排查方案与思路？" class="headerlink" title="CPU飙高排查方案与思路？"></a>CPU飙高排查方案与思路？</h3><p>1.使用top命令查看占用cpu的情况</p><p><img src="/loadingPostImg.gif" data-original="1742807410582-126.png" alt="img"></p><p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p><p>3.查看当前线程中的进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%CPU | grep 30978</span><br></pre></td></tr></table></figure><blockquote><p>pid  进行id</p><p>tid   进程中的线程id</p><p>%  cpu使用率 </p></blockquote><p><img src="/loadingPostImg.gif" data-original="1742807410582-127.png" alt="img"></p><p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p><p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p><p>转换方式：</p><p>在linux中执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; 30979</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742807410582-128.png" alt="img"></p><p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 30978   此处是进程id</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="1742807410582-129.png" alt="img"></p><h2 id="面试现场"><a href="#面试现场" class="headerlink" title="面试现场"></a>面试现场</h2><h3 id="JVM组成-1"><a href="#JVM组成-1" class="headerlink" title="JVM组成"></a>JVM组成</h3><blockquote><p><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</p><p><strong>候选人:</strong></p><p>嗯，好的~~</p><p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p><p>它们的运行流程是：</p><p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p><p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><p><strong>面试官</strong>：好的，你能详细说一下 JVM 运行时数据区吗？</p><p><strong>候选人:</strong></p><p>嗯，好~</p><p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p><ul><li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li><li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li><li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li><li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li></ul><p><strong>面试官</strong>：好的，你再详细介绍一下程序计数器的作用？</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p><p><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</p><p><strong>候选人:</strong></p><p>好的~</p><p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p>​        在JAVA8中堆内会存在年轻代、老年代</p><p>​        1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p><p>​        2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p><p><strong>面试官</strong>：能不能解释一下方法区？</p><p><strong>候选人:</strong></p><p>好的~</p><p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p><p><strong>面试官</strong>：你听过直接内存吗？</p><p><strong>候选人:</strong></p><p>嗯~~</p><p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p><p>​        所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</p><p><strong>面试官</strong>：什么是虚拟机栈</p><p><strong>候选人:</strong></p><p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p><p><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</p><p><strong>候选人:</strong></p><p>嗯，好的，有这几个区别</p><p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p><p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p></blockquote><h3 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</p><p><strong>候选人:</strong></p><p>嗯，是这样的</p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><p>常见的类加载器有4个</p><p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。</p><p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。</p><p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p><p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p><p><strong>面试官</strong>：说一下类装载的执行过程？</p><p><strong>候选人:</strong></p><p>嗯，这个过程还是挺多的。</p><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p><p>1.加载：查找和导入class文件</p><p>2.验证：保证加载类的准确性</p><p>3.准备：为类变量分配内存并设置类变量初始值</p><p>4.解析：把类中的符号引用转换为直接引用</p><p>5.初始化：对类的静态变量，静态代码块执行初始化操作</p><p>6.使用：JVM 开始从入口方法开始执行用户的程序代码</p><p>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><p><strong>面试官</strong>：什么是双亲委派模型？</p><p><strong>候选人:</strong></p><p>嗯，它是是这样的。</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p><p><strong>面试官</strong>：JVM为什么采用双亲委派机制</p><p><strong>候选人:</strong></p><p>主要有两个原因。</p><p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>第二、为了安全，保证类库API不会被修改</p></blockquote><h3 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote><p><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</p><p><strong>候选人:</strong></p><p>嗯，是这样~~</p><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</p><p><strong>候选人:</strong></p><p>嗯嗯~</p><p>强引用最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p><p>软引用表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p><p>弱引用表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p><p>虚引用表示一个对象处于<strong>无用</strong>的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</p><p><strong>面试官</strong>：对象什么时候可以被垃圾器回收</p><p><strong>候选人:</strong></p><p>思考一会~~</p><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><p>通常都使用可达性分析算法来确定是不是垃圾</p><p><strong>面试官</strong>： JVM 垃圾回收算法有哪些？</p><p><strong>候选人:</strong></p><p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p><p><strong>面试官</strong>： 你能详细聊一下分代回收吗？</p><p><strong>候选人:</strong></p><p>关于分代回收是这样的</p><p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p><p>具体的工作机制是有些情况：</p><p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p><p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p><p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p><p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p><p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p><p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p><p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p><p><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</p><p><strong>候选人:</strong></p><p>嗯！是这样的，简单说就是</p><p><strong>新生代</strong>主要用来存放新生的对象。</p><p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p><p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p><p><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？</p><p><strong>候选人:</strong></p><p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p><p><strong>面试官</strong>：Minor GC、Major GC、Full GC是什么</p><p><strong>候选人:</strong></p><p>嗯，其实它们指的是不同代之间的垃圾回收</p><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p><p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></blockquote><h3 id="JVM实践（调优）-1"><a href="#JVM实践（调优）-1" class="headerlink" title="JVM实践（调优）"></a>JVM实践（调优）</h3><blockquote><p><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</p><p><strong>候选人:</strong></p><p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p><p><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</p><p><strong>候选人:</strong></p><p>嗯，这些参数是比较多的</p><p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p><p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p><p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p><p><strong>面试官</strong>：嗯，好的，你们平时调试 JVM都用了哪些工具呢？</p><p><strong>候选人:</strong></p><p>嗯，我们一般都是使用jdk自带的一些工具，比如</p><p>jps 输出JVM中运行的进程状态信息</p><p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p><p>jmap 用于生成堆转存快照</p><p>jstat用于JVM统计监测工具</p><p>还有一些可视化工具，像jconsole和VisualVM等</p><p><strong>面试官</strong>：假如项目中产生了java内存泄露，你说一下你的排查思路？</p><p><strong>候选人:</strong></p><p>嗯，这个我在之前项目排查过</p><p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p><p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p><p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p><p><strong>面试官</strong>：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？</p><p><strong>候选人:</strong></p><p>嗯，我思考一下~~</p><p>可以这么做~~</p><p>第一可以使用使用top命令查看占用cpu的情况</p><p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p><p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p><p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p></blockquote><h1 id="企业场景"><a href="#企业场景" class="headerlink" title="企业场景"></a>企业场景</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在平时的开发中，涉及到设计模式的有两块内容，第一个是我们平时使用的框架（比如spring、mybatis等），第二个是我们自己开发业务使用的设计模式。</p><p>面试官一般比较关心的是你在开发过程中，有没有使用过设计模式，或者你在简历上写了关于设计模式的描述，那么这样我们就需要重点关心自己开发中用过的设计模式。</p><p>在平时的业务开发中，其实真正使用设计模式的场景并不多，虽然设计号称有23种之多（不同的纬度可能会更多），但是在项目最常使用的也就几种而已，在面试的过程中，我们主要介绍一种或两种就可以，重点要说的是：在什么业务场景下使用了设计模式，什么设计模式？</p><p><img src="/loadingPostImg.gif" data-original="1742824709869-19.png" alt="img"></p><p>这次面试部分，我们主要介绍三种设计模式：</p><ul><li>工厂方法模式（简单工厂、工厂方法、抽象工厂）</li><li>策略模式</li><li>责任链模式</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>需求：设计一个咖啡店点餐系统。  </p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-1.jpeg" alt="img"></p><blockquote><p>1.类图中的符号</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected</li></ul></blockquote><p>2.泛化关系(继承)用带空心三角箭头的实线来表示</p><p>3.依赖关系使用带箭头的虚线来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.factory.simple;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> orderCoffee(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">         System.out.println(coffee.getName());</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">         <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(<span class="string">&quot;american&quot;</span>.equals(type))&#123;</span><br><span class="line">             coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;latte&quot;</span>.equals(type))&#123;</span><br><span class="line">             coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">//添加配料</span></span><br><span class="line">         coffee.addMilk();</span><br><span class="line">         coffee.addSuqar();</span><br><span class="line">         <span class="keyword">return</span> coffee;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的<strong>开闭原则</strong>。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><blockquote><p>开闭原则：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p></blockquote><p>三种工厂</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>现在使用简单工厂对上面案例进行改进，类图如下：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-2.png" alt="img"></p><p>工厂类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.factory.simple;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">         <span class="comment">//通过工厂获得对象，不需要知道对象实现的细节</span></span><br><span class="line">         <span class="type">SimpleCoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffeeFactory</span>();</span><br><span class="line">         <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee(type);</span><br><span class="line">         <span class="comment">//添加配料</span></span><br><span class="line">         coffee.addMilk();</span><br><span class="line">         coffee.addSuqar();</span><br><span class="line">         <span class="keyword">return</span> coffee;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>缺点：</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p><strong>静态工厂</strong></p><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>使用工厂方法模式对上例进行改进，类图如下：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-3.png" alt="img"></p><p>流程：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-4.png" alt="img"></p><p>代码如下：</p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示</p><ul><li>产品族：一个品牌下面的所有产品；例如华为下面的电脑、手机称为华为的产品族；</li><li>产品等级：多个品牌下面的同种产品；例如华为和小米都有手机电脑为一个产品等级；</li></ul><p><img src="/loadingPostImg.gif" data-original="1742824709859-5.png" alt="img"></p><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p><strong>一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>现咖啡店业务发生改变，不仅要生产<strong>咖啡</strong>还要生产<strong>甜点</strong></p><ul><li>同一个产品等级（产品分类）<ul><li>咖啡：拿铁咖啡、美式咖啡 </li><li>甜点：提拉米苏、抹茶慕斯</li></ul></li><li>同一个风味，就是同一个产品族（相当于同一个品牌）<ul><li>美式风味：美式咖啡、抹茶慕斯</li><li>意大利风味：拿铁咖啡、提拉米苏</li></ul></li></ul><p>要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。</p><p>所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-6.png" alt="img"></p><p>实现关系使用带空心三角箭头的虚线来表示</p><p>整体调用思路：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-7.png" alt="img"></p><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-8.png" alt="img"></p><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-9.png" alt="img"></p><p><strong>定义：</strong></p><p>​        该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h4 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h4><p>策略模式的主要角色如下：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-10.png" alt="img"></p><p>聚合关系可以用带空心菱形的实线来表示</p><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>下图是gitee的登录的入口，其中有多种方式可以进行登录</p><ul><li>用户名密码登录</li><li>短信验证码登录</li><li>微信登录</li><li>QQ登录</li><li>….</li></ul><p><img src="/loadingPostImg.gif" data-original="1742824709859-11.png" alt="img"></p><h4 id="目前已实现的代码"><a href="#目前已实现的代码" class="headerlink" title="目前已实现的代码"></a>目前已实现的代码</h4><p>(1)登录接口</p><div class="table-container"><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>路径</td><td>/api/user/login</td></tr><tr><td>参数</td><td>LoginReq</td></tr><tr><td>返回值</td><td>LoginResp</td></tr></tbody></table></div><p>请求参数：LoginReq</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginReq</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> String phone;</span><br><span class="line">     <span class="keyword">private</span> String validateCode;<span class="comment">//手机验证码</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> String wxCode;<span class="comment">//用于微信登录</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * account : 用户名密码登录</span></span><br><span class="line"><span class="comment">      * sms : 手机验证码登录</span></span><br><span class="line"><span class="comment">      * we_chat : 微信登录</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> String type;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>响应参数：LoginResp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginResp</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String roleCode;</span><br><span class="line">    <span class="keyword">private</span> String token; <span class="comment">//jwt令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层LoginController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginReq loginReq)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(loginReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(loginReq.getType().equals(<span class="string">&quot;account&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名密码登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行用户密码登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(loginReq.getType().equals(<span class="string">&quot;sms&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;手机号验证码登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行手机号验证码登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (loginReq.getType().equals(<span class="string">&quot;we_chat&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;微信登录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行用户微信登录逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        loginResp.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> loginResp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我们重点讲的是设计模式，并不是登录的逻辑，所以以上代码并没有真正的实现登录功能</p><p>(2)问题分析</p><ul><li>业务层代码大量使用到了if…else，在后期阅读代码的时候会非常不友好，大量使用if…else性能也不高</li><li>如果业务发生变更，比如现在新增了QQ登录方式，这个时候需要修改业务层代码，违反了开闭原则</li></ul><p>解决：</p><p>使用<strong>工厂方法设计模式+策略模式</strong>解决</p><h4 id="代码改造（工厂-策略）"><a href="#代码改造（工厂-策略）" class="headerlink" title="代码改造（工厂+策略）"></a>代码改造（工厂+策略）</h4><p>（1）整体思路</p><p>改造之后，不在service中写业务逻辑，让service调用工厂，然后通过service传递不同的参数来获取不同的登录策略（登录方式）</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-12.png" alt="img"></p><p>（2）具体实现</p><p>抽象策略类：UserGranter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loginReq 传入的参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> map值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的策略：AccountGranter、SmsGranter、WeChatGranter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *         策略：账号登录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;登录方式为账号登录&quot;</span> + loginReq);</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="comment">// 执行业务操作 </span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略:短信登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>  &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;登录方式为短信登录&quot;</span> + loginReq);</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="comment">// 执行业务操作</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略:微信登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>  &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;登录方式为微信登录&quot;</span> + loginReq);</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="comment">// 执行业务操作</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程类：UserLoginFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作策略的上下文环境类 工具类</span></span><br><span class="line"><span class="comment"> * 将策略整合起来 方便管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginFactory</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, UserGranter&gt; granterPool = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTypeConfig loginTypeConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件中读取策略信息存储到map中</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">     * account:accountGranter,</span></span><br><span class="line"><span class="comment">     * sms:smsGranter,</span></span><br><span class="line"><span class="comment">     * we_chat:weChatGranter</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        loginTypeConfig.getTypes().forEach((k, y) -&gt; &#123;</span><br><span class="line">            granterPool.put(k, (UserGranter) applicationContext.getBean(y));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供获取具体策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grantType 用户的登录方式，需要跟配置文件中匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 具体策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserGranter <span class="title function_">getGranter</span><span class="params">(String grantType)</span> &#123;</span><br><span class="line">        <span class="type">UserGranter</span> <span class="variable">tokenGranter</span> <span class="operator">=</span> granterPool.get(grantType);</span><br><span class="line">        <span class="keyword">return</span> tokenGranter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在application.yml文件中新增自定义配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">login:</span></span><br><span class="line">  <span class="attr">types:</span></span><br><span class="line">    <span class="attr">account:</span> <span class="string">accountGranter</span></span><br><span class="line">    <span class="attr">sms:</span> <span class="string">smsGranter</span></span><br><span class="line">    <span class="attr">we_chat:</span> <span class="string">weChatGranter</span></span><br></pre></td></tr></table></figure><p>新增读取数据配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Getter</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTypeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; types;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造service代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserLoginFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserGranter</span> <span class="variable">granter</span> <span class="operator">=</span> factory.getGranter(loginReq.getType());</span><br><span class="line">        <span class="keyword">if</span>(granter == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">            loginResp.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> loginResp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> granter.login(loginReq);</span><br><span class="line">        <span class="keyword">return</span> loginResp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到我们使用了设计模式之后，业务层的代码就清爽多了，如果后期有新的需求改动，比如加入了QQ登录，我们只需要添加对应的策略就可以，无需再改动业务层代码。</p><h4 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h4><p>其实像这样的需求，在日常开发中非常常见，场景有很多，以下的情景都可以使用工厂模式+策略模式解决比如：</p><ul><li>订单的支付策略<ul><li>支付宝支付</li><li>微信支付</li><li>银行卡支付</li><li>现金支付</li></ul></li><li>解析不同类型excel<ul><li>xls格式</li><li>xlsx格式</li></ul></li><li>打折促销<ul><li>满300元9折</li><li>满500元8折</li><li>满1000元7折</li></ul></li><li>物流运费阶梯计算<ul><li>5kg以下</li><li>5kg-10kg</li><li>10kg-20kg</li><li>20kg以上</li></ul></li></ul><p>一句话总结：<strong>只要代码中有冗长的 if-else 或 switch 分支判断都可以采用策略模式优化</strong></p><p><img src="/loadingPostImg.gif" data-original="image-20250324230121524.png" alt="image-20250324230121524"></p><p>提供很多种策略，@Component交给Spring容器管理；</p><p>提供一个工厂</p><ul><li>准备策略对象</li><li>提供方法，根据不同参数返回不同对象</li></ul><h3 id="责任链设计模式"><a href="#责任链设计模式" class="headerlink" title="责任链设计模式"></a>责任链设计模式</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p><strong>定义：</strong></p><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>比较常见的springmvc中的拦截器，web开发中的filter过滤器</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-13.png" alt="img"></p><h4 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h4><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h4 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h4><p>处理订单的操作</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-14.png" alt="img"></p><p>类图：</p><p><img src="/loadingPostImg.gif" data-original="1742824709859-15.png" alt="img"></p><p>代码：</p><p>抽象处理者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.designpattern.chain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象处理者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理过程</span></span><br><span class="line"><span class="comment">     * 需要子类进行实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单信息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.designpattern.chain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(String productId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderValidition</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验订单基本信息&quot;</span>);</span><br><span class="line">        <span class="comment">//校验</span></span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补充订单信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFill</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;补充订单信息&quot;</span>);</span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算金额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderAmountCalcuate</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算金额-优惠券、VIP、活动打折&quot;</span>);</span><br><span class="line">        handler.process(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单入库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCreate</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OrderInfo order)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单入库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//检验订单</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderValidition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderValidition</span>();</span><br><span class="line">        <span class="comment">//补充订单信息</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderFill</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderFill</span>();</span><br><span class="line">        <span class="comment">//订单算价</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderAmountCalcuate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderAmountCalcuate</span>();</span><br><span class="line">        <span class="comment">//订单落库</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">orderCreate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCreate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置责任链路</span></span><br><span class="line">        orderValidition.setNext(orderFill);</span><br><span class="line">        orderFill.setNext(orderAmountCalcuate);</span><br><span class="line">        orderAmountCalcuate.setNext(orderCreate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始执行</span></span><br><span class="line">        orderValidition.process(<span class="keyword">new</span> <span class="title class_">OrderInfo</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>降低了对象之间的耦合度</li><li>该模式降低了请求发送者和接收者的耦合度。</li><li>增强了系统的可扩展性</li><li>可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性</li><li>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接</li><li>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担</li><li>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h4 id="举一反三-1"><a href="#举一反三-1" class="headerlink" title="举一反三"></a>举一反三</h4><ul><li>内容审核（视频、文章、课程….）</li></ul><p><img src="/loadingPostImg.gif" data-original="1742824709859-16.png" alt="img"></p><ul><li>订单创建</li></ul><p><img src="/loadingPostImg.gif" data-original="1742824709859-17.png" alt="img"></p><ul><li>简易流程审批</li></ul><p><img src="/loadingPostImg.gif" data-original="1742824709859-18.png" alt="img"></p><h2 id="技术场景"><a href="#技术场景" class="headerlink" title="技术场景"></a>技术场景</h2><h3 id="单点登录这块怎么实现的"><a href="#单点登录这块怎么实现的" class="headerlink" title="单点登录这块怎么实现的"></a>单点登录这块怎么实现的</h3><h4 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h4><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）,只需要登录一次，就可以访问所有信任的应用系统</p><p>在<strong>以前</strong>的时候，一般我们就<strong>单系统</strong>，所有的功能都在同一个系统上。</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-64.png" alt="img"></p><p>单体系统的session共享</p><ul><li><strong>登录</strong>：将用户信息保存在Session对象中<ul><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li></ul></li><li><strong>注销（退出登录）</strong>：从Session中删除用户的信息</li></ul><p>后来，我们为了<strong>合理利用资源和降低耦合性</strong>，于是把单系统<strong>拆分</strong>成多个子系统。</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-65.png" alt="img"></p><p>多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（最多支持5台tomcat，不推荐使用）</li><li>JWT(常见)</li><li>Oauth2</li><li>CAS</li><li>自己实现（redis+token）</li></ul><h4 id="JWT解决单点登录"><a href="#JWT解决单点登录" class="headerlink" title="JWT解决单点登录"></a>JWT解决单点登录</h4><p>现在有一个微服务的简单架构，如图：</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-66.png" alt="img"></p><p>使用jwt解决单点登录的流程如下：</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-67.png" alt="img"></p><h4 id="回答要点"><a href="#回答要点" class="headerlink" title="回答要点"></a>回答要点</h4><p>1，先解释什么是单点登录</p><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）</p><p>2，介绍自己项目中涉及到的单点登录（即使没涉及过，也可以说实现的思路）</p><p>3，介绍单点登录的解决方案，以JWT为例</p><p>​      I.  用户访问其他系统，会在网关判断token是否有效</p><p>​     II.  如果token无效则会返回401（认证失败）前端跳转到登录页面</p><p>​    III.  用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie</p><p>​    IV.  再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p><h3 id="权限认证是如何实现的"><a href="#权限认证是如何实现的" class="headerlink" title="权限认证是如何实现的"></a>权限认证是如何实现的</h3><h4 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h4><p>后台的管理系统，更注重权限控制，最常见的就是RBAC模型来指导实现权限</p><p>RBAC(Role-Based Access Control)基于角色的访问控制</p><ul><li>3个基础部分组成：用户、角色、权限</li><li>具体实现<ul><li>5张表（用户表、角色表、权限表、用户角色中间表、角色权限中间表）</li><li>7张表（用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表）</li></ul></li></ul><h4 id="RBAC权限模型"><a href="#RBAC权限模型" class="headerlink" title="RBAC权限模型"></a>RBAC权限模型</h4><p>最常见的5张表的关系</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-68.png" alt="img"></p><p><strong>数据流转</strong></p><p>张三具有什么权限呢？</p><p>流程：张三登录系统—-&gt; 查询张三拥有的角色列表—-&gt;再根据角色查询拥有的权限</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-69.png" alt="img"></p><p>在实际的开发中，也会使用权限框架完成权限功能的实现，并且设置多种粒度，常见的框架有：</p><ul><li>Apache shiro  </li><li>Spring security（推荐）</li></ul><h4 id="回答要点-1"><a href="#回答要点-1" class="headerlink" title="回答要点"></a>回答要点</h4><ul><li>后台管理系统的开发经验</li><li>介绍RBAC权限模型5张表的关系（用户、角色、权限）</li><li>权限框架：Spring security</li></ul><h3 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a>上传数据的安全性你们怎么控制？</h3><h4 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h4><p><img src="/loadingPostImg.gif" data-original="1742830087920-70.png" alt="img"></p><p>这里的安全性，主要说的是，浏览器访问后台，需要经过网络传输，有可能会出现安全的问题</p><p>解决方案：使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-71.png" alt="img"></p><ul><li>数据发信方将明文和加密密钥一起经过特殊的加密算法处理后，使其变成复杂的加密密文发送出去，</li><li>收信方收到密文后，若想解读出原文，则需要使用加密时用的密钥以及相同加密算法的逆算法对密文进行解密，才能使其回复成可读明文。</li><li>在对称加密算法中，使用的密钥只有一个，收发双方都使用这个密钥，这就需要解密方事先知道加密密钥。</li></ul><p><strong>优点:</strong>  对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p><p><strong>缺点:</strong>  没有非对称加密安全.</p><p><strong>用途：</strong> 一般用于保存用户手机号、身份证等敏感但能解密的信息。</p><p><strong>常见的对称加密算法有</strong>: <code>AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6、HS256</code></p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>两个密钥：公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-72.png" alt="img"></p><p>解释:  同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端.</p><p>加密与解密:</p><ul><li>私钥加密，持有公钥才可以解密</li><li>公钥加密，持有私钥才可解密</li></ul><p>签名:</p><ul><li>私钥签名,  持有公钥进行验证是否被篡改过.</li></ul><p><strong>优点:</strong>  非对称加密与对称加密相比，其安全性更好；</p><p><strong>缺点:</strong>  非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 <strong>用途：</strong> 一般用于签名和认证。私钥服务器保存, 用来加密,  公钥客户拿着用于对于令牌或者签名的解密或者校验使用.</p><p><strong>常见的非对称加密算法有：</strong> RSA、DSA（数字签名用）、ECC（移动设备用）、RS256 (采用SHA-256 的 RSA 签名) </p><h4 id="回答要点-2"><a href="#回答要点-2" class="headerlink" title="回答要点"></a>回答要点</h4><ul><li>使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台解密后处理数据<ul><li>传输的数据很大建议使用对称加密，不过不能保存敏感信息</li><li>传输的数据较小，要求安全性高，建议采用非对称加密</li></ul></li></ul><h3 id="你负责项目的时候遇到了哪些比较棘手的问题"><a href="#你负责项目的时候遇到了哪些比较棘手的问题" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题"></a>你负责项目的时候遇到了哪些比较棘手的问题</h3><p>这个面试题主要考察的是，</p><ul><li>你是否有过开发经验</li><li>是否是核心开发人员</li></ul><p>有4个方面可以回答，只要挑出一个回答就行了</p><p><strong>（1）设计模式</strong></p><ul><li>工厂模式+策略</li><li>责任链模式</li></ul><p>回答思路</p><p>1，什么背景（技术问题）</p><p>2，过程（解决问题的过程）</p><p>3，最终落地方案</p><p>举例：</p><p>①：介绍登录业务（一开始没有用设计模式，所有的登录方式都柔和在一个业务类中，不过，发现需求经常改）</p><p>②：登录方式经常会增加或更换，每次都要修改业务层代码，所以，经过我的设计，使用了工厂设计模式和策略模式，解决了，经常修改业务层代码的问题</p><p>③：详细介绍一下工厂模式和策略模式（参考前面设计模式的课程）</p><p><strong>（2）线上BUG</strong></p><ul><li>CPU飙高</li><li>内存泄漏</li><li>线程死锁</li><li>….</li></ul><p>回答方式参考上面的回答思路，具体问题可以参考前面的课程（JVM和多线程相关的面试题）</p><p><strong>（3）调优</strong></p><ul><li>慢接口</li><li>慢SQL</li><li>缓存方案</li></ul><p><strong>（4）组件封装</strong></p><ul><li>分布式锁</li><li>接口幂等</li><li>分布式事务</li><li>支付通用</li></ul><h3 id="你们项目中日志怎么采集的"><a href="#你们项目中日志怎么采集的" class="headerlink" title="你们项目中日志怎么采集的"></a>你们项目中日志怎么采集的</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1，为什么要采集日志？</p><p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p><p>2，采集日志的方式有哪些?</p><ul><li>ELK：即Elasticsearch、Logstash和Kibana三个软件的首字母</li><li>常规采集：按天保存到一个日志文件</li></ul><p><img src="/loadingPostImg.gif" data-original="1742830087920-73.png" alt="img"></p><h4 id="ELK基本架构"><a href="#ELK基本架构" class="headerlink" title="ELK基本架构"></a>ELK基本架构</h4><p>ELK即Elasticsearch、Logstash和Kibana三个开源软件的缩写</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-74.png" alt="img"></p><ul><li>Elasticsearch Elasticsearch  全文搜索和分析引擎，对大容量的数据进行接近实时的存储、搜索和分析操作。</li><li>Logstash Logstash是一个数据收集引擎，它可以动态的从各种数据源搜集数据，并对数据进行过滤、分析和统一格式等操作，并将输出结果存储到指定位置上</li><li>Kibana Kibana是一个数据分析和可视化平台，通常与Elasticsearch配合使用，用于对其中的数据进行搜索、分析，并且以统计图标的形式展示。</li></ul><h4 id="参考回答"><a href="#参考回答" class="headerlink" title="参考回答"></a>参考回答</h4><ul><li>我们搭建了ELK日志采集系统</li><li>介绍ELK的三个组件：<ul><li>Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析</li><li>Logstash是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置</li><li>Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</li></ul></li></ul><h3 id="查看日志的命令"><a href="#查看日志的命令" class="headerlink" title="查看日志的命令"></a>查看日志的命令</h3><p>目前采集日志的方式：按天保存到一个日志文件</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-75.png" alt="img"></p><p>也可以在logback配置文件中设置日志的目录和名字</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-76.png" alt="img"></p><p>需要掌握的Linux中的日志：</p><ul><li><p>实时监控日志的变化</p><p>实时监控某一个日志文件的变化：<strong>tail -f xx.log</strong>；实时监控日志最后100行日志： tail –n 100 -f xx.log</p></li><li><p>按照行号查询</p><ul><li>查询日志尾部最后100行日志：<strong>tail – n 100 xx.log</strong></li><li>查询日志头部开始100行日志：head –n 100 xx.log</li><li>查询某一个日志行号区间：cat -n xx.log | tail -n +100 | head -n 100 (查询100行至200行的日志)</li></ul></li><li><p>按照关键字找日志的信息</p><p>查询日志文件中包含debug的日志行号：<strong>cat -n xx.log | grep “debug”</strong></p></li><li><p>按照日期查询</p><p>sed -n ‘/2023-05-18 14:22:31.070/,/ 2023-05-18 14:27:14.158/p’xx.log </p></li><li><p>日志太多，处理方式</p><ul><li>分页查询日志信息：cat -n xx.log |grep “debug” | more</li><li>筛选过滤以后，输出到一个文件：cat -n xx.log | grep “debug” &gt;debug.txt  </li></ul></li></ul><h3 id="生产问题怎么排查"><a href="#生产问题怎么排查" class="headerlink" title="生产问题怎么排查"></a>生产问题怎么排查</h3><p>已经上线的bug排查的思路：</p><p>1，先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</p><p>2，远程debug(通常公司的正式环境（生产环境）是不允许远程debug的。一般远程debug都是公司的测试环境，方便调试代码)</p><p><strong>远程debug配置</strong></p><p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p><p>远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p><p> java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</p><blockquote><p><strong>-agentlib:jdwp</strong>  是通知JVM使用(java debug wire protocol)来运行调试环境</p><p><strong>transport=dt_socket</strong>  调试数据的传送方式</p><p><strong>server=y</strong>  参数是指是否支持在server模式</p><p><strong>suspend=n</strong> 是否在调试客户端建立起来后，再执行JVM。</p><p><strong>address=5005</strong>  调试端口设置为5005，其它端口也可以</p></blockquote><p>idea中设置远程debug，找到idea中的 Edit Configurations…</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-77.png" alt="img"></p><p>idea中启动远程debug</p><p><img src="/loadingPostImg.gif" data-original="1742830087920-78.png" alt="img"></p><p>访问远程服务器，在本地代码中打断点即可调试远程</p><h3 id="怎么快速定位系统的瓶颈"><a href="#怎么快速定位系统的瓶颈" class="headerlink" title="怎么快速定位系统的瓶颈"></a>怎么快速定位系统的瓶颈</h3><ul><li>压测（性能测试），项目上线之前测评系统的压力<ul><li>压测目的：给出系统当前的性能状况；定位系统性能瓶颈或潜在性能瓶颈</li><li>指标：响应时间、 QPS、并发数、吞吐量、 CPU利用率、内存使用率、磁盘IO、错误率</li><li>压测工具：LoadRunner、Apache Jmeter …</li><li>后端工程师：根据压测的结果进行解决或调优（接口慢、代码报错、并发达不到要求…）</li></ul></li><li>监控工具、链路追踪工具，项目上线之后监控<ul><li>监控工具：Prometheus+Grafana</li><li>链路追踪工具：skywalking、Zipkin</li></ul></li><li>线上诊断工具Arthas(阿尔萨斯)，项目上线之后监控、排查<ul><li>官网：<a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li><li>核心功能：</li><li><img src="/loadingPostImg.gif" data-original="1742830087920-79.png" alt="img"></li></ul></li></ul><p><img src="/loadingPostImg.gif" data-original="1742830087920-80.png" alt="img"></p><h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><h2 id="专业问题"><a href="#专业问题" class="headerlink" title="专业问题"></a>专业问题</h2><p><strong>linux怎么创建/复制/移动/删除文件夹？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] 文件夹名称</span><br><span class="line"><span class="built_in">cp</span> -r 源文件夹路径 目标文件夹路径</span><br><span class="line"><span class="built_in">mv</span> 源文件夹路径 目标文件夹路径</span><br><span class="line"><span class="built_in">rm</span> -r [选项] 文件夹路径</span><br></pre></td></tr></table></figure><p><strong>linux用户和用户组如何创建？</strong></p><p><em>创建用户组</em></p><p>可以使用 <code>groupadd</code> 命令来创建用户组，其基本语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br></pre></td></tr></table></figure><p>常见选项：</p><ul><li><code>-g</code>：指定新用户组的 GID（组 ID）。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 developers 的用户组</span></span><br><span class="line">groupadd developers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 testers 的用户组，并指定 GID 为 1010</span></span><br><span class="line">groupadd -g 1010 testers</span><br></pre></td></tr></table></figure><p><em>创建用户</em></p><p>可以使用 <code>useradd</code> 命令来创建用户，其基本语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] 用户名</span><br></pre></td></tr></table></figure><p>常见选项：</p><ul><li><code>-g</code>：指定用户所属的主用户组。</li><li><code>-G</code>：指定用户所属的附加用户组。</li><li><code>-d</code>：指定用户的主目录。</li><li><code>-m</code>：如果主目录不存在，则自动创建。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 alice 的用户，并将其主用户组设为 developers</span></span><br><span class="line">useradd -g developers alice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 bob 的用户，主用户组为 testers，附加用户组为 developers</span></span><br><span class="line">useradd -g testers -G developers bob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 charlie 的用户，指定主目录为 /home/charlie 并自动创建该目录</span></span><br><span class="line">useradd -d /home/charlie -m charlie</span><br></pre></td></tr></table></figure><p>创建用户后，通常还需要为其设置密码，可使用 <code>passwd</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为用户 alice 设置密码</span></span><br><span class="line">passwd alice</span><br></pre></td></tr></table></figure><p>执行上述命令后，系统会提示你输入新密码并确认。</p><p><strong>linux文件复制，大量的文件复制与保持权限一致</strong></p><p><code>cp</code> 命令是 Linux 中常用的文件复制工具，可通过添加 <code>-p</code> 选项来在复制过程中保留文件的权限、所有者、时间戳等属性。其基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p>常见选项说明：</p><ul><li><code>-r</code> 或 <code>-R</code>：递归复制目录及其子目录、文件，适用于复制大量文件和目录的情况。</li><li><code>-a</code>：归档模式，等同于 <code>-dpR</code>，能保留文件的所有属性，包括权限、链接、时间戳等，是一个较为全面的选项。</li></ul><p><strong>linux如何查看系统磁盘使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [选项] [文件或挂载点]</span><br></pre></td></tr></table></figure><ul><li>常用选项<ul><li><code>-h</code>：以人类可读的格式显示磁盘容量，如 KB、MB、GB 等。</li><li><code>-T</code>：显示文件系统的类型。</li></ul></li></ul><p><strong>linux用什么查询端口号的使用情况</strong></p><p><code>netstat</code> 是一个用于显示网络连接、路由表和网络接口等网络相关信息的工具，也能用来查看端口使用情况。</p><ul><li><strong>基本语法</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><ul><li>常用选项<ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：显示监听状态的连接。</li><li><code>-n</code>：以数字形式显示地址和端口号，而不是解析成主机名和服务名。</li><li><code>-p</code>：显示使用该连接的程序和进程 ID。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有监听状态的 TCP 连接及其对应的程序和进程 ID</span></span><br><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure><p><code>ss</code> 是一个用于显示套接字统计信息的工具，相比 <code>netstat</code> 更加高效，且能提供更详细的网络连接信息。</p><ul><li><strong>基本语法</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [选项]</span><br></pre></td></tr></table></figure><ul><li>常用选项<ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：显示监听状态的连接。</li><li><code>-n</code>：以数字形式显示地址和端口号。</li><li><code>-p</code>：显示使用该连接的程序和进程 ID。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有监听状态的 TCP 连接及其对应的程序和进程 ID</span></span><br><span class="line">ss -tlnp</span><br></pre></td></tr></table></figure><p><strong>linux swap交换内存</strong></p><ol><li>Swap 的作用</li></ol><p>当系统物理内存不足时，操作系统会把一些不常用的内存页转移到 Swap 空间中，从而为当前正在运行的程序腾出物理内存。尽管从磁盘读写数据比从物理内存读写慢很多，但 Swap 能防止系统因内存不足而崩溃。</p><ol><li>查看 Swap 使用情况</li></ol><p>可以使用 <code>swapon</code>、<code>free</code> 或 <code>top</code> 等命令查看 Swap 的使用情况。</p><ul><li><strong><code>swapon -s</code> 命令</strong>：显示系统中正在使用的 Swap 分区或文件的信息。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FilenameTypeSizeUsedPriority</span><br><span class="line">/swapfile                               file20971480-2</span><br></pre></td></tr></table></figure><ul><li><strong><code>free -h</code> 命令</strong>：以人类可读的格式显示系统的内存和 Swap 使用情况。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.7G        2.2G        3.4G        208M        2.1G        5.1G</span><br><span class="line">Swap:          2.0G          0B        2.0G</span><br></pre></td></tr></table></figure><ul><li><strong><code>top</code> 命令</strong>：在 <code>top</code> 界面中，按 <code>f</code> 键，然后选择 <code>S</code>（Swap） 可以显示 Swap 的使用情况。按 <code>q</code> 键退出 <code>top</code> 界面。</li></ul><p><strong>如何用find命令查找最近更新的文件，举例</strong></p><p>文件的更新通常涉及三种时间属性：访问时间（<code>atime</code>）、修改时间（<code>mtime</code>）和状态改变时间（<code>ctime</code>）。下面结合不同时间属性，给出具体的查找示例。</p><hr><p><strong>介绍下final和static的区别和使用</strong></p><p>概念含义</p><ul><li><strong><code>final</code></strong>：意味着 “不可变” 或 “最终的”。它可以修饰类、方法和变量，用来限制类不能被继承、方法不能被重写、变量不能被重新赋值。</li><li><strong><code>static</code></strong>：表示 “静态的”。它能修饰类、方法、变量和代码块，让这些成员属于类本身，而非类的实例。</li></ul><p>作用对象</p><ul><li><strong><code>final</code></strong>：可用于类、方法和变量。</li><li><strong><code>static</code></strong>：可用于类（仅限内部类）、方法、变量和代码块。</li></ul><p>内存分配</p><ul><li><strong><code>final</code></strong>：变量在初始化后，其值就不能再改变，但它仍然是实例变量，每个对象都有自己的一份副本。</li><li><strong><code>static</code></strong>：变量和方法属于类，在类加载时就会被分配内存，所有对象共享同一份静态成员。</li></ul><p>继承和重写</p><ul><li><code>final</code>：<ul><li>修饰类时，该类不能被继承。</li><li>修饰方法时，该方法不能被重写。</li></ul></li><li><code>static</code>：<ul><li>静态方法不能被重写，但可以被隐藏（子类可以定义与父类同名的静态方法）。</li><li>静态变量也可以被隐藏。</li></ul></li></ul><p><strong>Java中常见集合类有哪些，怎么应用（不少于5个）</strong></p><p><code>ArrayList</code></p><ul><li><strong>特点</strong>：基于动态数组实现，可动态扩容，能高效随机访问元素，但插入和删除操作在中间或开头位置效率较低。</li><li><strong>应用场景</strong>：适用于需要频繁随机访问元素，且插入和删除操作主要在列表末尾的场景。</li></ul><p><code>LinkedList</code></p><ul><li><strong>特点</strong>：基于双向链表实现，插入和删除操作效率高，尤其是在列表中间或开头位置，但随机访问效率低。</li><li><strong>应用场景</strong>：适用于需要频繁进行插入和删除操作的场景，如实现栈、队列等数据结构。</li></ul><p><code>HashSet</code></p><ul><li><strong>特点</strong>：基于哈希表实现，不允许存储重复元素，元素无序。</li><li><strong>应用场景</strong>：适用于需要快速判断元素是否存在，且不关心元素顺序的场景。</li></ul><p><code>TreeSet</code></p><ul><li><strong>特点</strong>：基于红黑树实现，不允许存储重复元素，元素会按照自然顺序或指定的比较器进行排序。</li><li><strong>应用场景</strong>：适用于需要对元素进行排序的场景。</li></ul><p><code>HashMap</code></p><ul><li><strong>特点</strong>：基于哈希表实现，存储键值对，键不允许重复，元素无序。</li><li><strong>应用场景</strong>：适用于需要根据键快速查找值的场景。</li></ul><p><code>TreeMap</code></p><ul><li><strong>特点</strong>：基于红黑树实现，存储键值对，键不允许重复，元素会按照键的自然顺序或指定的比较器进行排序。</li><li><strong>应用场景</strong>：适用于需要对键进行排序的场景。</li></ul><p><code>LinkedHashMap</code></p><ul><li><strong>特点</strong>：继承自 <code>HashMap</code>，同时维护了插入顺序或访问顺序，可根据插入顺序或访问顺序遍历元素。</li><li><strong>应用场景</strong>：适用于需要按照插入顺序或访问顺序遍历元素的场景。</li></ul><p><strong>构造函数为什么不能是虚函数</strong></p><p><strong>什么是方法重载和方法重写？有什么区别</strong></p><p><strong>在finally中return会怎样</strong></p><p><strong>解释封装</strong></p><p><strong>异常处理中finally一定会执行吗</strong></p><p><strong>string类可以被继承吗</strong></p><p><strong>接口是什么？接口和抽象类有什么区别</strong></p><p><strong>ipv4网络号枯竭，nat和ipv6分别是怎么解决的</strong></p><p><strong>TCP拥塞控制是什么？有哪些拥塞控制算法</strong></p><p><strong>什么是keepalive？TCP为什么要keepalive</strong></p><p><strong>TCP重传触发条件？超时重传和快速重传的区别</strong></p><p><strong>TCP为什么要有最后一次ACK</strong></p><p><strong>TCP如何实现断点续传</strong></p><p><strong>简述键入url到显示页面的过程</strong></p><p><strong>dns是什么？工作流程？</strong></p><p><strong>什么是三次握手四次挥手？有什么作用</strong></p><p><strong>内核态和用户态的区别？为什么要设计两种模式</strong></p><p><strong>数据库的悲观锁和乐观锁</strong></p><p><strong>inner join、left join和right join的区别</strong></p><p><strong>数据库索引失效时，如何诊断问题并采取措施恢复索引的有效性？描述可能的原因以及具体的解决步骤</strong></p><p><strong>SQL事务是怎么实现的</strong></p><p><strong>什么是主键？主键的特点和作用，如何设计主键</strong></p><p><strong>索引怎么确定？原则</strong></p><p><strong>什么是聚合函数？举例聚合函数及作用</strong></p><p><strong>怎么检验优化性能，用什么工具或方法</strong></p><p><strong>redis评论系统，如何高效的删除评论和附属评论</strong></p><p><strong>缓存失效和缓存不一致</strong></p><p><strong>如何设计微博热点话题排行榜的缓存更新策略？</strong></p><p><strong>分布式系统中，缓存与数据库不一致怎么处理</strong></p><p><strong>如何设计热门话题榜？怎么保证数据的时效性</strong></p><p><strong>设计网站内容搜索</strong></p><p><strong>如何确定内容搜索权重</strong></p><p><strong>游戏排行榜如何设计数据结构和更新策略</strong></p><ul><li>高并发场景下如何保证准确性和一致性</li></ul><p><strong>如何设计一个高并发的计数器，需要考虑实时性和一致性</strong></p><ul><li><p><strong>使用了redis处理高并发，那如果redis也无法支持呢</strong></p></li><li><p><strong>主从切换的情况下或主从网络不畅，怎么办</strong></p></li></ul><h2 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h2><p><strong>平时怎么了解前沿的软件开发新技术？渠道有哪些？不同渠道的区别？</strong></p><ul><li><p><strong>在微信公众号的文章中学到了什么印象深刻的技术？</strong></p><p><strong>慢sql的优化：</strong></p></li><li><p><strong>平时使用中应用了吗？怎么做的？</strong></p></li></ul><p>​    <strong>项目中深分页优化：</strong></p><p><strong>接触到新技术怎么学习</strong></p><p><strong>项目中最有难度的问题是？怎么解决</strong></p><p><strong>高压环境怎么完成任务，举例</strong></p><p><strong>软件开发领域，哪些核心能力是你需要持续提升的？有什么具体的计划？</strong></p><p><strong>描述一个你成功将一个想法转化为实际的例子</strong></p><p>​    <strong>慢sql的优化：</strong></p><p>​    <strong>具体怎么优化的？</strong></p><p><strong>代码重构或代码优化过程中，遇到困难如何解决</strong></p><p><strong>未来三年职业规划</strong></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode_JavaSolution</title>
      <link href="/2024/06/27/JSolution/"/>
      <url>/2024/06/27/JSolution/</url>
      
        <content type="html"><![CDATA[<hr><p>0x3f</p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>时间复杂度：$O(logn)$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目的前提是</p><ul><li><p><strong>数组为有序数组</strong></p></li><li><p><strong>数组中无重复元素</strong></p></li></ul><p>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p><em>简单</em></p><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123; <span class="comment">// [left, right]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums [mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] == target</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123; <span class="comment">// [left, right)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length -<span class="number">1</span> ]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] == target</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong>时间复杂度：$O(n)$。</p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><em>简单</em></p><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 把nums中不等于val的数依次填在下标上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x != val) &#123;</span><br><span class="line">                nums[k++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] != val) &#123;</span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h4><p><em>简单</em></p><blockquote><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// k表示保留元素填入的下标 == 唯一元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="80-删除有序数组中的重复项-Ⅱ"><a href="#80-删除有序数组中的重复项-Ⅱ" class="headerlink" title="80. 删除有序数组中的重复项 Ⅱ"></a>80. 删除有序数组中的重复项 Ⅱ</h4><p><em>中等</em></p><blockquote><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// nums[k - 2] == nums[i] 👉 nums[k - 2] == nums[k - 1] == nums[i]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k - <span class="number">2</span>] != nums[i]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>双指针：有序数组平方最大值在数组的两端产生，<code>i</code>指向起始位置，<code>j</code>指向终止位置，<code>k</code>指向结果数组终止位置（非递减顺序）。比较平方后较大值填入结果数组，移动对应指针。</p><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h3><p><em>简单</em></p><blockquote><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">                res[k--] = nums[j] * nums[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[k--] = nums[i] * nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口：所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。时间复杂度：$O(n)$。</p><p>窗口：满足和$\geq target$的长度最小的连续子数组。</p><p>起始位置：窗口满足条件就向前移动（缩小）。</p><p>终止位置：遍历数组。</p><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><em>中等</em></p><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p><p><strong>子数组</strong></p><p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123; <span class="comment">// 遍历右端点</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// 满足要求</span></span><br><span class="line">                res = Math.min(res, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++]; <span class="comment">// 左端点右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵Ⅱ"><a href="#螺旋矩阵Ⅱ" class="headerlink" title="螺旋矩阵Ⅱ"></a>螺旋矩阵Ⅱ</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>定义矩阵的边界：<code>L,R,T,B</code>。</p><p>迭代范围：<code>num = 1</code>，<code>target = n * n</code>。</p><p>当 <code>num &lt;= target</code> 时，始终按照 <code>从左到右</code> <code>从上到下</code> <code>从右到左</code> <code>从下到上</code> 填入顺序循环，每次填入后：</p><ul><li>执行 <code>num += 1</code>：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界 <code>T += 1</code>，相当于上边界向内缩 1。</li></ul><h3 id="59-螺旋矩阵Ⅱ"><a href="#59-螺旋矩阵Ⅱ" class="headerlink" title="59. 螺旋矩阵Ⅱ"></a>59. 螺旋矩阵Ⅱ</h3><p><em>中等</em></p><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/loadingPostImg.gif" data-original="spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>, target = n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>, T = <span class="number">0</span>, R = n - <span class="number">1</span>, B = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= R; i++) &#123; <span class="comment">// 从左到右</span></span><br><span class="line">                res[T][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            ++T;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> T; i &lt;= B; i++) &#123; <span class="comment">// 从上到下</span></span><br><span class="line">                res[i][R] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            --R;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> R; i &gt;= L; i--) &#123; <span class="comment">// 从右到左</span></span><br><span class="line">                res[B][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            --B;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> B; i &gt;=T; i--) &#123; <span class="comment">// 从下到上</span></span><br><span class="line">                res[i][L] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            ++L;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">// 节点的构造器（无参）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造器（一个参数）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造器（两个参数）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>插入/删除（时间复杂度）</th><th>查询（时间复杂度）</th><th>适用场景</th></tr></thead><tbody><tr><td>数组</td><td>$O(n)$</td><td>$O(1)$</td><td>数据量固定，频繁查询，较少增删</td></tr><tr><td>链表</td><td>$O(1)$</td><td>$O(n)$</td><td>数据量不固定，频繁增删，较少查询</td></tr></tbody></table></div><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>单链表删除头节点的两种方式：</p><ul><li><p><strong>直接使用原来的链表来进行删除操作。</strong></p><p>将头节点向后移动一位，这样就从链表中移除了一个头节点。需要<strong>单独</strong>写一段逻辑来处理移除头节点的情况。</p></li><li><p><strong>设置一个虚拟头节点再进行删除操作。</strong></p></li></ul><p>​    原链表的所有节点就都可以按照统一的方式进行移除了。别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头节点。</p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><em>简单</em></p><blockquote><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="/loadingPostImg.gif" data-original="removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next; <span class="comment">// 删除下一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next; <span class="comment">// 继续向后遍历链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加虚拟节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不添加虚拟节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经为null，提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已确定当前head.val != val</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不添加虚拟节点and pre Node方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr.next != <span class="literal">null</span> &amp;&amp; curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h3><p><em>中等</em></p><blockquote><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><h2 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h2><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>双指针：从0和length - 1 向中间移动，并完成<code>交换元素</code>。</p><ul><li>^=</li><li>temp</li></ul><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法用temp来交换数值容易理解些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反转字符串Ⅱ"><a href="#反转字符串Ⅱ" class="headerlink" title="反转字符串Ⅱ"></a>反转字符串Ⅱ</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><ul><li>可以认为是每隔2k个反转前k个。<code>i</code>作为每2k个需处理的字符的起点，<code>i += 2 * k</code>。判断终点<code>Math.min(i + k - 1, s.length - 1)</code>。</li><li>按题目要求。</li></ul><h3 id="541-反转字符串Ⅱ"><a href="#541-反转字符串Ⅱ" class="headerlink" title="541. 反转字符串Ⅱ"></a>541. 反转字符串Ⅱ</h3><p><em>简单</em></p><blockquote><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 每隔2k个反转前k个</span></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length - <span class="number">1</span>; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(left + k - <span class="number">1</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                ch[left] ^= ch[right];</span><br><span class="line">                ch[right] ^= ch[left];</span><br><span class="line">                ch[left] ^= ch[right];</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length - <span class="number">1</span>; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= ch.length) &#123; <span class="comment">// 反转前k个</span></span><br><span class="line">                swap(ch, i, i + k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 少于k个</span></span><br><span class="line">            swap(ch, i, ch.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            ch[right] ^= ch[left];</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>双指针</p><ul><li><code>i</code>指向旧数组的末位，<code>j</code>指向新数组的末位。</li></ul><p><strong>很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong>从前向后填充就是$O(n^2)$​的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p><h3 id="替换数字-1"><a href="#替换数字-1" class="headerlink" title="替换数字"></a>替换数字</h3><blockquote><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入一个字符串 s,s 仅包含小写字母和数字字符。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>打印一个新的字符串，其中每个数字字符都被替换为了number</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1b2c3</span><br></pre></td></tr></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anumberbnumbercnumber</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    len += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                ch[i] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                    ch[j--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ch[j--] = ch[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ul><li>双指针去除空格</li><li>反转整个字符串</li><li>反转单词</li></ul><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><p><em>中等</em></p><blockquote><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 去除首尾以及中间多余空格</span></span><br><span class="line">        ch = removeExtraSpaces(ch);</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverse(ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 反转单词</span></span><br><span class="line">        reverseEachWord(ch);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] removeExtraSpaces(<span class="type">char</span>[] ch) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; ch.length; fast++) &#123;</span><br><span class="line">            <span class="comment">// fast 移除空格</span></span><br><span class="line">            <span class="keyword">if</span> (ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// slow 加空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) &#123;</span><br><span class="line">                    ch[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历单词</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; ch.length &amp;&amp; ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    ch[slow++] = ch[fast++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] newCh = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(ch, <span class="number">0</span>, newCh, <span class="number">0</span>, slow); <span class="comment">// 将ch[0]开始slow个元素复制给newCh[0]</span></span><br><span class="line">        <span class="keyword">return</span> newCh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt;= ch.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;set a wrong right&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            ch[right] ^= ch[left];</span><br><span class="line">            ch[left++] ^= ch[right--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt;= ch.length; end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end == ch.length || ch[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(ch, start, end - <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋转字符串"><a href="#右旋转字符串" class="headerlink" title="右旋转字符串"></a>右旋转字符串</h2><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><ul><li>整体反转</li><li>局部反转</li></ul><p><img src="/loadingPostImg.gif" data-original="20231106172058.png" alt="img"></p><h3 id="右旋转字符串-1"><a href="#右旋转字符串-1" class="headerlink" title="右旋转字符串"></a>右旋转字符串</h3><blockquote><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 </p><p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共一行，为进行了右旋转操作后的字符串。</p><h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">abcdefg</span><br></pre></td></tr></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgabcde</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(sc.nextLine());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        reverse(ch, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        reverse(ch, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(ch, n, len - <span class="number">1</span>);</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            ch[end] ^= ch[start];</span><br><span class="line">            ch[start++] ^= ch[end--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>有$n$个物品，第$i$个物品的体积为$w[i]$，价值为$v[i]$。每个物品至多选一个，求体积和不超过$capacity$时的最大价值和。</p><ul><li>当前操作？枚举第$i$个物品选还是不选：不选，剩余容量不变；选，剩余容量减少$w[i]$。确定递归参数$i,c$。</li><li>子问题？剩余容量为$c$，从前$i$个物品中得到的最大价值和。<ul><li>不选：在剩余容量为$c$时，从前$i-1$​个物品中得到的最大价值和。</li><li>选：在剩余容量为$c-w[i]$时，从前$i-1$​个物品中得到的最大价值和。</li></ul></li></ul><script type="math/tex; mode=display">dfs(i, c) = max(dfs(i - 1, c), dfs(i - 1, c - w[i]) + v[i])</script><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a><a href="#494. 目标和">494.目标和</a></h3><p>恰好装capacity，求方案数/最大/最小价值和</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><h3 id="空间优化：两个数组"><a href="#空间优化：两个数组" class="headerlink" title="空间优化：两个数组"></a>空间优化：两个数组</h3><h3 id="空间优化：一个数组"><a href="#空间优化：一个数组" class="headerlink" title="空间优化：一个数组"></a>空间优化：一个数组</h3><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h2 id="常见变形"><a href="#常见变形" class="headerlink" title="常见变形"></a>常见变形</h2><ul><li><p>至多装capacity，求方案数/最大价值和</p></li><li><p>恰好装capacity，求方案数/最大/最小价值和 </p><script type="math/tex; mode=display">dfs(i, c) = dfs(i - 1, c) + dfs(i - 1, c - w[i])</script></li><li><p>至少装capacity，求方案数/最小价值和</p></li></ul><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h1><p><em>简单</em></p><blockquote><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序双指针</span></span><br><span class="line">        <span class="comment">// 初始化三个指针指向三个数组的末尾p1,p2,p</span></span><br><span class="line">        <span class="comment">// 比较nums1[p1]和nums2[p2] 较大的放入nums1[p]</span></span><br><span class="line">        <span class="comment">// p1 &gt;= 0 &amp;&amp; nums1[p1] &gt; nums2[p2] 放p1且p - 1, p1 - 1 否则 p - 1, p2 - 1</span></span><br><span class="line">        <span class="comment">// nums1[p1] == nums2[p2]时 规定放nums2[p2]</span></span><br><span class="line">        <span class="comment">// O(m + n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>, p2 = n - <span class="number">1</span>, p = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; nums1[p1] &gt; nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><p><em>简单</em></p><blockquote><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// Boyer-Moore</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>; <span class="comment">// 票数和众数 = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += (num == x) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="494-目标和-1"><a href="#494-目标和-1" class="headerlink" title="494. 目标和"></a>494. 目标和</h1><p><em>中等</em></p><blockquote><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            s += x;</span><br><span class="line">        &#125;</span><br><span class="line">        s -= Math.abs(target);</span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">0</span> || s % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s / <span class="number">2</span>; <span class="comment">// 背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][c] != -<span class="number">1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][c] = dfs(i - <span class="number">1</span>, c); <span class="comment">// 只能不选</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][c] = dfs(i - <span class="number">1</span>, c) + dfs(i - <span class="number">1</span>, c - nums[i]); <span class="comment">// 不选 + 选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h1><p><em>简单</em></p><blockquote><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// sumL = sum - nums[mid] - sumL</span></span><br><span class="line">        <span class="comment">// 2 * sumL = sum - nums[mid]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>; mid &lt; nums.length; mid++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * sumL == sum - nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            sumL += nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2734-执行子串操作后的字典序最小字符串"><a href="#2734-执行子串操作后的字典序最小字符串" class="headerlink" title="2734. 执行子串操作后的字典序最小字符串"></a>2734. 执行子串操作后的字典序最小字符串</h1><p><em>中等</em></p><blockquote><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以完成以下行为：</p><ul><li>选择 <code>s</code> 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，’b’ 用 ‘a’ 替换，’a’ 用 ‘z’ 替换。</li></ul><p>返回执行上述操作 <strong>恰好一次</strong> 后可以获得的 <strong>字典序最小</strong> 的字符串。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p><p>现有长度相同的两个字符串 <code>x</code> 和 字符串 <code>y</code> ，在满足 <code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 上，如果 <code>x[i]</code> 在字母表中先于 <code>y[i]</code> 出现，则认为字符串 <code>x</code> 比字符串 <code>y</code> <strong>字典序更小</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbabc&quot;</span><br><span class="line">输出：&quot;baabc&quot;</span><br><span class="line">解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 </span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;acbbc&quot;</span><br><span class="line">输出：&quot;abaab&quot;</span><br><span class="line">解释：我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。</span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;kddsbncd&quot;</span><br><span class="line">解释：我们选择整个字符串执行操作。</span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把 a 替换成 z 会让字典序变大，所以被替换的子串不能包含 a。反过来，如果子串不含 a，那么对其操作可以让 s 字典序变小。</span></span><br><span class="line"><span class="comment">从左到右找到第一个不等于 a 的字符 s[i]，然后从 i 开始，把每个字符都减一，直到遍历结束或者遇到了 a。例如abca 操作中间的子串 bc，得到答案 aaba。</span></span><br><span class="line"><span class="comment">如果 s 全为 a，由于题目要求必须操作一次，可以把最后一个 a 改成 z。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">smallestString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt; <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(;i &lt; n &amp;&amp; s[i] &gt; <span class="string">&#x27;a&#x27;</span>; i++) &#123;</span><br><span class="line">                    s[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[n - <span class="number">1</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain Consensus Algorithms</title>
      <link href="/2024/06/05/bl/"/>
      <url>/2024/06/05/bl/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链共识算法"><a href="#区块链共识算法" class="headerlink" title="区块链共识算法"></a>区块链共识算法</h1><h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h2><p>区块链共识算法是一种在区块链网络中用于确保所有参与者之间达成一致的机制。它允许分布式网络中的节点在去中心化的情况下，就区块链数据的当前状态达成共识。共识算法的主要目标是确保网络中的每个节点都同意交易记录的顺序和内容，从而维护整个区块链系统的完整性和不可篡改性。如何在不可信节点之间达成共识是拜占庭将军（Byzantine Generals, BG）问题的变体。在BG问题中，一群指挥拜占庭军队的将军们包围了一个城市。一些将军倾向于进攻，而另一些则倾向于撤退。然而，如果只有部分将军发起攻击，那么整个攻击就会失败。因此，他们必须达成一个共识，决定是进攻还是撤退。在分布式环境中达成共识是一个挑战。对于区块链来说，这同样是一个挑战，因为区块链网络是分布式的。在区块链中，没有中心节点来确保分布式节点上的账本都是相同的。因此需要一些协议来确保不同节点上的账本保持一致。</p><h2 id="2-共识算法"><a href="#2-共识算法" class="headerlink" title="2 共识算法"></a>2 共识算法</h2><h3 id="2-1-PoW"><a href="#2-1-PoW" class="headerlink" title="2.1 PoW"></a>2.1 PoW</h3><p>工作量证明（PoW，Proof of work）是比特币网络中使用的一种共识策略。在去中心化网络中，需要选择某个节点来记录交易。最简单的方法是随机选择，但随机选择容易受到攻击。因此，如果一个节点想要发布一个交易区块，它必须做很多工作来证明这个节点不太可能攻击网络。通常所说的工作指的是计算机计算。在PoW中，网络中的每个节点都在计算区块头的哈希值。区块头包含一个随机数（nonce），矿工会频繁地改变这个随机数以得到不同的哈希值。共识要求计算出的值必须等于或小于某个给定的值。当一个节点达到目标值时，它会将区块广播给其他节点，所有其他节点必须相互确认哈希值的正确性。如果区块得到验证，其他矿工就会将这个新区块添加到他们自己的区块链上。计算哈希值的节点被称为矿工，而PoW过程在比特币中被称为挖矿。</p><p>在去中心化网络中，当多个节点几乎同时找到一个合适的随机数（nonce）时，可能会同时生成有效的区块。然而，两个竞争的分支同时生成下一个区块的可能性是很小的。在PoW协议中，之后变得更长的链被认为是真实的链。这个过程通常被称为“链的分叉”或“分叉战争”，其中矿工们通过继续在特定分支上挖掘新区块来“投票”决定哪个分支将成为主链。这种机制确保了网络最终能够达成共识，即使在发生临时分叉的情况下。一旦一个分支变得更长，其他矿工就会转换到这个分支上，因为继续在较短的分支上工作将不再经济，因为较长的链代表了网络中的多数算力和共识。矿工们需要进行大量的计算机计算，但这些工作会消耗大量的资源。为了减轻资源浪费，一些PoW协议被设计成其工作可以有其他应用的副产品。例如，Primecoin在挖矿过程中寻找特殊的质数链，这些质数链可以用于数学研究。Primecoin的设计初衷是将挖矿过程中的计算工作转化为对科学有实际贡献的活动。通过寻找所谓的“卡特兰数”（Catalan numbers）和“双链质数”（bi-twin primes），Primecoin的挖矿过程不仅维护了区块链的安全性和去中心化，同时也为数学领域提供了有价值的数据和发现。这种设计试图解决传统PoW挖矿中存在的能源消耗和资源浪费问题，同时为科学研究做出贡献。</p><p> 工作量证明最核心的技术原理是散列函数（哈希）。在比特币中，PoW工作其实就是如何去计算一个区块的目标哈希值问题，让用户进行大量的穷举运算，同时得出这个哈希值还必须满足一些必要条件，这个条件在区块链中其实就是一个难度系数值，通过计算出的哈希值是否符合前面N位全是0，最终达成工作量证明。比如现在给出一个固定的字符串“Hello, blockchain”，现在要求计算的难题是将这个字符串与一个随机数（Nonce）拼接起来，并通过SHA256哈希计算一个固定256位长度的哈希值，如果计算结果得到的前5位全是0，即认为满足计算条件，同时得到的随机数（Nonce）值证明为达成工作量证明的有效随机数。</p><p>PoW速度慢，耗能大，易受“规模经济”（economies of scale）的影响。实例有 Bitcoin、Ethereum、LiteCoin、Dogecoin等。</p><h3 id="2-2-PoS"><a href="#2-2-PoS" class="headerlink" title="2.2 PoS"></a>2.2 PoS</h3><p>权益证明（PoS，Proof of Stake）节能、攻击者代价更大、不易受“规模经济”的影响，是PoW的一种节能替代方案。在PoS中，矿工需要证明他们持有一定数量的货币所有权。普遍认为，拥有更多货币的人不太可能攻击网络。基于账户余额的选择方式相当不公平，因为最富有的个人注定会在网络中占据主导地位。因此，为了解决这个问题，许多解决方案被提出，结合了权益大小来决定谁来铸造下一个区块。Blackcoin使用随机化来预测下一个生成者，寻找最低的哈希值与权益大小的组合。Peercoin则偏好基于币龄的选择。在Peercoin中，持有时间更长、数量更多的货币集合有更大的概率挖掘下一个区块。</p><p>PoS机制通过减少挖矿所需的计算资源，旨在解决PoW挖矿中的能源消耗问题。它通过权益持有量和/或其他因素（如币龄）来选择区块生产者，从而鼓励长期投资并减少网络攻击的可能性。随着区块链技术的发展，越来越多的项目开始探索和采用PoS或其变体作为其共识机制。例如，以太坊计划从Ethash（一种PoW）迁移到Casper（一种PoS）。</p><p>每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。</p><p>PoS存在无利害关系（Nothing at stake）攻击问题。实例有Ethereum、Peercoin、Nxt等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现pos挖矿的原理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Data <span class="type">string</span> <span class="comment">//</span></span><br><span class="line">    PreHash <span class="type">string</span></span><br><span class="line">    Hash <span class="type">string</span></span><br><span class="line">    Timestamp <span class="type">string</span></span><br><span class="line">    <span class="comment">//记录挖矿节点</span></span><br><span class="line">    Validator *Node</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genesisBlock</span><span class="params">()</span></span> Block  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> genesBlock  = Block&#123;<span class="number">0</span>, <span class="string">&quot;Genesis block&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,time.Now().String(),&amp;Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;dd&quot;</span>&#125;&#125;</span><br><span class="line">    genesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</span><br><span class="line">    <span class="keyword">return</span> genesBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BlockHash</span><span class="params">(block *Block)</span></span> []<span class="type">byte</span>  &#123;</span><br><span class="line">    record := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="type">byte</span>(record))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建全节点类型</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Tokens <span class="type">int</span> <span class="comment">//持币数量</span></span><br><span class="line">    Days <span class="type">int</span> <span class="comment">//持币时间</span></span><br><span class="line">    Address <span class="type">string</span> <span class="comment">//地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建5个节点</span></span><br><span class="line"><span class="comment">//算法的实现要满足 持币越多的节点越容易出块</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">make</span>([]Node, <span class="number">5</span>)</span><br><span class="line"><span class="comment">//存放节点的地址</span></span><br><span class="line"><span class="keyword">var</span> addr = <span class="built_in">make</span>([]*Node, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitNodes</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    nodes[<span class="number">0</span>] = Node&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;0x12341&quot;</span>&#125;</span><br><span class="line">    nodes[<span class="number">1</span>] = Node&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;0x12342&quot;</span>&#125;</span><br><span class="line">    nodes[<span class="number">2</span>] = Node&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;0x12343&quot;</span>&#125;</span><br><span class="line">    nodes[<span class="number">3</span>] = Node&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;0x12344&quot;</span>&#125;</span><br><span class="line">    nodes[<span class="number">4</span>] = Node&#123;<span class="number">5</span>, <span class="number">1</span>, <span class="string">&quot;0x12345&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    cnt :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</span><br><span class="line">            addr[cnt] = &amp;nodes[i]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用Pos共识算法进行挖矿</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNewBlock</span><span class="params">(lastBlock *Block, data <span class="type">string</span>)</span></span> Block&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line">    newBlock.Index = lastBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = time.Now().String()</span><br><span class="line">    newBlock.PreHash = lastBlock.Hash</span><br><span class="line">    newBlock.Data = data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过pos计算由那个村民挖矿</span></span><br><span class="line">    <span class="comment">//设置随机种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="comment">//[0,15)产生0-15的随机值</span></span><br><span class="line">    <span class="keyword">var</span> rd =rand.Intn(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选出挖矿的矿工</span></span><br><span class="line">    node := addr[rd]</span><br><span class="line">    <span class="comment">//设置当前区块挖矿地址为矿工</span></span><br><span class="line">    newBlock.Validator = node</span><br><span class="line">    <span class="comment">//简单模拟 挖矿所得奖励</span></span><br><span class="line">    node.Tokens += <span class="number">1</span></span><br><span class="line">    newBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    InitNodes()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建创世区块</span></span><br><span class="line">    <span class="keyword">var</span> genesisBlock = genesisBlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新区快</span></span><br><span class="line">    <span class="keyword">var</span> newBlock = CreateNewBlock(&amp;genesisBlock, <span class="string">&quot;new block&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印新区快信息</span></span><br><span class="line">    fmt.Println(newBlock)</span><br><span class="line">    fmt.Println(newBlock.Validator.Address)</span><br><span class="line">    fmt.Println(newBlock.Validator.Tokens)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-DPOS"><a href="#2-3-DPOS" class="headerlink" title="2.3 DPOS"></a>2.3 DPOS</h3><p>委任权益证明（DPOS，Delegated Proof-of-Stake）系统中，权益持有者可以选举领导者（或称为见证人，Witness）。经权益持有者授权，这些领导者可进行投票。该机制使得DPoS要快于正常的PoS。 例如，EOS 中选举出 21 位见证人，并且有一堆节点（潜在的见证人）作为候选者。一旦见证人节点死亡或是做出了恶意行为，新节点就会立刻替代见证人节点。见证人会因为生成区块而获得一笔支付费用。该费用是由权益持有者设立的 。 通常，所有节点采用轮询方式，一次生成一个区块。该机制防止一个节点发布连续的块，进而执行“双重支付”攻击。如果一个见证人在分配给他的时间槽中未生成区块，那么该时间槽就被跳过，并由下一位见证人生成下一个区块。如果见证人持续丢失他的区块，或是发布了错误的交易，那么权益持有者将投票决定其退出，用更好的见证人替换他。 在DPoS中，矿工可以合作生成块，而不是像在PoW和PoS中那样竞争生成。通过区块生成的部分中心化，DPoS的运行可以比其它共识算法呈数量级快。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。</p><p>DPOS略为中心化、拥有高权益的参与者可投票使自己成为一名验证者，这是已在EOS中出现的问题。DPOS是Bitshares的支柱，它通过减少参与共识过程的节点数量，提高了交易处理的效率。这种机制还有助于降低网络的拥堵，提高整体性能。DPOS通过委托权益持有者投票给代表，使得网络治理更加民主化，同时也确保了网络的安全性和去中心化。实例有BitShares、Steemit、EOS、Lisk、Ark等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Timestamp <span class="type">string</span></span><br><span class="line">    Prehash <span class="type">string</span></span><br><span class="line">    Hash <span class="type">string</span></span><br><span class="line">    Data []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">    delegate *Node<span class="comment">// 代理 区块由哪个节点挖出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenesisBlock</span><span class="params">()</span></span>  Block &#123;</span><br><span class="line">    gene := Block&#123;<span class="number">0</span>, time.Now().String(),<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;genesis block&quot;</span>), <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">    gene.Hash = <span class="type">string</span>(blockHash(gene))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delegate *Node = <span class="built_in">new</span>(Node)</span><br><span class="line">    delegate.Name = <span class="string">&quot;Genis Block&quot;</span></span><br><span class="line">    delegate.Votes = <span class="number">0</span>;</span><br><span class="line">    gene.delegate = delegate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gene</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockHash</span><span class="params">(block Block)</span></span> []<span class="type">byte</span>  &#123;</span><br><span class="line"></span><br><span class="line">    record := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)</span><br><span class="line"></span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="type">byte</span>(record))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类型</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span> <span class="comment">//节点名称</span></span><br><span class="line">    Votes <span class="type">int</span>    <span class="comment">// 被选举的票数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span></span>GenerateNewBlock(lastBlock Block, data []<span class="type">byte</span>) Block  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock = Block&#123;lastBlock.Index+<span class="number">1</span>, time.Now().String(), lastBlock.Hash, <span class="string">&quot;&quot;</span>, data, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">    newBlock.Hash = hex.EncodeToString(blockHash(newBlock))</span><br><span class="line">    newBlock.delegate = node</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="keyword">var</span> NodeArr = <span class="built_in">make</span>([]Node,<span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        name := fmt.Sprintf(<span class="string">&quot;NODE %d num&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">        NodeArr[i] = Node&#123;name, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单模拟投票</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Vote</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        rand.Seed(time.Now().UnixNano())</span><br><span class="line">        vote := rand.Intn(<span class="number">10</span>) + <span class="number">1</span></span><br><span class="line">        NodeArr[i].Votes = vote</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选出票数最多的前3位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortNodes</span><span class="params">()</span></span> []Node  &#123;</span><br><span class="line">    n:= NodeArr</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(n) ;i++  &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(n)<span class="number">-1</span> ;j++  &#123;</span><br><span class="line">            <span class="keyword">if</span> n[j].Votes &lt; n[j+<span class="number">1</span>].Votes &#123;</span><br><span class="line">                n[j],n[j+<span class="number">1</span>] = n[j+<span class="number">1</span>],n[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n[:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    CreateNode()</span><br><span class="line">    fmt.Println(NodeArr)</span><br><span class="line">    Vote()</span><br><span class="line">    nodes := SortNodes()</span><br><span class="line"></span><br><span class="line">    fmt.Println(nodes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建创世区块</span></span><br><span class="line">    gene := GenesisBlock()</span><br><span class="line"></span><br><span class="line">    lastBlock := gene</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i&lt; <span class="built_in">len</span>(nodes) ;i++  &#123;</span><br><span class="line">        <span class="comment">//打印新区块信息</span></span><br><span class="line">        <span class="comment">// var node *Node</span></span><br><span class="line">         node := lastBlock.delegate</span><br><span class="line">         fmt.Println(<span class="string">&quot;区块号:&quot;</span>,lastBlock.Index,<span class="string">&quot;节点名称:&quot;</span>,node.Name,<span class="string">&quot;节点投票数:&quot;</span>,node.Votes)</span><br><span class="line"></span><br><span class="line">        lastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;new block %d&quot;</span>,i)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-PBFT"><a href="#2-4-PBFT" class="headerlink" title="2.4 PBFT"></a>2.4 PBFT</h3><p>实用拜占庭容错（PBFT，Practical Byzantine Fault Tolerance）是一种复制算法，用于容忍拜占庭错误。PBFT能够处理高达1/3恶意拜占庭副本的情况。其中一个新区块的确定是在一轮中完成的。在每一轮中，会根据某些规则选择一个主节点。主节点负责对交易进行排序。整个过程可以划分为三个阶段：预准备（pre-prepare）、准备（prepare）和提交（commit）。在每个阶段，如果一个节点收到了超过2/3的节点的投票，它就会进入下一个阶段。因此，PBFT要求网络中的每个节点都是已知的。与PBFT类似，Stellar共识协议（SCP）也是一种拜占庭协议。在PBFT中，每个节点必须查询其他节点，而SCP则给予参与者选择相信哪些其他参与者的权利。基于PBFT，Antshares实现了他们的dBFT（委托拜占庭容错）。在dBFT中，一些专业节点被投票选出以记录交易。PBFT通过确保即使在部分节点存在恶意行为的情况下，系统也能达成一致性，从而在分布式系统中实现了拜占庭容错。它通过多个阶段的投票和确认过程来确保交易的有效性和顺序。SCP则是另一种方法，它通过允许参与者选择信任的节点集合来达成共识，增加了系统的灵活性。dBFT则是PBFT的一个变体，它通过委托给专业节点来记录交易，旨在提高效率和可扩展性。这些共识算法都旨在解决分布式系统中的信任问题，并确保网络的稳定运行。</p><p><img src="/loadingPostImg.gif" data-original="webp.webp" alt="img"></p><ul><li><strong>Request：</strong>请求端C发送请求到任意一节点，这里是0；</li><li><strong>Pre-Prepare：</strong>服务端0收到C的请求后进行广播，扩散至123；</li><li><strong>Prepare：</strong>123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播； </li><li><strong>Commit：</strong>0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求； </li><li><strong>Reply：</strong>0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明节点信息,代表各个小国家</span></span><br><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//标示</span></span><br><span class="line">    id <span class="type">string</span></span><br><span class="line">    <span class="comment">//准备访问的方法</span></span><br><span class="line">    path <span class="type">string</span></span><br><span class="line">    <span class="comment">//服务器做出的相应</span></span><br><span class="line">    writer http.ResponseWriter</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放四个国家的地址</span></span><br><span class="line"><span class="keyword">var</span> nodeTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//拜占庭在Fabric中的使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取执行的参数</span></span><br><span class="line">    userId :=os.Args[<span class="number">1</span>]<span class="comment">//获取执行的第一个参数</span></span><br><span class="line">    fmt.Println(userId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//./main Apple</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建四个国家的地址</span></span><br><span class="line">    nodeTable = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">        <span class="string">&quot;Apple&quot;</span>:<span class="string">&quot;localhost:1111&quot;</span>,</span><br><span class="line">        <span class="string">&quot;MS&quot;</span>:<span class="string">&quot;localhost:1112&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Google&quot;</span>:<span class="string">&quot;localhost:1113&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IBM&quot;</span>:<span class="string">&quot;localhost:1114&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node:=nodeInfo&#123;userId,nodeTable[userId],<span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http协议的回调函数</span></span><br><span class="line">    <span class="comment">//http://localhost:1111/req?warTime=8888</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/req&quot;</span>,node.request)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/prePrepare&quot;</span>,node.prePrepare)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/prepare&quot;</span>,node.prepare)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/commit&quot;</span>,node.commit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> err:=http.ListenAndServe(node.path,<span class="literal">nil</span>);err!=<span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Print(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数是http访问时候req命令的请求回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>request(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line">    <span class="comment">//设置允许解析参数</span></span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//如果有参数值，则继续处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(request.Form[<span class="string">&quot;warTime&quot;</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        node.writer = writer</span><br><span class="line">        <span class="comment">//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">&quot;warTime&quot;</span>][<span class="number">0</span>],<span class="string">&quot;/prePrepare&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由主节点向其他节点做广播</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>broadcast(msg <span class="type">string</span> ,path <span class="type">string</span> )&#123;</span><br><span class="line">    <span class="comment">//遍历所有的国家</span></span><br><span class="line">    <span class="keyword">for</span> nodeId,url:=<span class="keyword">range</span> nodeTable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodeId == node.id &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用Get请求</span></span><br><span class="line">        <span class="comment">//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</span></span><br><span class="line">        http.Get(<span class="string">&quot;http://&quot;</span>+url+path+<span class="string">&quot;?warTime=&quot;</span>+msg+<span class="string">&quot;&amp;nodeId=&quot;</span>+node.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//fmt.Println(&quot;hello world&quot;)</span></span><br><span class="line">    <span class="comment">//在做分发</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(request.Form[<span class="string">&quot;warTime&quot;</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//分发给其他三个人</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">&quot;warTime&quot;</span>][<span class="number">0</span>],<span class="string">&quot;/prepare&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>prepare(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//调用验证</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">&quot;warTime&quot;</span>])&gt;<span class="number">0</span>&#123;</span><br><span class="line">        fmt.Println(request.Form[<span class="string">&quot;warTime&quot;</span>][<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">&quot;nodeId&quot;</span>])&gt;<span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(request.Form[<span class="string">&quot;nodeId&quot;</span>][<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.authentication(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authenticationsuccess = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> authenticationMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//获得除了本节点外的其他节点数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>authentication(request *http.Request) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    request.ParseForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> authenticationsuccess!=<span class="literal">false</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">&quot;nodeId&quot;</span>])&gt;<span class="number">0</span> &#123;</span><br><span class="line">            authenticationMap[request.Form[<span class="string">&quot;nodeId&quot;</span>][<span class="number">0</span>]]=<span class="string">&quot;ok&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(authenticationMap)&gt;<span class="built_in">len</span>(nodeTable)/<span class="number">3</span> &#123;</span><br><span class="line">        <span class="comment">//则拜占庭原理实现,通过commit反馈给浏览器</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">&quot;warTime&quot;</span>][<span class="number">0</span>],<span class="string">&quot;/commit&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span></span>commit(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给浏览器反馈相应</span></span><br><span class="line">    io.WriteString(node.writer,<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Ripple"><a href="#2-5-Ripple" class="headerlink" title="2.5 Ripple"></a>2.5 Ripple</h3><p>Ripple共识算法是一种在较大网络内利用集体信任的子网络的共识机制。在这个网络中，节点被分为两种类型：参与共识过程的服务器节点和仅用于资金转移的客户节点。每个服务器节点都有一个独特的节点列表（Unique Node List, UNL）。UNL对服务器节点来说非常重要。当决定是否将交易放入账本时，服务器节点会查询UNL中的节点，如果收到的协议达到80%，则交易将被打包进账本。对于一个节点来说，只要UNL中故障节点的百分比低于20%，账本就会保持正确。</p><p>Ripple共识算法的核心在于信任的构建和维护。服务器节点通过UNL来确定信任的节点集合，并依赖这些节点来达成共识。这种机制允许网络在保持去中心化的同时，实现快速的交易确认和账本更新。Ripple的这种方法强调了网络中节点间信任关系的重要性，并利用这种信任关系来维护整个网络的一致性和安全性。</p><h3 id="2-6-Tendermint"><a href="#2-6-Tendermint" class="headerlink" title="2.6 Tendermint"></a>2.6 Tendermint</h3><p>Tendermint是一种拜占庭容错共识算法。新区块的确定是在一轮中完成的。在这一轮中，会选出一个提议者（proposer），由其广播一个未确认的区块。Tendermint的共识过程可以被划分为三个步骤：</p><ul><li><p><strong>预投票（Prevote）</strong>：验证者选择是否为提议的区块广播一个预投票（prevote）。</p></li><li><p><strong>预提交（Precommit）</strong>：如果节点收到了提议区块超过2/3的预投票，它会为该区块广播一个预提交（precommit）。如果节点收到了超过2/3的预提交，它将进入提交步骤。</p></li><li><p><strong>提交（Commit）</strong>：节点验证区块，并为该区块广播一个提交（commit）。如果节点收到了2/3的提交，它将接受该区块。</p></li></ul><p>与PBFT（实用拜占庭容错）相比，Tendermint要求节点锁定他们的代币以成为验证者。一旦验证者被发现有不诚实行为，它将受到惩罚。</p><p>Tendermint共识算法通过锁定代币的方式，增加了验证者作弊的成本，从而提高了网络的安全性。验证者在预投票和预提交阶段必须做出决策，并且只有在获得足够多的其他验证者的支持时，才会进入提交阶段。这种机制确保了即使在存在拜占庭节点（即恶意或故障节点）的情况下，网络也能达成一致性，并继续运作。Tendermint因其高效性和安全性，被许多区块链项目采用作为其共识机制。</p><h2 id="3-算法比较"><a href="#3-算法比较" class="headerlink" title="3 算法比较"></a>3 算法比较</h2><div class="table-container"><table><thead><tr><th>算法</th><th style="text-align:center">PoW</th><th style="text-align:center">PoS</th><th style="text-align:center">DPOS</th><th style="text-align:center">PBFT</th><th style="text-align:center">Ripple</th><th style="text-align:center">Tendermint</th></tr></thead><tbody><tr><td>节点身份管理</td><td style="text-align:center">open</td><td style="text-align:center">open</td><td style="text-align:center">open</td><td style="text-align:center">permissioned</td><td style="text-align:center">open</td><td style="text-align:center">permissioned</td></tr><tr><td>节能</td><td style="text-align:center">no</td><td style="text-align:center">partial</td><td style="text-align:center">partial</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td>敌手容忍能力</td><td style="text-align:center">&lt; 25% computing power</td><td style="text-align:center">&lt; 51% stake</td><td style="text-align:center">&lt; 51% validators</td><td style="text-align:center">&lt; 33.3% faulty replicas</td><td style="text-align:center">&lt; 20% faulty nodes in UNL</td><td style="text-align:center">&lt; 33.3% byzantine voting power</td></tr><tr><td>实例</td><td style="text-align:center">Bitcoin</td><td style="text-align:center">Peercoin</td><td style="text-align:center">BitShares</td><td style="text-align:center">Hyperledger Fabric</td><td style="text-align:center">Ripple</td><td style="text-align:center">Tendermint</td></tr></tbody></table></div><p>PBFT和Tendermint 是许可协议，节点身份预计为整个网络所知，因此它们可能用于商业模式而不是公共模式。 PoW和PoS都适合公有链。联盟链或私有链可能会偏好PBFT、Tendermint、DPOS和Ripple。</p><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><p>[1]Wang W, Hoang D T, Hu P, 等. A Survey on Consensus Mechanisms and Mining Strategy Management in Blockchain Networks[J]. IEEE Access, 2019, 7: 22328-22370. doi: <a href="https://doi.org/10.1109/ACCESS.2019.2896108">10.1109/ACCESS.2019.2896108</a>.</p><p>[2]C. Decker, J. Seidel, and R. Wattenhofer, “Bitcoin meets strong consistency,” in Proceedings of the 17th International Conference on Distributed Computing and Networking (ICDCN). Singapore, Singapore: ACM, 2016, p. 13.</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ML作业4</title>
      <link href="/2023/12/09/ML4/"/>
      <url>/2023/12/09/ML4/</url>
      
        <content type="html"><![CDATA[<p><img src="/loadingPostImg.gif" data-original="image-20231209185804468.png" alt="image-20231209185804468"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置显示中文字体</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line"><span class="comment"># 设置正常显示符号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (1)</span></span><br><span class="line"><span class="comment"># 生成训练数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">x_train = np.sort(np.random.rand(<span class="number">10</span>))</span><br><span class="line">y_train = np.sin(<span class="number">2</span> * np.pi * x_train) + np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.scatter(x_train, y_train, label=<span class="string">&#x27;训练数据&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;生成的训练数据&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="Figure_1.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="image-20231209185816928.png" alt="image-20231209185816928"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (2)</span></span><br><span class="line"><span class="comment"># 定义最小二乘目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">least_squares</span>(<span class="params">x, w, t, sigma2</span>):</span><br><span class="line">    y = np.dot(x, w)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> / sigma2 * np.<span class="built_in">sum</span>((t - y)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式曲线拟合模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_model</span>(<span class="params">x, w</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(x, w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stochastic_gradient_descent</span>(<span class="params">x, t, w_init, learning_rate, epochs, mini_batch_size, sigma2</span>):</span><br><span class="line">    w = w_init</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        indices = np.random.permutation(<span class="built_in">len</span>(x))</span><br><span class="line">        <span class="keyword">for</span> batch_start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x), mini_batch_size):</span><br><span class="line">            batch_indices = indices[batch_start:batch_start+mini_batch_size]</span><br><span class="line">            x_batch = x[batch_indices]</span><br><span class="line">            y_batch = t[batch_indices]</span><br><span class="line">            gradient = compute_gradient(x_batch, w, y_batch, sigma2)</span><br><span class="line">            w = w - learning_rate * gradient</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算梯度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_gradient</span>(<span class="params">x, w, t, sigma2</span>):</span><br><span class="line">    y = polynomial_model(x, w)</span><br><span class="line">    error = y - t</span><br><span class="line">    gradient = <span class="number">1.0</span> / sigma2 * np.dot(x.T, error)</span><br><span class="line">    <span class="keyword">return</span> gradient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成多项式特征矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_polynomial_features</span>(<span class="params">x, M</span>):</span><br><span class="line">    <span class="keyword">return</span> np.column_stack([x**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方差</span></span><br><span class="line">sigma2 = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整学习率、miniBatch大小等参数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line">mini_batch_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择不同的多项式阶数进行训练</span></span><br><span class="line">plt.plot(x_train, y_train, <span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;训练数据&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    x_poly = generate_polynomial_features(x_train, M)</span><br><span class="line">    w_init = np.zeros(M+<span class="number">1</span>)  <span class="comment"># 使用非常小的随机元素进行初始化</span></span><br><span class="line">    w_optimal = stochastic_gradient_descent(x_poly, y_train, w_init, learning_rate, epochs, mini_batch_size, sigma2)</span><br><span class="line">    <span class="comment"># 绘制回归函数</span></span><br><span class="line">    x_range = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    y_range = polynomial_model(generate_polynomial_features(x_range, M), w_optimal)</span><br><span class="line">    plt.plot(x_range, y_range, label=<span class="string">f&#x27;M=<span class="subst">&#123;M&#125;</span>&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;不同阶数的多项式曲线拟合模型&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="Figure_2.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="image-20231209185831289.png" alt="image-20231209185831289"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (3)</span></span><br><span class="line"><span class="comment"># 生成测试数据集</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">x_test = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">y_test = np.sin(<span class="number">2</span> * np.pi * x_test) + np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同M值下的训练误差和测试误差</span></span><br><span class="line">train_errors = []</span><br><span class="line">test_errors = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    x_poly_train = generate_polynomial_features(x_train, M)</span><br><span class="line">    x_poly_test = generate_polynomial_features(x_test, M)</span><br><span class="line">    </span><br><span class="line">    w_init = np.zeros(M+<span class="number">1</span>)</span><br><span class="line">    w_optimal = stochastic_gradient_descent(x_poly_train, y_train, w_init, learning_rate, epochs, mini_batch_size, sigma2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算训练误差</span></span><br><span class="line">    y_train_pred = polynomial_model(x_poly_train, w_optimal)</span><br><span class="line">    train_error = np.sqrt(mean_squared_error(y_train, y_train_pred))</span><br><span class="line">    train_errors.append(train_error)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算测试误差</span></span><br><span class="line">    y_test_pred = polynomial_model(x_poly_test, w_optimal)</span><br><span class="line">    test_error = np.sqrt(mean_squared_error(y_test, y_test_pred))</span><br><span class="line">    test_errors.append(test_error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差与测试误差曲线</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">11</span>), train_errors, label=<span class="string">&#x27;训练误差&#x27;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">11</span>), test_errors, label=<span class="string">&#x27;测试误差&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;训练误差与测试误差曲线&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;多项式阶数 (M)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;均方根误差&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="Figure_3.png" alt=""></p><p>通过训练误差与测试误差曲线的比较，可以观察模型在不同多项式阶数下的性能表现。</p><ul><li>当多项式阶数较小时，模型欠拟合，导致训练误差和测试误差都较高。</li><li>随着多项式阶数的增加，模型的复杂度提高，训练误差逐渐减小。但是注意到多项式阶数大于6或7后误差开始增大，说明模型出现了过拟合现象。</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231209185845503.png" alt="image-20231209185845503"></p><p>第二次作业中的结果：</p><p><img src="/loadingPostImg.gif" data-original="Figure_1.3.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="Figure_1.4.png" alt=""></p><p>第二次作业的结果在多项式阶数大于6后显然出现了严重的过拟合现象。然而这里利用随机梯度下降方法(SGD)，调整 miniBatch 的大小、学习速率参数以及参数初始化为0或非常小的随机元素训练的多项式曲线拟合模型没有出现严重的过拟合现象，可能有如下几点原因。</p><ul><li>SGD在梯度更新时引入了随机性，可以视为一种正则化的形式，有助于缓解过拟合。</li><li>SGD可以使用更小的学习率，每次更新基于小批量的数据，可以减少模型参数在训练中的波动，有助于缓解过拟合。</li><li>使用非常小的随机元素对参数初始化有助于避免模型陷入局部最小值。对于较大的多项式阶数，初始化参数为0可能导致模型在训练开始时就收敛到一个不良局部最小值，而随机初始化则有助于破坏对称性。</li><li>调整miniBatch的大小可以视为正则化，引入噪声从而对梯度进行不准确的估计。</li></ul><p>因此这里的SGD方法在适当调整参数后，相比第二次作业使用的<code>LinearRegression</code>模型在处理高阶多项式时具有更好的鲁棒性。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ML作业3</title>
      <link href="/2023/11/28/ML3/"/>
      <url>/2023/11/28/ML3/</url>
      
        <content type="html"><![CDATA[<p><img src="/loadingPostImg.gif" data-original="image-20231126215942272.png" alt="1"></p><p>Logistic回归的假设函数为</p><script type="math/tex; mode=display">h_\theta(x) = \frac{1}{1 + e^{-\theta^Tx}}</script><p>交叉熵代价函数为</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{m} \sum_{i=1}^{m} [y^{(i)}\log(h_\theta(x^{(i)})) + (1 - y^{(i)})\log(1 - h_\theta(x^{(i)}))]</script><p>计算梯度需要用到Sigmoid函数的性质</p><script type="math/tex; mode=display">g^{\prime}(z) = g(z)(1 - g(z))</script><ul><li><p>梯度下降法</p><p>$\theta_{j}$更新</p><script type="math/tex; mode=display"> \theta_j := \theta_j - \alpha \frac{\partial J(\theta)}{\partial \theta_j}</script><p>计算梯度</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta_j} = \frac{1}{m} \sum_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}</script></li><li><p>随机梯度下降法</p><p>随机梯度下降法在每次更新时随机选择样本进行梯度下降</p><p>$\theta_{j}$更新</p><script type="math/tex; mode=display">\theta_j := \theta_j - \alpha (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}</script></li><li><p>牛顿法</p><p>计算梯度</p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \frac{1}{m} X^T(h_\theta(X) - y)</script><p>计算黑塞矩阵</p><script type="math/tex; mode=display">H = \frac{1}{m} X^T R X</script><p>$X$是特征矩阵，行向量是训练样本的特征向量。$R$是对角矩阵，$R_{ii} = h_\theta(x^{(i)})(1 - h_\theta(x^{(i)}))$。</p><p>$\theta$更新</p><script type="math/tex; mode=display">\theta := \theta - H^{-1} \nabla_\theta J(\theta)</script></li><li><p>“随机”牛顿法</p><p>学习随机梯度下降法的思想，每次更新时随机选择一部分样本进行梯度下降，而不是全部。</p><script type="math/tex; mode=display">\theta := \theta - (H^{-1} \nabla_\theta J(\theta))^{i}</script></li></ul><hr><p><img src="/loadingPostImg.gif" data-original="image-20231126231622069.png" alt="2"></p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><ul><li><code>learning_rate = 0.01</code></li><li><code>epochs = 10000</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置显示中文字体</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line"><span class="comment"># 设置正常显示符号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载鸢尾花数据集</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 仅使用前两个特征，方便可视化</span></span><br><span class="line">y = (iris.target != <span class="number">0</span>) * <span class="number">1</span>  <span class="comment"># 二元分类问题，将标签转换为0和1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.4</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 特征标准化</span></span><br><span class="line"><span class="comment"># scaler = StandardScaler()</span></span><br><span class="line"><span class="comment"># X_train = scaler.fit_transform(X_train)</span></span><br><span class="line"><span class="comment"># X_test = scaler.transform(X_test)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加偏置项</span></span><br><span class="line">X_train = np.c_[np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>)), X_train]</span><br><span class="line">X_test = np.c_[np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>)), X_test]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line">theta = np.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义逻辑斯蒂函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义代价函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_loss</span>(<span class="params">X, y, theta</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    h = sigmoid(X.dot(theta))</span><br><span class="line">    loss = -<span class="number">1</span>/m * (y.dot(np.log(h)) + (<span class="number">1</span> - y).dot(np.log(<span class="number">1</span> - h)))</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">X, y, theta, learning_rate, epochs</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    loss_history = []</span><br><span class="line">    error_history_train = []</span><br><span class="line">    error_history_test = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        h = sigmoid(X.dot(theta))</span><br><span class="line">        gradient = X.T.dot(h - y) / m</span><br><span class="line">        theta -= learning_rate * gradient</span><br><span class="line">        loss = compute_loss(X, y, theta)</span><br><span class="line">        loss_history.append(loss)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算训练集和测试集的分类错误率</span></span><br><span class="line">        train_predictions = (sigmoid(X_train.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        test_predictions = (sigmoid(X_test.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        error_train = <span class="number">1</span> - accuracy_score(y_train, train_predictions)</span><br><span class="line">        error_test = <span class="number">1</span> - accuracy_score(y_test, test_predictions)</span><br><span class="line">        error_history_train.append(error_train)</span><br><span class="line">        error_history_test.append(error_test)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta, loss_history, error_history_train, error_history_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10000</span></span><br><span class="line">theta, loss_history, error_history_train, error_history_test = gradient_descent(X_train, y_train, theta, learning_rate, epochs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出训练集上的损失函数随训练回合数的变化曲线</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, epochs+<span class="number">1</span>), loss_history)</span><br><span class="line">plt.title(<span class="string">&#x27;代价函数随训练回合数的变化曲线&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;代价函数&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出模型在训练集和测试集上的分类错误率随训练回合数的变化曲线</span></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, epochs+<span class="number">1</span>), error_history_train, label=<span class="string">&#x27;Training Error&#x27;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, epochs+<span class="number">1</span>), error_history_test, label=<span class="string">&#x27;Testing Error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;分类错误率随训练回合数的变化曲线&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;错误率&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化训练数据和测试数据</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 可视化训练数据</span></span><br><span class="line">plt.figure(<span class="number">3</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">0</span>][:, <span class="number">1</span>], X_train[y_train == <span class="number">0</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;setosa&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">1</span>][:, <span class="number">1</span>], X_train[y_train == <span class="number">1</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;versicolor&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;训练集&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># 可视化测试数据</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.scatter(X_test[y_test == <span class="number">0</span>][:, <span class="number">1</span>], X_test[y_test == <span class="number">0</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;setosa&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.scatter(X_test[y_test == <span class="number">1</span>][:, <span class="number">1</span>], X_test[y_test == <span class="number">1</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;versicolor&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;测试集&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在数据集的可视化图中显示决策边界</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.figure(<span class="number">4</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">0</span>][:, <span class="number">1</span>], X_train[y_train == <span class="number">0</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;setosa&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">1</span>][:, <span class="number">1</span>], X_train[y_train == <span class="number">1</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;versicolor&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;训练集决策边界&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">x_boundary = np.linspace(X_train[:, <span class="number">1</span>].<span class="built_in">min</span>(), X_train[:, <span class="number">1</span>].<span class="built_in">max</span>(), <span class="number">100</span>)</span><br><span class="line">y_boundary = -(theta[<span class="number">0</span>] + theta[<span class="number">1</span>] * x_boundary) / theta[<span class="number">2</span>]</span><br><span class="line">plt.plot(x_boundary, y_boundary, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;决策边界&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.scatter(X_test[y_test == <span class="number">0</span>][:, <span class="number">1</span>], X_test[y_test == <span class="number">0</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;setosa&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.scatter(X_test[y_test == <span class="number">1</span>][:, <span class="number">1</span>], X_test[y_test == <span class="number">1</span>][:, <span class="number">2</span>], label=<span class="string">&#x27;versicolor&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;测试集决策边界&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花萼长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花萼宽度&#x27;</span>)</span><br><span class="line">x_boundary = np.linspace(X_train[:, <span class="number">1</span>].<span class="built_in">min</span>(), X_train[:, <span class="number">1</span>].<span class="built_in">max</span>(), <span class="number">100</span>)</span><br><span class="line">y_boundary = -(theta[<span class="number">0</span>] + theta[<span class="number">1</span>] * x_boundary) / theta[<span class="number">2</span>]</span><br><span class="line">plt.plot(x_boundary, y_boundary, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;决策边界&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="GD_1.png" alt="1"></p><p><img src="/loadingPostImg.gif" data-original="GD_2.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="GD_3.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="GD_4.png" alt=""></p><h3 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h3><ul><li><code>learning_rate = 0.01</code></li><li><code>epochs = 500</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stochastic_gradient_descent</span>(<span class="params">X, y, theta, learning_rate, epochs</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    loss_history = []</span><br><span class="line">    error_history_train = []</span><br><span class="line">    error_history_test = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            rand_index = np.random.randint(<span class="number">0</span>, m)</span><br><span class="line">            X_i = X[rand_index, :].reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">            y_i = y[rand_index]</span><br><span class="line"></span><br><span class="line">            h = sigmoid(X_i.dot(theta))</span><br><span class="line">            gradient = X_i.T.dot(h - y_i)</span><br><span class="line">            theta -= learning_rate * gradient</span><br><span class="line">        loss = compute_loss(X, y, theta)</span><br><span class="line">        loss_history.append(loss)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算训练集和测试集的分类错误率</span></span><br><span class="line">        train_predictions = (sigmoid(X_train.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        test_predictions = (sigmoid(X_test.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        error_train = <span class="number">1</span> - accuracy_score(y_train, train_predictions)</span><br><span class="line">        error_test = <span class="number">1</span> - accuracy_score(y_test, test_predictions)</span><br><span class="line">        error_history_train.append(error_train)</span><br><span class="line">        error_history_test.append(error_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta, loss_history, error_history_train, error_history_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">500</span></span><br><span class="line">theta, loss_history, error_history_train, error_history_test = stochastic_gradient_descent(X_train, y_train, theta, learning_rate, epochs)</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="SGD_1.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SGD_2.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SGD_3.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SGD_4.png" alt=""></p><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><ul><li><code>epochs = 20</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛顿法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Newton</span>(<span class="params">X, y, theta, epochs</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    loss_history = []</span><br><span class="line">    error_history_train = []</span><br><span class="line">    error_history_test = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        h = sigmoid(X.dot(theta))</span><br><span class="line">        gradient = X.T.dot(h - y) / m</span><br><span class="line">        hessian = X.T.dot(np.diag(h * (<span class="number">1</span> - h))).dot(X) / m</span><br><span class="line">        theta -= np.linalg.inv(hessian).dot(gradient)</span><br><span class="line">        loss = compute_loss(X, y, theta)</span><br><span class="line">        loss_history.append(loss)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算训练集和测试集的分类错误率</span></span><br><span class="line">        train_predictions = (sigmoid(X_train.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        test_predictions = (sigmoid(X_test.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        error_train = <span class="number">1</span> - accuracy_score(y_train, train_predictions)</span><br><span class="line">        error_test = <span class="number">1</span> - accuracy_score(y_test, test_predictions)</span><br><span class="line">        error_history_train.append(error_train)</span><br><span class="line">        error_history_test.append(error_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta, loss_history, error_history_train, error_history_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">epochs = <span class="number">20</span></span><br><span class="line">theta, loss_history, error_history_train, error_history_test = Newton(X_train, y_train, theta, epochs)</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="N_1.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="N_2.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="N_3.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="N_4.png" alt=""></p><h3 id="“随机”牛顿法"><a href="#“随机”牛顿法" class="headerlink" title="“随机”牛顿法"></a>“随机”牛顿法</h3><ul><li><code>epochs = 50</code></li><li><code>batch_size = 2</code></li><li><code>regularization_lambda = 0.1</code></li><li><code>initial_learning_rate = 0.5</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义逻辑斯蒂函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">z</span>):</span><br><span class="line">    clipped_z = np.clip(z, -<span class="number">500</span>, <span class="number">500</span>)  <span class="comment"># 截断输入，避免指数溢出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-clipped_z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义代价函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_loss</span>(<span class="params">X, y, theta, regularization_lambda</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    h = sigmoid(X.dot(theta))</span><br><span class="line">    loss = -<span class="number">1</span>/m * (y.dot(np.log(sigmoid(h))) + (<span class="number">1</span> - y).dot(np.log(<span class="number">1</span> - sigmoid(h)))) + (regularization_lambda / (<span class="number">2</span> * m)) * np.<span class="built_in">sum</span>(theta[<span class="number">1</span>:]**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机牛顿法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">StochasticNewton</span>(<span class="params">X, y, theta, epochs, batch_size, regularization_lambda, initial_learning_rate</span>):</span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    loss_history = []</span><br><span class="line">    error_history_train = []</span><br><span class="line">    error_history_test = []</span><br><span class="line">    learning_rate = initial_learning_rate  <span class="comment"># 初始学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m, batch_size):</span><br><span class="line">            indices = np.random.choice(m, batch_size, replace=<span class="literal">False</span>)</span><br><span class="line">            X_batch = X[indices, :]</span><br><span class="line">            y_batch = y[indices]</span><br><span class="line"></span><br><span class="line">            h = sigmoid(X_batch.dot(theta))</span><br><span class="line">            gradient = X_batch.T.dot(h - y_batch) / batch_size</span><br><span class="line">            hessian = X_batch.T.dot(np.diag(h * (<span class="number">1</span> - h))).dot(X_batch) / batch_size</span><br><span class="line">            regularization_term = regularization_lambda * np.eye(theta.shape[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 数值稳定性改进</span></span><br><span class="line">            theta -= np.linalg.pinv(hessian + regularization_term).dot(gradient) * learning_rate</span><br><span class="line"></span><br><span class="line">        loss = compute_loss(X, y, theta, regularization_lambda)</span><br><span class="line">        loss_history.append(loss)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算训练集和测试集的分类错误率</span></span><br><span class="line">        train_predictions = (sigmoid(X_train.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        test_predictions = (sigmoid(X_test.dot(theta)) &gt;= <span class="number">0.5</span>) * <span class="number">1</span></span><br><span class="line">        error_train = <span class="number">1</span> - accuracy_score(y_train, train_predictions)</span><br><span class="line">        error_test = <span class="number">1</span> - accuracy_score(y_test, test_predictions)</span><br><span class="line">        error_history_train.append(error_train)</span><br><span class="line">        error_history_test.append(error_test)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 衰减学习率</span></span><br><span class="line">        learning_rate /= (<span class="number">1</span> + epoch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta, loss_history, error_history_train, error_history_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型（带正则化项和学习率衰减）</span></span><br><span class="line">epochs = <span class="number">50</span></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">regularization_lambda = <span class="number">0.1</span></span><br><span class="line">initial_learning_rate = <span class="number">0.5</span></span><br><span class="line">theta, loss_history, error_history_train, error_history_test = StochasticNewton(</span><br><span class="line">    X_train, y_train, theta, epochs, batch_size, regularization_lambda, initial_learning_rate</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="SN_1.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SN_2.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SN_3.png" alt=""></p><p><img src="/loadingPostImg.gif" data-original="SN_4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matrix theory</title>
      <link href="/2023/11/26/JZ/"/>
      <url>/2023/11/26/JZ/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Matrix-theory"><a href="#1-Matrix-theory" class="headerlink" title="1 Matrix theory"></a>1 Matrix theory</h2><h3 id="1-1-SVD"><a href="#1-1-SVD" class="headerlink" title="1.1 SVD"></a>1.1 SVD</h3><p>奇异值分解(Singular Value Decomposition,SVD)是在机器学习领域广泛应用的算法，它不光可以用于降维算法中的特征分解，还可以用于推荐系统，以及自然语言处理等领域。</p><h4 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h4><p>和特征分解不同，SVD并不要求要分解的矩阵为方阵。矩阵$\mathbf{X}$是一个$m \times n$的矩阵，$\mathbf{X}$的SVD为</p><script type="math/tex; mode=display">\mathbf{X} = \mathbf{U}\mathbf{\Sigma}\mathbf{V}^T</script><p>$\mathbf{U}$是$m \times m$的酉矩阵（左奇异矩阵），$\mathbf{V}$是$n \times n$的酉矩阵（右奇异矩阵），有$\mathbf{U}^{T}\mathbf{U} = \mathbf{I}$，$\mathbf{V}^{T}\mathbf{V} = \mathbf{I}$。</p><p>$\mathbf{\Sigma}$是$m \times n$的对角矩阵（奇异值矩阵），对角元素是$\mathbf{X}$的奇异值。</p><p>$\mathbf{U}$中的每个特征向量叫做$\mathbf{X}$的左奇异向量。$\mathbf{V}$中的每个特征向量叫做$\mathbf{X}$的右奇异向量。</p><h4 id="1-1-2-信息压缩"><a href="#1-1-2-信息压缩" class="headerlink" title="1.1.2 信息压缩"></a>1.1.2 信息压缩</h4><p>在奇异值矩阵中奇异值按照从大到小排列，而且奇异值的减少特别的快。在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上的比例。</p><p>因此，可以用最大的$k$个的奇异值和对应的左右奇异向量来近似描述矩阵，从而达到信息压缩的目的。</p><script type="math/tex; mode=display">\mathbf{X}\approx\mathbf{X}_k=\mathbf{U}_k\mathbf{\Sigma}_k\mathbf{V}_k^T</script><p>可以通过</p><script type="math/tex; mode=display">\|\mathbf{X}-\mathbf{X}_k\|_F\leq\sqrt{\sum_{i=k+1}^r\sigma_i^2}</script><p>来保证$\mathbf{X}$和$\mathbf{X}_k$的近似程度。$\| \cdot \|_{F}$是矩阵的$F$范数，$r$是$\mathbf{X}$的秩，$\sigma_i$是$\mathbf{X}$的第$i$个奇异值。</p><p>信息压缩的思想在图像、音频和视频压缩等方向都有应用。</p><h4 id="1-1-3-应用"><a href="#1-1-3-应用" class="headerlink" title="1.1.3 应用"></a>1.1.3 应用</h4><p>PCA降维需要找到样本协方差矩阵$\mathbf{X}^{T}\mathbf{X}$的最大的$d$个特征向量，然后用这最大的$d$个特征向量张成的矩阵来做低维投影降维。可以看出，在这个过程中需要先求出协方差矩阵 $\mathbf{X}^{T}\mathbf{X}$，当样本数和特征数较多时，计算量非常大。而一些SVD的实现算法可以不先求出$\mathbf{X}^{T}\mathbf{X}$也能求出右奇异矩阵$\mathbf{V}$。即可以不做特征分解而是通过SVD来实现PCA。</p><p>左奇异矩阵可以用于行数的压缩，右奇异矩阵可以用于列数即特征维度的压缩，也就是PCA降维。</p><h3 id="1-2-稀疏矩阵"><a href="#1-2-稀疏矩阵" class="headerlink" title="1.2 稀疏矩阵"></a>1.2 稀疏矩阵</h3><p>在深度学习领域矩阵是一种存储数据的常用方式。但在实际应用中矩阵往往较大且非零元素较少，这时如果对矩阵执行操作，会有大部分的内存资源和计算资源浪费在分配32或64位的零值或是将他们相加相乘上。这对于算法的空间复杂度和时间复杂度来说都是非常不利的，而且这种浪费会随着矩阵的增大或稀疏性变小持续增加。</p><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p>稀疏矩阵是绝大多数元素都为0的矩阵。</p><p>维基百科中有如下介绍：</p><blockquote><p><strong>稀疏矩阵(sparse matrix)</strong>，在数值分析中，是其元素大部分为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是<strong>稠密(dense)</strong>的。在科学与工程领域中求解线性模型时经常出现大型的稀疏矩阵。</p><p>在使用计算机存储和操作稀疏矩阵时，经常需要修改标准算法以利用矩阵的稀疏结构。由于其自身的稀疏特性，通过压缩可以大大节省稀疏矩阵的内存代价。更为重要的是，由于过大的尺寸，标准的算法经常无法操作这些稀疏矩阵。</p></blockquote><p>非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。可以量化矩阵的稀疏性。</p><h4 id="1-2-2-存储"><a href="#1-2-2-存储" class="headerlink" title="1.2.2 存储"></a>1.2.2 存储</h4><p>稀疏矩阵通常具有很高的维度，在存储时大量的零元素占据大部分内存。因此我们希望只存储矩阵中的非零元素值。为了存储非零元素值，需要同时存储坐标位置和元素值，以便恢复。</p><p>对稀疏矩阵的压缩存储就是在构造更为有效的数据结构。常见的有：</p><ul><li><p>支持高效访问、矩阵操作的<a href="#anchor1">CSR</a>、<a href="#anchor2">CSC</a></p></li><li><p>支持高效修改的<a href="#anchor3">DOK</a>、<a href="#anchor4">LIL</a>、<a href="#anchor5">COO</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</span><br><span class="line"><span class="built_in">help</span>(sparse)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Sparse Matrix Storage Formats</span></span><br><span class="line"><span class="string">There are seven available sparse matrix types:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        1. csc_matrix: Compressed Sparse Column format</span></span><br><span class="line"><span class="string">        2. csr_matrix: Compressed Sparse Row format</span></span><br><span class="line"><span class="string">        3. bsr_matrix: Block Sparse Row format</span></span><br><span class="line"><span class="string">        4. lil_matrix: List of Lists format</span></span><br><span class="line"><span class="string">        5. dok_matrix: Dictionary of Keys format</span></span><br><span class="line"><span class="string">        6. coo_matrix: COOrdinate format (aka IJV, triplet format)</span></span><br><span class="line"><span class="string">        7. dia_matrix: DIAgonal format</span></span><br><span class="line"><span class="string">        8. spmatrix: Sparse matrix base clas</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>SciPy库提供了七种可用的稀疏矩阵类型。</p><h5 id="CSR-压缩稀疏行矩阵"><a href="#CSR-压缩稀疏行矩阵" class="headerlink" title=" CSR 压缩稀疏行矩阵"></a><a name="anchor1"></a> CSR 压缩稀疏行矩阵</h5><ul><li><code>indices, indptr, data</code>确定矩阵</li><li>对于第 <code>i</code> 行而言，该行中非零元素的列索引为 <code>indices[indptr[i]:indptr[i+1]]</code></li><li><code>indptr[i] = indptr[i+1]</code>则该行没有非零元素</li><li>数据存放在： <code>data[indptr[i]:indptr[i+1]]</code></li></ul><p><img src="/loadingPostImg.gif" data-original="62c92320-23cb-11eb-b89e-32690a56e4fd [MConverter.eu].webp" alt="img"></p><h5 id="CSC-压缩稀疏列矩阵"><a href="#CSC-压缩稀疏列矩阵" class="headerlink" title="CSC 压缩稀疏列矩阵"></a><a name="anchor2"></a>CSC 压缩稀疏列矩阵</h5><ul><li>与CSR类似，但按列压缩矩阵</li></ul><p><img src="/loadingPostImg.gif" data-original="17ce6ebc-232f-11eb-8376-cadbb0a08063 [MConverter.eu].webp" alt="img"></p><h5 id="DOK-关键字字典矩阵"><a href="#DOK-关键字字典矩阵" class="headerlink" title="DOK 关键字字典矩阵"></a><a name="anchor3"></a>DOK 关键字字典矩阵</h5><ul><li>字典的 <code>key</code> 存的是记录元素的位置信息的元组， <code>value</code> 是记录元素的具体值</li></ul><h5 id="LIL-链表矩阵"><a href="#LIL-链表矩阵" class="headerlink" title="LIL 链表矩阵"></a><a name="anchor4"></a>LIL 链表矩阵</h5><ul><li><code>data</code>保存每行中的非零元素的值，<code>rows</code>保存每行非零元素所在的列</li></ul><p><img src="/loadingPostImg.gif" data-original="c7487c86-2355-11eb-bb7c-368fe856f9f2 [MConverter.eu].webp" alt="img"></p><h5 id="COO-坐标列表矩阵"><a href="#COO-坐标列表矩阵" class="headerlink" title="COO 坐标列表矩阵"></a><a name="anchor5"></a>COO 坐标列表矩阵</h5><ul><li>三元组<code>(row, col, data)</code>形式存储非零元素</li><li><code>coo[row[k]][col[k]] = data[k]</code></li></ul><p><img src="/loadingPostImg.gif" data-original="v2-0e24a642bfd95d61e5f0e8ce7b5b167c_b.webp" alt="img"></p><h4 id="1-2-3-应用"><a href="#1-2-3-应用" class="headerlink" title="1.2.3 应用"></a>1.2.3 应用</h4><p>以信道稀疏恢复问题为例。</p><ul><li>在通信系统中，信道稀疏恢复问题是指信号在信道传输过程中，由于时变、多径的影响，导致信号在接收端出现了噪声和失真。信号在传输过程中往往仅占据整体信号空间的一小部分，形成了稀疏性。因此，需要通过恢复算法准确地还原原始信号。</li><li>由于信号的稀疏性，可以将信道传输建模为一个稀疏矩阵。通过稀疏矩阵的方法，可以更准确地估计信道的状态，减小信道估计误差，提高恢复信号的准确性。</li></ul><h5 id="稀疏性利用-sparsity-exploitation-物理层的UWA-Underwater-Acoustic-传感器网络-1"><a href="#稀疏性利用-sparsity-exploitation-物理层的UWA-Underwater-Acoustic-传感器网络-1" class="headerlink" title="稀疏性利用(sparsity exploitation)物理层的UWA(Underwater Acoustic)传感器网络[1]"></a>稀疏性利用(sparsity exploitation)物理层的UWA(Underwater Acoustic)传感器网络<sup><a href="#a6">[1]</a></sup></h5><p>鉴于UWA信道固有的稀疏特性，压缩感知(CS)理论能够将UWA信道估计转化为稀疏恢复问题，从而提高性能。用于稀疏恢复的一种流行的经典CS算法是贪心算法，包括匹配追踪算法(MP)和正交匹配追踪(OMP)算法。然而，大多数CS算法都认为稀疏结构保持静止，即未考虑UWA信道的时变稀疏性。UWA信道的时变性会显著恶化信号矢量与所需原子（测量矩阵的列向量）之间的相关性，导致OMP算法的性能下降。</p><p>论文通过将信道估计问题表述为恢复具有时变支持的稀疏集，采用降阶卡尔曼滤波器(KF)来估计非零系数集，而支持的变化则通过运行CS来获得。</p><h6 id="CS信道估计"><a href="#CS信道估计" class="headerlink" title="CS信道估计"></a>CS信道估计</h6><p>稀疏恢复问题：</p><script type="math/tex; mode=display">{\underset{\mathbf{h}}\min \left \| \mathbf{h} \right \| _{1}} \text{ s.t. }\quad\mathbf{y} = \mathbf{A}\mathbf{h}</script><p>$\mathbf{y}$，$\mathbf{h}$和$\mathbf{A}$分别表示接收信号、时变UWA信道和测量矩阵。$\left \| \mathbf{h} \right \| _{1}$指$l_{1}$范式。</p><p>贪心算法广泛应用于解决UWA信道稀疏恢复问题。OMP算法实现简单、计算复杂度低，是一种典型的贪心算法。然而，OMP算法尚未考虑UWA信道的时变稀疏性，不足以产生理想的性能。</p><h6 id="DCS信道估计"><a href="#DCS信道估计" class="headerlink" title="DCS信道估计"></a>DCS信道估计</h6><p>将UWA信道表示为时变稀疏集，在DCS(Dynamic CS)框架下解决信道估计问题。</p><p>对于具有不同支持度的稀疏信号序列，KF-CS有如下重构思想。测量模型为</p><script type="math/tex; mode=display">\mathbf{y}_{t} =\mathbf{A}\mathbf{h}_{t} +  \mathbf{w}_{t},\mathbf{w}_{t}\sim CN\left ( 0,\sigma ^{2}_{obs} \mathbf{I}  \right )</script><p>$\mathbf{y}_{t}$，$\mathbf{h}_{t}$和$\mathbf{w}_{t}$是时刻$t$的接收信号、时变UWA信道和加性噪声。$\mathbf{A}\in C^{M\times N}$是测量矩阵，$M$和$N$分别是接收信号$\mathbf{y}_{t}$和脉冲响应$\mathbf{h}_{t}$的长度。$\sigma ^{2}_{obs}$是观测噪声的方差。$CN\left ( 0,\sigma ^{2}_{obs} \mathbf{I}  \right )$表示均值为$0$协方差矩阵为$\sigma ^{2}_{obs} \mathbf{I}$的复高斯向量。</p><p>KF-CS算法：</p><p>1）运行临时KF</p><script type="math/tex; mode=display">\begin{align} \mathbf{K}_{t,tmp} &= ( \mathbf{P}_{t−1} + \hat{\mathbf{Q}}_{t} ) \mathbf{A}^{\prime}( \mathbf{A} ( \mathbf{P}_{t} + \hat{\mathbf{Q}}_{t} ) \mathbf{A}^{\prime} + \sigma ^{2}_{obs}\mathbf{I} )^{-1}\\ \hat{\mathbf{h}}_{t,tmp} &= (\mathbf{I} − \mathbf{K}_{t,tmp}\mathbf{A}) \hat{\mathbf{h}}_{t-1} + \mathbf{K}_{t,tmp}\mathbf{y}_{t}.\end{align}</script><p>2）通过 CS 检测和估计增量，滤波误差为</p><script type="math/tex; mode=display">\tilde{\mathbf{y}}_{t,res} = \mathbf{y}_{t} − \mathbf{A} \hat{\mathbf{h}}_{t,tmp}</script><p>3）更新KF</p><script type="math/tex; mode=display">\begin{align} \mathbf{P}_{t \mid t-1} &= \left ( \mathbf{P}_{t-1} + \hat{\mathbf{Q}}_{t} \right ) \\\mathbf{K}_{t} &= \mathbf{P}_{t \mid t-1}A^{\prime}\left ( \mathbf{A}\mathbf{P}_{t \mid t-1}\mathbf{A}^{\prime} + \sigma ^{2}_{obs}\mathbf{I} \right )^{-1} \\\mathbf{P}_{t} &= \left ( \mathbf{I} - \mathbf{K}_{t}\mathbf{A} \right )\mathbf{P}_{t \mid t-1} \\\hat{\mathbf{h}}_{t} &=  \left ( \mathbf{I} - \mathbf{K}_{t}\mathbf{A} \right )\hat{\mathbf{h}}_{t-1} + \mathbf{K}_{t}y_{t}\end{align}</script><p>经过仿真，DCS信道估计驱动物理层的UWA传感器网络能获得更低的网络误码率输出、更高的网络吞吐量和更小的端到端延迟值。从网络性能上验证了经典稀疏性利用和动态稀疏性利用在提高UWA传感器网络性能方面的有效性。在时变信道条件下，物理层接收器对网络性能的影响在网络提供负载极高或极低时都很小。换句话说，在适当的网络负载范围内，具有动态稀疏性利用功能的接收器有助于改善存在时变信道时的网络性能。</p><h2 id="2-映射"><a href="#2-映射" class="headerlink" title="2 映射"></a>2 映射</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>设$S$、$S^{\prime}$是给定的两个<strong>非空集合</strong>，如果有一个对应法则$\sigma$，通过这个法则对于中的<strong>每一个元素</strong>$a$，都有$S^{‘}$中一个<strong>唯一确定的元素</strong>$a^{\prime}$与它对应，则称$\sigma$为$S$到$S^{\prime}$的一个映射，记作：$\sigma : S\to S^{\prime} $或$ S\overset{\sigma}\longrightarrow S^{\prime}$。称$a^{\prime}$为$a$在映射$\sigma$下的象，而$a^{\prime}$称为$a$在映射$\sigma$下的原象。</p><h3 id="2-2-为什么这样定义映射"><a href="#2-2-为什么这样定义映射" class="headerlink" title="2.2 为什么这样定义映射"></a>2.2 为什么这样定义映射</h3><p>映射是多对一的，意味着不同的元素可以映射到相同的元素，但在一个给定的映射中，对于每个原象，其映射到的象是唯一确定的。</p><p>映射的定义是为了描述和研究集合之间对应关系而引入的概念，是一种数学抽象，可以用来分析很多实际问题。</p><ul><li>映射可以表示函数关系：导数、积分、编程语言函数等</li><li>映射可以表示数据结构：数组、链表、哈希表等</li><li>映射可以表示变换关系：线性变换等</li></ul><p>映射的定义还可以进一步扩展。如集值映射、多值映射等。</p><ul><li>集值映射指映射的值域是一个集合而不仅仅是一个单一的元素。可以用来描述不确定性或多义性情况下，输入对应多个可能输出，输出形成一个集合的情况。</li><li>多值映射允许输入在值域中有多个对应的元素，即放宽唯一性的要求。与集值映射相似，多值映射也可以用来描述处理多义性多值性的问题。多值函数是多值映射的一种。<ul><li>多值函数可以描述系统的多分支性质。</li><li>复数域函数的多值性更为显著。在复分析时会经常遇到函数对于非零复数有多个值的情况。</li><li>信号处理中一些传输函数可能有多输入多输出。</li><li>通信网中使用图论方法分析时，在多重边情况下，节点之间的关系可以通过多值函数表示。</li></ul></li></ul><hr><p>参考资料：</p><p><a name="a6"></a>[1]WEIHUA JIANG, FENG TONG. Exploiting Sparsity for Underwater Acoustic Sensor Network Under Time-Varying Channels[J/OL]. IEEE Internet of Things Journal, 2022, 9(4): 2859-2869. DOI:<a href="https://doi.org/10.1109/JIOT.2021.3094818">10.1109/JIOT.2021.3094818</a>.</p><p><a href="https://zhuanlan.zhihu.com/p/29846048">奇异值分解（SVD） - 知乎 (zhihu.com)</a></p><p><a href="https://zh.wikipedia.org/wiki/稀疏矩阵">稀疏矩阵 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/188700729">Sparse稀疏矩阵主要存储格式总结 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/no_007/article/details/32428167">什么是映射？为什么需要映射_服务器上为什么会产生映射-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Networking:A Top-Down Approach 8th Edition</title>
      <link href="/2023/11/21/Computer%20Networking%EF%BC%9AA%20Top-Down%20Approach%208th%20Edition/"/>
      <url>/2023/11/21/Computer%20Networking%EF%BC%9AA%20Top-Down%20Approach%208th%20Edition/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Computer-Networks-and-the-Internet"><a href="#1-Computer-Networks-and-the-Internet" class="headerlink" title="1 Computer Networks and the Internet"></a>1 Computer Networks and the Internet</h1><h2 id="1-1-What-Is-the-Internet"><a href="#1-1-What-Is-the-Internet" class="headerlink" title="1.1 What Is the Internet?"></a>1.1 What Is the Internet?</h2><h3 id="1-1-1-A-Nuts-and-Bolts-Description"><a href="#1-1-1-A-Nuts-and-Bolts-Description" class="headerlink" title="1.1.1 A Nuts-and-Bolts Description"></a>1.1.1 A Nuts-and-Bolts Description</h3><p><img src="/loadingPostImg.gif" data-original="image-20231121230342695.png" alt="1"></p><p>互联网是一个计算机网络，将传统计算设备如台式电脑、Linux工作站和所谓的服务器互联起来。如今非传统互联网“物”也在连接到互联网。所有这些设备被称为主机(hosts)或终端系统(end systems)。</p><p>终端系统通过通信链路(communication links)和分组交换机(packet switches)网络连接在一起。</p><p>常见的分组交换机有路由器(routers)和链路层交换机(link-layer switches)。链路层交换机通常用于接入网络，而路由器通常用于网络核心。</p><p>数据包从发送端系统到接收端系统所经过的通信链路和分组交换机的序列称为网络路由(route)或路径(path)。</p><p>终端系统通过互联网服务提供商(<strong>I</strong>nternet <strong>S</strong>ervice <strong>P</strong>roviders)访问互联网。每个ISP本身就是一个由分组交换机和通信链路组成的网络。ISP向终端系统提供各种类型的网络接入。互联网就是要把终端系统相互连接起来，因此为终端系统提供接入的ISP也必须相互连接。因此，这些低层互联网服务提供商通过国内和国际上层互联网服务提供商实现互联，而这些上层互联网服务提供商则直接相互连接。上层ISP由高速路由器和高速光纤链路组成。每个ISP网络，无论是上层还是下层，都是独立管理的，运行IP协议，并符合特定的命名和地址约定。</p><p>终端系统、分组交换机和互联网的其他部分都运行着控制互联网内信息收发的协议。传输控制协议(<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol)和互联网协议(<strong>I</strong>nternet <strong>P</strong>rotocol)是互联网中最重要的两个协议。IP协议规定了路由器和终端系统之间收发数据包的格式。互联网的主要协议统称为<strong>TCP/IP</strong>。</p><p>The IEEE 802 LAN Standards Committee [IEEE 802 2020], for example, specifies the Ethernet and wireless WiFi standards.</p><h3 id="1-1-2-A-Services-Description"><a href="#1-1-2-A-Services-Description" class="headerlink" title="1.1.2 A Services Description"></a>1.1.2 A Services Description</h3><p><strong><em>互联网是为应用程序提供服务的基础设施。</em></strong></p><p>这些应用被称为分布式应用，因为它们涉及多个相互交换数据的终端系统。互联网应用是在终端系统上运行的，而不是在网络核心的分组交换机上运行的。虽然分组交换机有助于终端系统之间的数据交换，但它们与作为数据源或数据汇的应用程序无关。</p><p>连接到互联网的终端系统提供一个套接字接口(socket interface)，规定在一个终端系统上运行的程序如何要求互联网基础设施向在另一个终端系统上运行的特定目标程序传送数据。互联网套接字接口是一组规则，发送程序必须遵守这些规则，这样互联网才能将数据传送给目标程序。</p><blockquote><p>爱丽丝必须遵循这些规则才能让邮政服务将她的信投递给鲍勃。</p></blockquote><p>互联网为其应用程序提供多种服务。</p><h3 id="1-1-3-What-Is-a-Protocol"><a href="#1-1-3-What-Is-a-Protocol" class="headerlink" title="1.1.3 What Is a Protocol?"></a>1.1.3 What Is a Protocol?</h3><p><img src="/loadingPostImg.gif" data-original="image-20231121224818849.png" alt="2"></p><blockquote><p>如果人们执行不同的协议（例如，一个人有礼貌而另一个人没有，或者一个人理解时间概念而另一个人不理解），协议就无法互操作，也就无法完成有用的工作。</p></blockquote><p>联网也是如此——需要两个（或更多）运行相同协议的通信实体才能完成任务。</p><p>信息的发送和接收，以及在发送和接收这些信息时所采取的一系列常规操作，是这种问答协议的核心。</p><p>互联网中涉及两个或多个远程通信实体的所有活动都受协议制约。例如，在两台物理连接的计算机中，硬件实现的协议控制着两块网络接口卡之间 “线 “上的比特流；终端系统中的拥塞控制协议控制着数据包在发送方和接收方之间的传输速率；路由器中的协议决定着数据包从源到目的地的路径。</p><p>从上述人类和网络的例子来看，信息的交换以及收发这些信息时所采取的行动是协议的关键定义要素：</p><p><strong><em>协议定义了两个或多个通信实体之间交换信息的格式和顺序，以及在传输和/或接收信息或其他事件时所采取的行动。</em></strong></p><h2 id="1-2-The-Network-Edge"><a href="#1-2-The-Network-Edge" class="headerlink" title="1.2 The Network Edge"></a>1.2 The Network Edge</h2><p>在计算机网络术语中，连接到互联网的计算机和其他设备通常被称为终端系统。它们之所以被称为终端系统，是因为它们位于互联网的边缘。</p><ul><li>终端系统也被称为主机，因为它们承载（即运行）应用程序，如网络浏览器程序、网络服务器程序、电子邮件客户端程序或电子邮件服务器程序。主机有时会进一步分为两类：客户端(clients)和服务器(servers)。非正式地讲，客户端往往是台式机、笔记本电脑、智能手机等，而服务器往往是存储和分发网页、视频流、转发电子邮件等功能更强大的机器。如今，我们接收搜索结果、电子邮件、网页、视频和移动应用程序内容的服务器大多位于大型数据中心(data centers)。</li></ul><h3 id="1-2-1-Access-Networks"><a href="#1-2-1-Access-Networks" class="headerlink" title="1.2.1 Access Networks"></a>1.2.1 Access Networks</h3><p>接入网络——将终端系统与第一个路由器（也称为 “边缘路由器”）物理连接起来的网络。</p><h4 id="Home-Access-DSL-Cable-FTTH-and-5G-Fixed-Wireless"><a href="#Home-Access-DSL-Cable-FTTH-and-5G-Fixed-Wireless" class="headerlink" title="Home Access: DSL, Cable, FTTH, and 5G Fixed Wireless"></a>Home Access: DSL, Cable, FTTH, and 5G Fixed Wireless</h4><p>目前，最普遍的两种宽带住宅接入方式是数字用户线路(<strong>D</strong>igital <strong>S</strong>ubscriber <strong>L</strong>ine)和电缆(cable)。住宅通常从提供有线本地电话接入的本地电话公司(telco)获得DSL互联网接入。因此，使用DSL时，用户的电话公司也是其ISP。</p><p><img src="/loadingPostImg.gif" data-original="image-20231121234559850.png" alt="3"></p><ul><li>每个用户的DSL调制解调器(“猫”，modem)使用现有的电话线与位于电信公司本地中心局 (CO) 的数字用户线路接入多路复用器 (<strong>DSLA</strong>ccess <strong>M</strong>ultiplexer) 交换数据。</li></ul><ul><li><p>住宅电话线可同时传输数据和传统电话信号，这两种信号的编码频率不同：</p><ul><li>A high-speed downstream channel, in the 50 kHz to 1 MHz band </li></ul></li></ul><ul><li>A medium-speed upstream channel, in the 4 kHz to 50 kHz band </li></ul><ul><li>An ordinary two-way telephone channel, in the 0 to 4 kHz band</li></ul><ul><li>这种方法使单个DSL链路看起来好像有三个独立的链路，因此电话和互联网连接可以同时共享DSL链路。（频分复用技术）</li></ul><ul><li>在用户端，分路器(splitter)将到达家庭的数据信号和电话信号分开，并将数据信号转发给DSL调制解调器；在电信公司方面，在本地中心局，DSLAM分离数据和电话信号，并将数据发送到互联网。数百甚至数千个家庭连接到一个DSLAM。</li></ul><ul><li>DSL标准规定了多种传输速率，最新标准规定了1Gbps的上行加下行总速率[ITU 2014]。由于下行和上行速率不同，这种接入方式被称为非对称接入。</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231122215452014.png" alt="image-20231122215452014"></p><p>DSL利用电信公司现有的本地电话基础设施，而有线互联网接入(cable Internet access)则利用有线电视公司现有的有线电视基础设施。住宅从提供有线电视的同一家公司获得有线互联网接入。光纤连接电缆头端(cable head end)与社区级联结点，然后使用传统的同轴电缆将电缆连接到各个住宅和公寓。由于该系统同时使用光纤和同轴电缆，因此通常被称为混合光纤同轴(<strong>H</strong>ybrid <strong>F</strong>iber <strong>C</strong>oax)网络。</p><ul><li>电缆上网需要特殊的调制解调器，称为电缆调制解调器(cable modems)。与DSL调制解调器一样，电缆调制解调器通常是一个外部设备，通过以太网端口与家用电脑连接。在电缆头端，电缆调制解调器终端系统(<strong>C</strong>able <strong>M</strong>odem <strong>T</strong>ermination <strong>S</strong>ystem)的功能与DSL网络的DSLAM相似，它将从许多下游家庭的电缆调制解调器发送的模拟信号转换成数字格式。电缆调制解调器将HFC网络分为两个通道，一个下行通道和一个上行通道。与DSL一样，接入通常是不对称的，下行信道的传输速率通常高于上行信道。</li></ul><ul><li>有线互联网接入的一个重要特点是它是一种共享的广播媒介。特别是，头端发送的每个数据包都会通过每条链路下传到每个家庭，而家庭发送的每个数据包都会通过上游信道上传到头端。因此，如果多个用户同时在下行信道上下载视频文件，则每个用户接收视频文件的实际速率将大大低于有线电视的总下行速率。由于上行信道也是共享的，因此需要一个分布式多路访问协议来协调传输和避免碰撞。</li></ul><p>光纤到户(<strong>F</strong>iber <strong>T</strong>o <strong>T</strong>he <strong>H</strong>ome)[Fiber Broadband 2020]是一种新兴技术，可提供更高的速度。FTTH的概念很简单——提供一条从CO直接到家庭的光纤路径。从CO到住户的光纤分配有几种相互竞争的技术。最简单的光纤分配网络称为直接光纤，每户家庭都有一根光纤从CO出发。更常见的情况是，离开CO的每根光纤实际上都被许多住户共享；直到光纤相对接近住户时，才会被拆分成客户专用的单根光纤。目前有两种相互竞争的光分配网络体系结构可以实现这种分割：有源光网络(<strong>A</strong>ctive <strong>O</strong>ptical <strong>N</strong>etwork<strong>s</strong>)和无源光网络(<strong>P</strong>assive <strong>O</strong>ptical <strong>N</strong>etwork<strong>s</strong>)。AON本质上是交换式以太网。</p><p><img src="/loadingPostImg.gif" data-original="image-20231122222111634.png" alt="image-20231122222111634"></p><ul><li>如图是PON分配结构的FTTH。每个家庭都有一个光网络终端(<strong>O</strong>ptical <strong>N</strong>etwork <strong>T</strong>erminator)，它通过专用光纤与小区分路器相连。分路器将多个家庭（通常少于 100 户）合并到一根共享光纤上，然后连接到电信公司CO的光线路终端器(<strong>O</strong>ptical <strong>L</strong>ine <strong>T</strong>erminator)。OLT提供光信号和电信号之间的转换，并通过电信公司的路由器连接到互联网。在家里，用户将家用路由器（通常是无线路由器）连接到ONT，并通过该家用路由器访问互联网。在PON架构中，从OLT发送到分路器的所有数据包都在分路器上进行复制（类似于电缆头端）。</li></ul><p>除了 DSL、Cable 和FTTH，5G 固定无线网络也开始部署。5G固定无线网络不仅能提供高速的住宅接入，而且无需从电信公司的CO到住宅安装昂贵且易发生故障的电缆。5G固定无线技术采用波束成形技术，数据从供应商的基站以无线方式发送到家中的调制解调器。WiFi无线路由器与调制解调器相连（可能捆绑在一起），类似于WiFi无线路由器与电缆或DSL调制解调器的连接方式。</p><p><img src="/loadingPostImg.gif" data-original="image-20231124153448136.png" alt="image-20231124153448136"></p><p>局域网(<strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork)技术有多种类型，最普遍的接入技术是以太网(Ethernet)。</p><ul><li><p>以太网用户使用双绞线铜线(twisted-pair copper wire)连接到以太网交换机。然后，以太网交换机或由此类互连交换机组成的网络又与更大的互联网相连。</p></li><li><p>基于IEEE 802.11技术的无线局域网接入(WiFi)无处不在。在无线局域网环境中，无线用户向接入点发送/接收数据包，接入点连接到企业网络（很可能使用有线以太网），而企业网络又连接到有线互联网。</p></li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231124153651865.png" alt="image-20231124153651865"></p><h4 id="Wide-Area-Wireless-Access-3G-and-LTE-4G-and-5G"><a href="#Wide-Area-Wireless-Access-3G-and-LTE-4G-and-5G" class="headerlink" title="Wide-Area Wireless Access: 3G and LTE 4G and 5G"></a>Wide-Area Wireless Access: 3G and LTE 4G and 5G</h4><ul><li>设备采用与蜂窝电话相同的无线基础设施，通过蜂窝网络提供商运营的基站发送/接收数据包。与 WiFi 不同的是，用户只需在距离基站几十公里（而不是几十米）的范围内即可使用。其实际下载速度可达 60 Mbps。更高速的广域接入技术——第五代（5G）广域无线网络已经开始部署。</li><li>广域蜂窝接入网(Wide-area cellular access networks)<ul><li>provided by mobile, cellular network operator (10’s km)</li><li>10’s Mbps </li></ul></li></ul><h3 id="1-2-2-Physical-Media"><a href="#1-2-2-Physical-Media" class="headerlink" title="1.2.2 Physical Media"></a>1.2.2 Physical Media</h3><p>物理介质分为两类：导向介质(guided media)和非导向介质(unguided media)。</p><ul><li>在导向介质中，电波沿着固体介质（如光导纤维、双绞线或同轴电缆）传播。</li><li>对于非导向介质，电波在大气层和外层空间传播，例如在无线局域网(WLAN)或数字卫星信道中传播。</li></ul><h4 id="Twisted-Pair-Copper-Wire"><a href="#Twisted-Pair-Copper-Wire" class="headerlink" title="Twisted-Pair Copper Wire"></a>Twisted-Pair Copper Wire</h4><ul><li>双绞线铜线是成本最低、最常用的引导传输介质。</li><li>电话网络一直使用双绞线。</li><li>非屏蔽双绞线(<strong>U</strong>nshielded <strong>T</strong>wisted <strong>P</strong>air)通常用于建筑物内的计算机网络，即局域网。目前，使用双绞线的局域网数据传输速率从 10 Mbps 到 10 Gbps 不等。双绞线成为高速局域网联网的主流解决方案。</li><li>双绞线也常用于住宅互联网接入。拨号调制解调器技术可通过双绞线实现高达 56 kbps 的接入速率。DSL技术使住宅用户能够通过双绞线以10’s Mbps 的速率访问互联网（当用户居住地靠近 ISP 的CO时）。</li></ul><h4 id="Coaxial-Cable"><a href="#Coaxial-Cable" class="headerlink" title="Coaxial Cable"></a>Coaxial Cable</h4><ul><li>与双绞线一样，同轴电缆由两根铜导体组成，但两根导体同心而非平行。有了这种结构以及特殊的绝缘和屏蔽，同轴电缆可以实现很高的数据传输速率。</li><li>同轴电缆在有线电视系统中非常常见。有线电视系统最近与cable modem相结合，为住宅用户提供了100’s Mbps 的互联网接入速率。在有线电视和有线互联网接入中，发射机将数字信号转移到特定频段，然后将产生的模拟信号从发射机发送到一个或多个接收器。</li><li>同轴电缆可用作导向共享介质(guided shared medium)。具体来说，一些终端系统可以直接连接到电缆上，每个终端系统都可以接收其他终端系统发送的任何信号。</li></ul><h4 id="Fiber-Optics"><a href="#Fiber-Optics" class="headerlink" title="Fiber Optics"></a>Fiber Optics</h4><ul><li>光纤是一种薄而灵活的介质，可传输光脉冲，每个脉冲代表一个比特。单根光纤可支持极大的比特率，10’s ~ 100’s Mbps。</li><li>不受电磁干扰，信号衰减极低，最远可达 100 公里，而且很难被窃听。这些特点使光纤成为首选的长途导向传输媒体，尤其是海外链路。美国和其他地方的许多长途电话网络现在都完全使用光纤。光纤在互联网骨干网(backbone)中也很普遍。</li><li>光设备（如发射器、接收器和交换机）的高成本阻碍了它们在局域网或家庭接入网等短途传输中的应用。</li><li>光载波(<strong>O</strong>ptical <strong>C</strong>arrier)标准链路速度从 51.8 Mbps 到 39.8 Gbps 不等；这些规格通常称为 OC-n，其中链路速度等于 n × 51.8 Mbps。目前使用的标准包括 OC-1、OC-3、OC-12、OC-24、OC-48、OC-96、OC-192 和 OC-768。</li></ul><h4 id="Terrestrial-Radio-Channels"><a href="#Terrestrial-Radio-Channels" class="headerlink" title="Terrestrial Radio Channels"></a>Terrestrial Radio Channels</h4><ul><li>无线电信道在电磁频谱中传输信号。</li><li>无线电信道的特性在很大程度上取决于传播环境和信号传输距离。环境因素决定了路径损耗和阴影衰落（当信号传输距离较远并绕过/穿过障碍物时，信号强度会降低）、多径衰落（由于信号被干扰物体反射）和干扰（由于其他传输和电磁信号）。</li><li>地面无线电信道大致可分为三类：极短距离无线电信道、局域无线电信道和广域无线电信道。无线耳机、键盘等使用极端距离无线电信道；WLAN技术使用的是局域无线电信道；蜂窝接入(cellular access)技术使用的是广域无线电信道。</li></ul><h4 id="Satellite-Radio-Channels"><a href="#Satellite-Radio-Channels" class="headerlink" title="Satellite Radio Channels"></a>Satellite Radio Channels</h4><ul><li>通信卫星将两个或多个地面微波发射器/接收器（称为地面站）连接起来。卫星接收一个频段的传输信号，使用中继器（下文将讨论）再生信号，然后在另一个频段上传输信号。</li><li>用于通信的卫星有两类：地球静止卫星(geostationary satellites)和低地轨道卫星(<strong>L</strong>ow-<strong>E</strong>arth <strong>O</strong>rbiting)。</li><li>280ms 信号传播延迟，链路运行速度100’s Mbps，通常用于无法使用 DSL 或电缆上网的地区。</li><li>LEO可以用于互联网接入。</li></ul><h2 id="1-3-The-Network-Core"><a href="#1-3-The-Network-Core" class="headerlink" title="1.3 The Network Core"></a>1.3 The Network Core</h2><p>连接互联网终端系统的分组交换机和链路网。</p><h3 id="1-3-1-Packet-Switching"><a href="#1-3-1-Packet-Switching" class="headerlink" title="1.3.1 Packet Switching"></a>1.3.1 Packet Switching</h3><ul><li>要将信息从信源端系统发送到目的端系统，信源会将长信息分成较小的数据块，即数据包。</li><li>在源端和目的端之间，每个数据包都要经过通信链路和分组交换机（主要有两种类型：路由器和链路层交换机）。数据包在每个通信链路上的传输速率等于链路的全部传输速率。</li></ul><h4 id="Store-and-Forward-Transmission"><a href="#Store-and-Forward-Transmission" class="headerlink" title="Store-and-Forward Transmission"></a>Store-and-Forward Transmission</h4><p>大多数分组交换机在链路输入端使用存储转发传输。</p><ul><li>存储转发传输意味着分组交换机必须先接收到整个数据包，然后才能开始将数据包的第一比特传输到出站链路上。</li><li>路由器通常会有许多入站链路，因为它的任务是将传入数据包切换到出站链路上。</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231124175912639.png" alt="image-20231124175912639"></p><ul><li><p>这个例子中，源端有三个数据包要发送到目的地，每个数据包由$L$bits组成。在图 1.11 所示的时间快照处，信源已传送了部分数据包 1，而数据包 1 的前端已到达路由器。由于路由器采用了存储转发技术，因此在这一时刻，路由器不能传输它已收到的比特，而必须先缓冲（即 “store”）数据包的比特。只有在路由器接收到数据包的所有比特后，它才能开始将数据包传输（即 “forward”）到出站链路上。</p></li><li><p>忽略传播延迟。信源在时间 $0$ 开始传输；在时间 $L/R$ 秒时，信源已传输完整个数据包，路由器也已接收并存储了整个数据包。在 $L/R$ 秒时，由于路由器刚刚接收到整个数据包，因此可以开始将数据包传输到目的地的出站链路上；在 $2L/R$ 秒时，路由器已传输完整个数据包，目的地也已接收到整个数据包。总延迟为 $2L/R$。</p></li><li><p>考虑一般情况。通过由 $N$ 个链路组成的路径从源点向目的地发送一个数据包（在源点和目的地之间有 $N-1$ 个路由器）。端到端延迟为</p><script type="math/tex; mode=display">d_{end-to-end} = N \frac{L}{R}</script></li></ul><h4 id="Queuing-Delays-and-Packet-Loss"><a href="#Queuing-Delays-and-Packet-Loss" class="headerlink" title="Queuing Delays and Packet Loss"></a>Queuing Delays and Packet Loss</h4><ul><li>每个分组交换机都有多个连接链路。对于每个连接的链路，分组交换机都有一个输出缓冲区(output buffer)，也称为输出队列(output queue)，用于存储路由器即将发送到该链路的数据包。</li><li>除了存储转发延迟外，数据包还会受到输出缓冲区排队延迟的影响。这些延迟是可变的，取决于网络的拥塞程度。</li><li>由于缓冲区空间有限，到达的数据包可能会发现缓冲区已被其他等待传输的数据包占满。在这种情况下，数据包丢失(packet loss)就会发生——到达的数据包或已经排队的数据包都会被丢弃。</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231124193525475.png" alt="image-20231124193525475"></p><h4 id="Forwarding-Tables-and-Routing-Protocols"><a href="#Forwarding-Tables-and-Routing-Protocols" class="headerlink" title="Forwarding Tables and Routing Protocols"></a>Forwarding Tables and Routing Protocols</h4><ul><li>在互联网中，每个终端系统都有一个地址，称为 IP 地址。当源端系统要向目的端系统发送数据包时，源端系统会在数据包头中包含目的端的 IP 地址。</li></ul><blockquote><p>与邮政地址一样，该地址也具有层次结构。</p></blockquote><ul><li>当数据包到达网络中的路由器时，路由器会检查数据包目的地址的一部分，并将数据包转发给相邻的路由器。更具体地说，每个路由器都有一个转发表(forwarding table)，将目的地址（或目的地址的一部分）映射到该路由器的出站链接上。当数据包到达路由器时，路由器会检查地址并使用该目标地址搜索转发表，以找到合适的出站链接。然后，路由器将数据包引导到该出站链接。</li></ul><blockquote><p>端到端路由选择过程类似于一个不使用地图而喜欢问路的汽车司机。例如，假设乔驾车从费城前往佛罗里达州奥兰多市的湖滨大道 156 号。乔首先开车到附近的加油站，询问如何前往佛罗里达州奥兰多市的湖滨大道 156 号。加油站服务员提取了地址中的佛罗里达州部分，告诉乔需要上 I-95 South 州际公路，入口就在加油站旁边。他还告诉乔，一旦进入佛罗里达州，他就应该询问那里的其他人。然后，乔沿着 I-95 南线一直走到佛罗里达州的杰克逊维尔，这时他向另一个加油站的服务员问路。服务员摘录了地址中的奥兰多部分，并告诉乔，他应该继续沿着 I-95 公路前往代托纳海滩，然后再去问别人。在代托纳海滩，另一名加油站服务员也提取了地址中的奥兰多部分，并告诉乔应该直接走 I-4 号公路前往奥兰多。乔乘坐 I-4 号公路，在奥兰多出口下了车。乔去找另一个加油站的服务员，这次服务员提取了地址中的湖滨大道部分，并告诉乔必须沿着哪条路才能到达湖滨大道。到达湖滨路后，乔向一个骑自行车的孩子询问如何到达目的地。孩子摘录了地址中的 156 部分，并指出了房子的位置。乔终于到达了最终目的地。在上述比喻中，加油站服务员和骑自行车的孩子就好比路由器。</p></blockquote><ul><li>路由器使用数据包的目的地址来索引转发表，并确定适当的出站链接。那么<strong><em>转发表是如何设置的？</em></strong>互联网有许多特殊的路由协议，用于自动设置转发表。例如，路由协议可以确定从每个路由器到每个目的地的最短路径，并使用最短路径结果来配置路由器中的转发表。（第 5 章）</li></ul><h3 id="1-3-2-Circuit-Switching"><a href="#1-3-2-Circuit-Switching" class="headerlink" title="1.3.2 Circuit Switching"></a>1.3.2 Circuit Switching</h3><p>通过链路和交换机网络传输数据有两种基本方法：电路交换和分组交换。</p><ul><li>在电路交换网络中，终端系统之间通信所需的路径资源（缓冲区、链路传输速率）是在终端系统之间的通信会话(session)期间预留(reserved)的。在分组交换网络中，这些资源并不保留；会话信息按需使用资源，因此可能需要等待（即排队）才能进入通信链路。</li><li>传统的电话网络就是电路交换网络的例子。在发送方发送信息之前，网络必须在发送方和接收方之间建立连接。这是一个真正的连接，发送方和接收方之间路径上的交换机为该连接保持连接状态。在电话术语中，这种连接称为电路(circuit)。</li><li>网络在建立电路时，也会在连接期间为网络链路预留一个恒定的传输速率（代表每个链路传输容量的一部分）。由于已为发送方到接收方的连接预留了一定的传输速率，因此发送方可以按照保证的恒定速率向接收方传输数据。</li></ul><p><img src="/loadingPostImg.gif" data-original="image-20231124200349949.png" alt="image-20231124200349949"></p><ul><li>图 1.13 展示了一个电路交换网络。在该网络中，四个电路交换机通过四个链路相互连接。每个链路都有四个电路，因此每个链路可同时支持四个连接。每台主机（如个人电脑和工作站）都直接连接到其中一台交换机。当两台主机要通信时，网络会在两台主机之间建立专用的端到端连接。因此，为了让主机 A 与主机 B 通信，网络必须首先在两条链路上各预留一条电路。在本例中，专用端到端连接使用了第一条链路中的第二个电路和第二条链路中的第四个电路。由于每个链路都有四个电路，因此端到端连接每使用一个链路，就能在连接期间获得该链路总传输容量的四分之一。因此，举例来说，如果相邻交换机之间的每个链路的传输速率都是 1 Mbps，那么每个端到端电路交换机连接就能获得 250 kbps 的专用传输速率。</li><li>相比之下，如果一台主机想通过分组交换网络（如互联网）向另一台主机发送数据包，与电路交换不同的是，数据包是在不预留任何链路资源的情况下发送到网络中的。如果其中一条链路因其他数据包需要同时通过该链路传输而拥塞，那么数据包将不得不在传输链路发送端的缓冲区中等待，并遭受延迟。互联网会尽最大努力及时传送数据包，但不作任何保证。</li></ul><h4 id="Multiplexing-in-Circuit-Switched-Networks"><a href="#Multiplexing-in-Circuit-Switched-Networks" class="headerlink" title="Multiplexing in Circuit-Switched Networks"></a>Multiplexing in Circuit-Switched Networks</h4><h4 id="Packet-Switching-Versus-Circuit-Switching"><a href="#Packet-Switching-Versus-Circuit-Switching" class="headerlink" title="Packet Switching Versus Circuit Switching"></a>Packet Switching Versus Circuit Switching</h4><h3 id="1-3-3-A-Network-of-Networks"><a href="#1-3-3-A-Network-of-Networks" class="headerlink" title="1.3.3 A Network of Networks"></a>1.3.3 A Network of Networks</h3><h2 id="1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks"><a href="#1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks" class="headerlink" title="1.4 Delay, Loss, and Throughput in Packet-Switched Networks"></a>1.4 Delay, Loss, and Throughput in Packet-Switched Networks</h2><h3 id="1-4-1-Overview-of-Delay-in-Packet-Switched-Networks"><a href="#1-4-1-Overview-of-Delay-in-Packet-Switched-Networks" class="headerlink" title="1.4.1 Overview of Delay in Packet-Switched Networks"></a>1.4.1 Overview of Delay in Packet-Switched Networks</h3><h4 id="Types-of-Delay"><a href="#Types-of-Delay" class="headerlink" title="Types of Delay"></a>Types of Delay</h4><h4 id="Processing-Delay"><a href="#Processing-Delay" class="headerlink" title="Processing Delay"></a>Processing Delay</h4><h4 id="Queuing-Delay"><a href="#Queuing-Delay" class="headerlink" title="Queuing Delay"></a>Queuing Delay</h4><h4 id="Transmission-Delay"><a href="#Transmission-Delay" class="headerlink" title="Transmission Delay"></a>Transmission Delay</h4><h4 id="Propagation-Delay"><a href="#Propagation-Delay" class="headerlink" title="Propagation Delay"></a>Propagation Delay</h4><h4 id="Comparing-Transmission-and-Propagation-Delay"><a href="#Comparing-Transmission-and-Propagation-Delay" class="headerlink" title="Comparing Transmission and Propagation Delay"></a>Comparing Transmission and Propagation Delay</h4><h3 id="1-4-2-Queuing-Delay-and-Packet-Loss"><a href="#1-4-2-Queuing-Delay-and-Packet-Loss" class="headerlink" title="1.4.2 Queuing Delay and Packet Loss"></a>1.4.2 Queuing Delay and Packet Loss</h3><h4 id="Packet-Loss"><a href="#Packet-Loss" class="headerlink" title="Packet Loss"></a>Packet Loss</h4><h3 id="1-4-3-End-to-End-Delay"><a href="#1-4-3-End-to-End-Delay" class="headerlink" title="1.4.3 End-to-End Delay"></a>1.4.3 End-to-End Delay</h3><h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><h4 id="End-System-Application-and-Other-Delays"><a href="#End-System-Application-and-Other-Delays" class="headerlink" title="End System, Application, and Other Delays"></a>End System, Application, and Other Delays</h4><h3 id="1-4-4-Throughput-in-Computer-Networks"><a href="#1-4-4-Throughput-in-Computer-Networks" class="headerlink" title="1.4.4 Throughput in Computer Networks"></a>1.4.4 Throughput in Computer Networks</h3><h2 id="1-5-Protocol-Layers-and-Their-Service-Models"><a href="#1-5-Protocol-Layers-and-Their-Service-Models" class="headerlink" title="1.5 Protocol Layers and Their Service Models"></a>1.5 Protocol Layers and Their Service Models</h2><h3 id="1-5-1-Layered-Architecture"><a href="#1-5-1-Layered-Architecture" class="headerlink" title="1.5.1 Layered Architecture"></a>1.5.1 Layered Architecture</h3><h4 id="Protocol-Layering"><a href="#Protocol-Layering" class="headerlink" title="Protocol Layering"></a>Protocol Layering</h4><h4 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h4><h4 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h4><h4 id="Network-Layer"><a href="#Network-Layer" class="headerlink" title="Network Layer"></a>Network Layer</h4><h4 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h4><h4 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h4><h3 id="1-5-2-Encapsulation"><a href="#1-5-2-Encapsulation" class="headerlink" title="1.5.2 Encapsulation"></a>1.5.2 Encapsulation</h3><h2 id="1-6-Networks-Under-Attack"><a href="#1-6-Networks-Under-Attack" class="headerlink" title="1.6 Networks Under Attack"></a>1.6 Networks Under Attack</h2><h4 id="The-Bad-Guys-Can-Put-Malware-into-Your-Host-Via-the-Internet"><a href="#The-Bad-Guys-Can-Put-Malware-into-Your-Host-Via-the-Internet" class="headerlink" title="The Bad Guys Can Put Malware into Your Host Via the Internet"></a>The Bad Guys Can Put Malware into Your Host Via the Internet</h4><h4 id="The-Bad-Guys-Can-Attack-Servers-and-Network-Infrastructure"><a href="#The-Bad-Guys-Can-Attack-Servers-and-Network-Infrastructure" class="headerlink" title="The Bad Guys Can Attack Servers and Network Infrastructure"></a>The Bad Guys Can Attack Servers and Network Infrastructure</h4><h4 id="The-Bad-Guys-Can-Sniff-Packets"><a href="#The-Bad-Guys-Can-Sniff-Packets" class="headerlink" title="The Bad Guys Can Sniff Packets"></a>The Bad Guys Can Sniff Packets</h4><h4 id="The-Bad-Guys-Can-Masquerade-as-Someone-You-Trust"><a href="#The-Bad-Guys-Can-Masquerade-as-Someone-You-Trust" class="headerlink" title="The Bad Guys Can Masquerade as Someone You Trust"></a>The Bad Guys Can Masquerade as Someone You Trust</h4>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ML作业2</title>
      <link href="/2023/11/12/ML2/"/>
      <url>/2023/11/12/ML2/</url>
      
        <content type="html"><![CDATA[<p><img src="/loadingPostImg.gif" data-original="1.png" alt="1"></p><p>（2）多项式回归模型：</p><script type="math/tex; mode=display">y(x, \mathbf{w}) = w_0 + w_1x + w_2x^2 + \ldots + w_Mx^M</script><p>其中，$\mathbf{w} = [w_0, w_1, \ldots, w_M]$是多项式系数向量，$M$是多项式的阶数。</p><p>给定训练数据集${(x_1, y_1), \ldots, (x_N, y_N)}$，假设观测噪声服从均值为零、方差为$\sigma^2$的高斯分布，即$y(x, \mathbf{w})$的条件概率分布为：</p><script type="math/tex; mode=display">p(\mathbf{t}|\mathbf{X}, \mathbf{w}, \sigma^2) = \prod_{n=1}^{N} \mathcal{N}(t_n | y(x_n, \mathbf{w}), \sigma^2)</script><p>其中，$\mathbf{t} = [t_1, \ldots, t_N]$是观测目标值，$\mathbf{X} = [x_1, \ldots, x_N]$是输入数据。</p><p>最大似然估计的目标是最大化似然函数，即在给定观测数据的条件下，找到使得观测数据出现的概率最大的模型参数。似然函数为：</p><script type="math/tex; mode=display">L(\mathbf{w} | \mathbf{X}, \mathbf{t}, \sigma^2) = \prod_{n=1}^{N} \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{1}{2\sigma^2}(t_n - y(x_n, \mathbf{w}))^2\right)</script><p>取对数似然，得到：</p><script type="math/tex; mode=display">\ln L(\mathbf{w} | \mathbf{X}, \mathbf{t}, \sigma^2) = -\frac{N}{2} \ln(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{n=1}^{N} (t_n - y(x_n, \mathbf{w}))^2</script><p>考虑最小化对数似然的负数，即最小化损失函数：</p><script type="math/tex; mode=display">L(\mathbf{w}) = \frac{1}{2\sigma^2} \sum_{n=1}^{N} (t_n - y(x_n, \mathbf{w}))^2</script><p>即最小二乘法的损失函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># (1)</span></span><br><span class="line"><span class="comment"># 生成训练数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">x_train = np.sort(np.random.rand(<span class="number">10</span>))</span><br><span class="line">y_train = np.sin(<span class="number">2</span> * np.pi * x_train) + np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.scatter(x_train, y_train, label=<span class="string">&#x27;Training Data&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Generated Training Data&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3)</span></span><br><span class="line"><span class="comment"># 多项式回归</span></span><br><span class="line">plt.scatter(x_train, y_train, label=<span class="string">&#x27;Training Data&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> degree <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    poly_features = PolynomialFeatures(degree=degree)</span><br><span class="line">    x_poly = poly_features.fit_transform(x_train.reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    model = LinearRegression()</span><br><span class="line">    model.fit(x_poly, y_train)</span><br><span class="line">    x_plot = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    x_plot_poly = poly_features.transform(x_plot.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    y_plot = model.predict(x_plot_poly)</span><br><span class="line">    plt.plot(x_plot, y_plot, label=<span class="string">f&#x27;Degree = <span class="subst">&#123;degree&#125;</span>&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Polynomial Regression with Different Degrees&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.ylim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># (4)</span></span><br><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line">x_test = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y_test_true = np.sin(<span class="number">2</span> * np.pi * x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算训练误差和测试误差</span></span><br><span class="line">train_errors = []</span><br><span class="line">test_errors = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> degree <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    poly_features = PolynomialFeatures(degree=degree)</span><br><span class="line">    x_train_poly = poly_features.fit_transform(x_train.reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    model = LinearRegression()</span><br><span class="line">    model.fit(x_train_poly, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算训练误差</span></span><br><span class="line">    y_train_pred = model.predict(x_train_poly)</span><br><span class="line">    train_error = np.sqrt(mean_squared_error(y_train, y_train_pred))</span><br><span class="line">    train_errors.append(train_error)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算测试误差</span></span><br><span class="line">    x_test_poly = poly_features.transform(x_test.reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    y_test_pred = model.predict(x_test_poly)</span><br><span class="line">    test_error = np.sqrt(mean_squared_error(y_test_true, y_test_pred))</span><br><span class="line">    test_errors.append(test_error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练误差和测试误差曲线</span></span><br><span class="line">plt.figure(<span class="number">3</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">11</span>), train_errors, label=<span class="string">&#x27;Training Error&#x27;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">11</span>), test_errors, label=<span class="string">&#x27;Testing Error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Testing Error for Different Polynomial Degrees&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Degree&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Root Mean Squared Error&#x27;</span>)</span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="2.png" alt="f1"></p><p><img src="/loadingPostImg.gif" data-original="3.png" alt="f2"></p><p><img src="/loadingPostImg.gif" data-original="4.png" alt="f3"></p><p>由图Training and Testing Error for Different Polynomial Degrees可以看出，当多项式次数为1时，模型出现了欠拟合，训练误差和测试误差都很高且相差不大。当多项式次数为10时，模型出现了过拟合，因为训练误差很低，但测试误差很高，并且相差很大。当多项式次数为5时，模型达到了一个较好的平衡，训练误差和测试误差都较低，且相差不大。</p><hr><p><img src="/loadingPostImg.gif" data-original="5.png" alt="2"></p><p>（1）当考虑多项式曲线拟合问题时，使用参数的最大后验概率（MAP）估计可以引入正则化项，从而得到正则化最小二乘法。</p><p>多项式回归模型：</p><script type="math/tex; mode=display">y(x, \mathbf{w}) = w_0 + w_1x + w_2x^2 + \ldots + w_Mx^M</script><p>其中，$\mathbf{w} = [w_0, w_1, \ldots, w_M]$ 是多项式系数向量，$M$是多项式的阶数。</p><p>假设先验概率分布为高斯分布，即：</p><script type="math/tex; mode=display">p(\mathbf{w}|\alpha) = \mathcal{N}(\mathbf{w}| \mathbf{0}, \alpha^{-1}\mathbf{I})</script><p>其中，$\alpha$是控制正则化项的超参数，$\mathbf{I}$是单位矩阵。</p><p>接下来，考虑似然函数。给定训练数据集${(x_1, y_1), \ldots, (x_N, y_N)}$，假设观测噪声服从均值为零、方差为$\beta^{-1}$的高斯分布，即$y(x, \mathbf{w})$​的条件概率分布为：</p><script type="math/tex; mode=display">p(\mathbf{t}|\mathbf{X}, \mathbf{w}, \beta) = \prod_{n=1}^{N} \mathcal{N}(t_n | y(x_n, \mathbf{w}), \beta^{-1})</script><p>其中，$\mathbf{t} = [t_1, \ldots, t_N]$是观测目标值，$\mathbf{X} = [x_1, \ldots, x_N]$是输入数据。</p><p>由贝叶斯定理得到后验概率：</p><script type="math/tex; mode=display">p(\mathbf{w}|\mathbf{X}, \mathbf{t}, \alpha, \beta) \propto p(\mathbf{t}|\mathbf{X}, \mathbf{w}, \beta) p(\mathbf{w}|\alpha)</script><p>取对数后，得到后验概率的对数：</p><script type="math/tex; mode=display">\ln p(\mathbf{w}|\mathbf{X}, \mathbf{t}, \alpha, \beta) = \ln p(\mathbf{t}|\mathbf{X}, \mathbf{w}, \beta) + \ln p(\mathbf{w}|\alpha) + \text{const}</script><p>对数似然的二次形式为：</p><script type="math/tex; mode=display">\ln p(\mathbf{t}|\mathbf{X}, \mathbf{w}, \beta) = -\frac{\beta}{2} \sum_{n=1}^{N} (y(x_n, \mathbf{w}) - t_n)^2</script><p>对数先验的二次形式为：</p><script type="math/tex; mode=display">\ln p(\mathbf{w}|\alpha) = -\frac{\alpha}{2} \mathbf{w}^T \mathbf{w}</script><p>将这两项代入对数后验，得到：</p><script type="math/tex; mode=display">\ln p(\mathbf{w}|\mathbf{X}, \mathbf{t}, \alpha, \beta) = -\frac{\beta}{2} \sum_{n=1}^{N} (y(x_n, \mathbf{w}) - t_n)^2 -\frac{\alpha}{2} \mathbf{w}^T \mathbf{w} + \text{const}</script><p>这里的$const$表示与 $\mathbf{w}$无关的常数项。</p><p>为了最大化后验概率，相当于最小化负的对数后验。因此，MAP 估计下的正则化最小二乘法的目标函数为：</p><script type="math/tex; mode=display">L(\mathbf{w}) = \frac{\beta}{2} \sum_{n=1}^{N} (y(x_n, \mathbf{w}) - t_n)^2 + \frac{\alpha}{2} \mathbf{w}^T \mathbf{w}</script><p>这就是正则化最小二乘法的目标函数。在实际应用中，通过调整超参数 $\alpha$来平衡拟合和正则化的效果。</p><p>sklearn.linear_model.Ridge()函数是具有L2正则化的线性最小二乘法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># (2)</span></span><br><span class="line"><span class="comment"># 生成训练数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">x_train = np.sort(np.random.rand(<span class="number">10</span>))</span><br><span class="line">y_train = np.sin(<span class="number">2</span> * np.pi * x_train) + np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line">x_test = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">y_test_true = np.sin(<span class="number">2</span> * np.pi * x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多项式回归带正则化项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ridge_polynomial_regression</span>(<span class="params">x, y, degree, alpha</span>):</span><br><span class="line">    poly_features = PolynomialFeatures(degree=degree)</span><br><span class="line">    x_poly = poly_features.fit_transform(x.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    model = Ridge(alpha=alpha)</span><br><span class="line">    model.fit(x_poly, y)</span><br><span class="line">    <span class="keyword">return</span> model, poly_features  <span class="comment"># 返回模型和多项式特征转换器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算训练误差和测试误差</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_errors</span>(<span class="params">model, poly_features, x, y_true</span>):</span><br><span class="line">    x_poly = poly_features.transform(x.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    y_pred = model.predict(x_poly)</span><br><span class="line">    error = np.sqrt(mean_squared_error(y_true, y_pred))</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制带正则化项的拟合曲线</span></span><br><span class="line">plt.scatter(x_train, y_train, label=<span class="string">&#x27;Training Data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同正则化参数下的拟合曲线</span></span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>]:</span><br><span class="line">    model, poly_features = ridge_polynomial_regression(x_train, y_train, degree=<span class="number">10</span>, alpha=alpha)</span><br><span class="line">    x_plot = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    x_plot_poly = poly_features.transform(x_plot.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    y_plot = model.predict(x_plot_poly)</span><br><span class="line">    plt.plot(x_plot, y_plot, label=<span class="string">f&#x27;Lambda = <span class="subst">&#123;alpha&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Ridge Regression with Different Regularization Parameters&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3)</span></span><br><span class="line"><span class="comment"># 计算训练误差和测试误差</span></span><br><span class="line">train_errors_ridge = []</span><br><span class="line">test_errors_ridge = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>]:</span><br><span class="line">    model, poly_features = ridge_polynomial_regression(x_train, y_train, degree=<span class="number">10</span>, alpha=alpha)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算训练误差</span></span><br><span class="line">    train_error = calculate_errors(model, poly_features, x_train, y_train)</span><br><span class="line">    train_errors_ridge.append(train_error)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算测试误差</span></span><br><span class="line">    test_error = calculate_errors(model, poly_features, x_test, y_test_true)</span><br><span class="line">    test_errors_ridge.append(test_error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制带正则化项的训练误差和测试误差曲线</span></span><br><span class="line">plt.plot([<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>], train_errors_ridge, label=<span class="string">&#x27;Training Error (Ridge)&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>], test_errors_ridge, label=<span class="string">&#x27;Testing Error (Ridge)&#x27;</span>)</span><br><span class="line">plt.xscale(<span class="string">&#x27;log&#x27;</span>)  <span class="comment"># 使用对数坐标尺度</span></span><br><span class="line">plt.title(<span class="string">&#x27;Training and Testing Error with Ridge Regression&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Lambda&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Root Mean Squared Error&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/loadingPostImg.gif" data-original="6.png" alt="f4"></p><p><img src="/loadingPostImg.gif" data-original="7.png" alt="f5"></p><p>由图Training and Testing Error with Ridge Regression可以看出，当lambda较大的时候，训练误差和测试误差都很高，这说明模型没有充分利用训练集的信息，对数据的特征没有学习到，也就是出现了欠拟合的现象。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/11/10/Redis/"/>
      <url>/2023/11/10/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis实现原理"><a href="#Redis实现原理" class="headerlink" title="Redis实现原理"></a>Redis实现原理</h2><ul><li>纯内存操作</li><li>单线程操作，避免频繁的上下文切换</li><li>采用非阻塞I/O多路复用机制</li><li>纯ANSI C编写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis的工作原理是什么</span><br><span class="line"></span><br><span class="line">Redis 是一个高性能的 key-value 存储系统，支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等。它的工作原理可以概括为：</span><br><span class="line"></span><br><span class="line">内存存储：Redis 将数据存储在内存中，以实现快速读写操作。同时，Redis 也支持数据持久化到磁盘中，以保证数据在断电等情况下不会丢失。</span><br><span class="line"></span><br><span class="line">单线程执行：Redis 使用单线程模型来避免多线程之间的竞争和锁等问题，从而提高系统的并发处理能力。同时，Redis 也使用了一些异步 IO 技术，以实现高效的网络 IO 操作。</span><br><span class="line"></span><br><span class="line">事件驱动模型：Redis 采用事件驱动模型，通过监听网络套接字上的事件，如可读事件、可写事件等，来触发对应的事件处理函数，从而实现对客户端请求的响应。这种模型避免了传统的轮询方式带来的性能问题。</span><br><span class="line"></span><br><span class="line">数据结构的支持：Redis 支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等。这些数据结构都有自己的特点和适用场景，可以满足不同应用的需求。</span><br><span class="line"></span><br><span class="line">原子性操作：Redis 支持多种原子性操作，如事务、乐观锁、悲观锁等。这些操作可以保证数据的一致性和正确性，同时也提高了系统的并发性能。</span><br><span class="line"></span><br><span class="line">总之，Redis 的工作原理非常灵活和高效，可以满足各种应用场景的需求。</span><br></pre></td></tr></table></figure><h2 id="使用redis有哪些好处"><a href="#使用redis有哪些好处" class="headerlink" title="使用redis有哪些好处"></a>使用redis有哪些好处</h2><ol><li><strong>速度快</strong>，因为数据存在内存中</li><li><strong>支持丰富数据类型</strong>，支持 string，list，set，sorted set，hash</li><li><strong>支持事务</strong>，操作都是原子性（与关系型数据库的事务不是同一个东西）</li><li><strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h2 id="redis相比memcached有哪些优势？"><a href="#redis相比memcached有哪些优势？" class="headerlink" title="redis相比memcached有哪些优势？"></a>redis相比memcached有哪些优势？</h2><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ol><h2 id="redis-最适合的场景"><a href="#redis-最适合的场景" class="headerlink" title="redis 最适合的场景"></a>redis 最适合的场景</h2><ul><li>会话缓存（Session Cache）</li><li>全页缓存（FPC）</li><li>队列</li><li>排行榜/计数器</li><li>发布/订阅</li></ul><h2 id="redis是单线程还是多线程"><a href="#redis是单线程还是多线程" class="headerlink" title="redis是单线程还是多线程"></a>redis是单线程还是多线程</h2><ul><li>无论什么版本，工作线程就是一个</li><li>6.x高版本出现了IO多线程</li><li>单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多的线程里去并行，好处如下：1、执行时间缩短，更快；2、更好的压榨系统及硬件的资源(网卡能够高效的使用)；</li></ul><h2 id="redis的一些其他特点"><a href="#redis的一些其他特点" class="headerlink" title="redis的一些其他特点"></a>redis的一些其他特点</h2><ul><li>Redis是单进程单线程的，利用队列技术将并发访问变为串行访问 </li><li>读写分离模型，整个集群的读和写的可用性都非常高 </li><li>数据分片模型，可以将每个节点看成都是独立的master，然后通过业务实现数据分片 </li><li><p>Redis的回收策略 </p></li><li><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 </li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 </li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 </li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li><li>no-enviction（驱逐）：禁止驱逐数据<br>使用策略规则： </li></ul></li></ul><ol><li><ol><li><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ol></li></ol></li></ol><h2 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，可以通过淘汰策略保证热点数据</p><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用<code>scan</code>指令查找，使用<code>keys</code>指令会阻塞</p><h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><ol><li>Master最好不要写内存快照，Master 写内存快照，save命令调度rdbSave函数，<strong>会阻塞主线程的工作</strong>，当快照比较大时对性能影响是非常大的，会间断性暂停服务。</li><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，<strong>AOF文件过大</strong>会影响Master重启的恢复速度。<strong>Master最好不要做任何持久化工作</strong>，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>Master调用<code>BGREWRITEAOF</code>重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在<code>同一个局域网</code>内</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用<strong>单向链表结构</strong>更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- …</code></li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li><strong>缓存穿透：</strong>查询某个 Key 对应的数据，<strong>数据库和reids中没有该数据</strong>，查了redis再查数据库，没有查出数据返回空（相当于进行了两次无用的查询），redis 也不会缓存空结果，这就造成每次通过这样的 Key 去查询数据都会直接到数据库中查询，这也是缓存命中率问题。</li><li><p><strong>解决方法：</strong></p></li><li><ul><li>让有效地请求到达数据库，即便放大前置环节的复杂度和成本</li></ul></li><li><ul><li><ul><li>布隆过滤器。布隆过滤器可以针对大数据量的、有规律的键值进行处理。一条记录是不是存在，本质上是一个 Bool 值，只需要使用 1bit 就可以存储。使用布隆过滤器将这种表示是、否等操作，压缩到一个数据结构中。比如，用户性别这种数据，就非常适合使用布隆过滤器来处理</li><li>将数据库查询的空结果缓存到 redis 中，设置合理的过期时间（可能浪费空间）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> object <span class="title function_">getProductList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product_list&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.Get(cacheKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//数据库查询不到，为空</span></span><br><span class="line">        cacheValue = getProductListFromDB();</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现为空，设置个默认值，也缓存起来</span></span><br><span class="line">            cacheValue = string.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li><strong>缓存击穿：</strong>如果缓存中的数据在某个时刻批量过期（相同的过期时间），导致大部分用户的请求都会直接落在数据库上，这种现象就叫作缓存击穿</li><li><p><strong>解决方法：</strong></p></li><li><ul><li>对于不变的比较热点的数据可以设置为永不过期</li><li>在访问数据的时候，更新其过期时间</li><li>对于批量入库的缓存项，分配比较合理的过期时间，避免同一时刻失效</li><li>使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程进入等待（性能大大降低）</li></ul></li><li><ul><li><ul><li>步骤：</li></ul></li></ul></li></ul><ol><li><ol><li><ol><li><ol><li>请求 redis，肯定没有</li><li>大家抢锁，redis取不到数据时</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>抢上的查数据库，O(1)</li><li>没抢上的 sleep（sleep线程不会占用cpu） </li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li>数据库查询，更新redis，O(1) </li><li>sleep的线程回到第一步 </li></ol></li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> object <span class="title function_">getProductList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product_list&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> cacheKey;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.get(cacheKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey) &#123;</span><br><span class="line">            cacheValue = CacheHelper.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="comment">//这里一般是sql查询数据</span></span><br><span class="line">                cacheValue = getProductListFromDB();</span><br><span class="line">                CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存</li></ul></li><li><ul><li><ul><li>缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存</li><li>缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> object <span class="title function_">getProductList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product_list&quot;</span>;    </span><br><span class="line">    <span class="comment">//缓存标记</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheSign</span> <span class="operator">=</span> cacheKey + <span class="string">&quot;_sign&quot;</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> CacheHelper.Get(cacheSign);</span><br><span class="line">    <span class="comment">//获取缓存值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.Get(cacheKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue; <span class="comment">//未过期，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHelper.Add(cacheSign, <span class="string">&quot;1&quot;</span>, cacheTime);       </span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">            <span class="comment">//这里一般是 sql查询数据</span></span><br><span class="line">            cacheValue = getProductListFromDB();</span><br><span class="line">            <span class="comment">//日期设缓存时间的2倍，用于脏读</span></span><br><span class="line">            CacheHelper.Add(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li><strong>缓存雪崩：</strong>如果在某一时刻缓存集中失效（缓存击穿 * N），或者缓存系统出现故障，所有的并发流量就会直接到达数据库。数据存储层的调用量就会暴增，用不了多长时间，数据库就会被大流量压垮，这种级联式的服务故障，就叫作缓存雪崩。</li><li><p><strong>解决方法：</strong></p></li><li><ul><li>保证 Redis 的高可用，将 Redis 缓存部署成高可用集群，有效的防止缓存雪崩问题的发生</li><li>缓解大并发流量，使用限流降级的方式防止缓存雪崩</li><li>通过数据预热的方式将可能大量访问的数据加载到缓存，在即将发生大并发访问的时候，提前手动触发加载不同的数据到缓存中，并为数据设置不同的过期时间，让缓存失效的时间点尽量均匀，不至于在同一时刻全部失效</li></ul></li></ul><h2 id="Redis是怎么删除过期key的、缓存如何回收的？"><a href="#Redis是怎么删除过期key的、缓存如何回收的？" class="headerlink" title="Redis是怎么删除过期key的、缓存如何回收的？"></a>Redis是怎么删除过期key的、缓存如何回收的？</h2><ul><li><p>被动清理</p></li><li><ul><li>当用户主动访问一个过期的key时，redis会将其直接从内存中删除</li></ul></li><li><p>主动清理</p></li><li><ul><li>redis后台轮询，分段分批的删除过期的key</li></ul></li></ul><h2 id="Redis的淘汰回收策略"><a href="#Redis的淘汰回收策略" class="headerlink" title="Redis的淘汰回收策略"></a>Redis的淘汰回收策略</h2><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 </li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 </li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 </li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li><li>no-enviction（驱逐）：禁止驱逐数据<br>使用策略规则： </li></ul><ol><li><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ol></li></ol><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p>解决思路：</p><ol><li>写个缓存刷新页面，上线时手工操作；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h2 id="主从不一致"><a href="#主从不一致" class="headerlink" title="主从不一致"></a>主从不一致</h2><ul><li>redis的确默认是弱一致性，异步的同步</li><li>锁不能用主从、(可用单实例/分片集群/redlock)==&gt;redisson</li><li>在配置中提供了必须有多少个Client连接能同步，可以配置同步因子，趋向于强制一性</li></ul><h2 id="数据库与缓存不一致如何解决？"><a href="#数据库与缓存不一致如何解决？" class="headerlink" title="数据库与缓存不一致如何解决？"></a>数据库与缓存不一致如何解决？</h2><ul><li>分布式事务（读多，写稀有情况下）</li><li><p>不强求一致 </p></li><li><ul><li>redis是缓存，更倾向于稍微的有时差，默认是弱一致性，异步的同步</li><li>减少DB的操作</li></ul></li><li><p>完全异步化，使用<code>MQ</code></p></li><li>使用<code>canal binlog</code></li></ul><h2 id="描述一下redis持久化原理？"><a href="#描述一下redis持久化原理？" class="headerlink" title="描述一下redis持久化原理？"></a>描述一下redis持久化原理？</h2><p>当前线程阻塞服务<br>异步后台进程完成持久，fork  +  cow</p><h2 id="redis实现分布式锁的指令"><a href="#redis实现分布式锁的指令" class="headerlink" title="redis实现分布式锁的指令"></a>redis实现分布式锁的指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k v nx ex</span><br></pre></td></tr></table></figure><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损部分其他服务，仍然需要保证主服务可用。可以将其他次要服务的数据进行缓存降级，从而提升主服务的稳定性。</p><h2 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h2><p><code>setnx + expire</code>的原子操作枪锁，也可以防止锁一直占用</p><h2 id="Redis做异步队列"><a href="#Redis做异步队列" class="headerlink" title="Redis做异步队列"></a>Redis做异步队列</h2><ul><li>一般使用list结构作为队列，<code>rpush</code>生产消息，<code>blpop</code>消费消息，<code>blpop</code>没有消息的时候，它会阻塞住直到消息到来</li><li>使用pub/sub主题订阅者模式，可以实现1:N的消息队列，在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等</li></ul><h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的<strong>卡顿现象</strong>。一般需要在时间上加一个随机值，使得<strong>过期时间分散</strong>一些。</p><h2 id="为什么Redis需要把所有数据放到内存中？"><a href="#为什么Redis需要把所有数据放到内存中？" class="headerlink" title="为什么Redis需要把所有数据放到内存中？"></a>为什么Redis需要把所有数据放到内存中？</h2><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征<br>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值</p><h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性</p><h2 id="Redis-集群方案与实现"><a href="#Redis-集群方案与实现" class="headerlink" title="Redis 集群方案与实现"></a>Redis 集群方案与实现</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储</p><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h2 id="缓存脏读"><a href="#缓存脏读" class="headerlink" title="缓存脏读"></a>缓存脏读</h2><p>缓存的数据与数据库中不一样</p><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><ul><li>前台</li><li>中台</li><li>后台</li></ul>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ML作业1</title>
      <link href="/2023/11/10/ML1/"/>
      <url>/2023/11/10/ML1/</url>
      
        <content type="html"><![CDATA[<p><img src="/loadingPostImg.gif" data-original="1.png" alt="1"></p><p>设总体均值为$\mu$，总体方差为$\sigma^2$。对上式两边求期望，得：</p><script type="math/tex; mode=display">\begin{aligned}E(\sigma_{ML}^2) &= E\left(\frac{1}{N} \sum_{n=1}^N (x_n - \mu_{ML})^2\right)\\&= \frac{1}{N} \sum_{n=1}^N E\left((x_n - \mu_{ML})^2\right)\\&= \frac{1}{N} \sum_{n=1}^N E\left((x_n - \mu + \mu -\mu_{ML})^2\right)\\&= \frac{1}{N} \sum_{n=1}^N E\left((x_n - \mu)^2 + 2(x_n - \mu)(\mu - \mu_{ML}) + (\mu - \mu_{ML})^2\right)\\&= \frac{1}{N} \sum_{n=1}^N E\left((x_n - \mu)^2\right) + 2E\left((x_n - \mu)(\mu - \mu_{ML})\right) + E\left((\mu - \mu_{ML})^2\right)\\&= \frac{N-1}{N}\sigma^2\end{aligned}</script><p>从而得：</p><script type="math/tex; mode=display">E(\sigma_{ML}^2) - \sigma^2 = -\frac{\sigma^2}{N}</script><p>因此最大似然估计的方差是有偏的(biased)。</p><p><img src="/loadingPostImg.gif" data-original="2.png" alt="2"></p><p>假设$p_k \geq 0$，构造拉格朗日函数：</p><script type="math/tex; mode=display">L(p_1, p_2, \dots, p_m, \lambda) = -\sum_{k=1}^m p_k \log p_k + \lambda (\sum_{k=1}^m p_k - 1)</script><p>令</p><script type="math/tex; mode=display">\left\{ \begin{matrix}\begin{aligned}\frac{\partial L}{\partial p_k} &= -\log p_k - 1 + \lambda = 0, \quad k = 1, 2, \dots, m \\\frac{\partial L}{\partial \lambda} &= \sum_{k=1}^m p_k - 1 = 0\end{aligned}\end{matrix} \right.</script><p>有$p_k = e^{\lambda - 1}, \quad k = 1, 2, \dots, m<br>$</p><p>代入第二个方程，有：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{k=1}^m p_k &= me^{\lambda - 1} = 1 \\\Rightarrow \lambda &= 1 -\ln m\\p_k &= \frac{1}{m} >  0, \quad k = 1, 2, \dots, m\end{aligned}</script><p>计算拉格朗日函数的黑塞矩阵，有：</p><script type="math/tex; mode=display">\begin{align} H(L) &= \begin{bmatrix} -\frac {1}{p_1} & 0 & \cdots & 0 & 1 \\ 0 & -\frac {1}{p_2} & \cdots & 0 & 1 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & -\frac {1}{p_m} & 1 \\ 1 & 1 & \cdots & 1 & 0 \\ \end{bmatrix} \\ &= \begin{bmatrix} -m & 0 & \cdots & 0 & 1 \\ 0 & -m & \cdots & 0 & 1 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & -m & 1 \\ 1 & 1 & \cdots & 1 & 0 \\ \end{bmatrix} \end{align}</script><p>奇数阶顺序主子式均小于零，矩阵负定，所以得到的是局部极大值，也是全局最大的熵。</p><p>目标函数是严格凸的，约束集是凸集，所以最优解唯一。</p><p><img src="/loadingPostImg.gif" data-original="3.png" alt="3"></p><p>设微分熵为：</p><script type="math/tex; mode=display">H(X) = -\int_{-\infty}^{\infty}p(x)\log p(x)dx</script><p>根据已知条件，有：</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty}xp(x)dx=\alpha\\\int_{-\infty}^{\infty}(x-\alpha)^2p(x)dx=\beta</script><p>设拉格朗日函数为：</p><script type="math/tex; mode=display">L(p)=H(X)+\lambda_0\left(\int_{-\infty}^{\infty}p(x)dx-1\right)+\lambda_1\left(\int_{-\infty}^{\infty}xp(x)dx-\alpha\right)+\lambda_2\left(\int_{-\infty}^{\infty}(x-\alpha)^2p(x)dx-\beta\right)</script><p>令$\frac{\partial}{\partial p(x)}L(p)=-\log p(x)-1+\lambda_0+\lambda_1x+\lambda_2(x-\alpha)^2=0<br>$</p><p>解得：</p><script type="math/tex; mode=display">p(x)=e^{-1+\lambda_0}\cdot e^{\lambda_1x+\lambda_2(x-\alpha)^2}\\e^{-1+\lambda_0}\int_{-\infty}^{\infty}e^{\lambda_1x+\lambda_2(x-\alpha)^2}dx=1\\e^{-1+\lambda_0}\int_{-\infty}^{\infty}xe^{\lambda_1x+\lambda_2(x-\alpha)^2}dx=\alpha\\e^{-1+\lambda_0}\int_{-\infty}^{\infty}(x-\alpha)^2e^{\lambda_1x+\lambda_2(x-\alpha)^2}dx=\beta</script><p>令$\lambda_1 = 0$，解得：</p><script type="math/tex; mode=display">\begin{aligned}\lambda_0&=1+\log|\lambda_2|-\log \pi\\\alpha&=-\frac{1}{4\lambda_2}\\\beta&=\frac{3}{4|\lambda_2|}-\frac{1}{16\lambda_2^2}\\p(x)&=\frac{1}{\sqrt{2\pi\beta}}e^{-\frac{(x-\alpha)^2}{2\beta}}\end{aligned}</script><p>即解得的概率密度函数是正态分布。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>testimg</title>
      <link href="/2023/11/10/testimg/"/>
      <url>/2023/11/10/testimg/</url>
      
        <content type="html"><![CDATA[<p><img src="/loadingPostImg.gif" data-original="1.png" alt="1"></p><p><img src="/loadingPostImg.gif" data-original="2.png" alt="2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/11/10/test/"/>
      <url>/2023/11/10/test/</url>
      
        <content type="html"><![CDATA[<h2 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h2><p>我不仅是个屌丝 我还是小丑 还是咸鱼</p><p>我胆怯又自卑 我的青春就是一场又一场的意淫 </p><p>每天幻想着自己也能得到别人的认同</p><p>现实却是爆了父母的金币 读了个烂学校混日子 之后找班上 没有理想 没有目标 没有能力的三无人员</p><p>每当我看到你们在网上开屌丝的玩笑 我都想哭 </p><p>我就是那地底下的老鼠 我就是那个透过下水井的缝隙窥探地上各种美好生活的老鼠 </p><p>每一次看到他们的幸福生活 对我的心里都是一次伤害 对我生存空间的一次压缩</p><p>但是那能怎么办呢 生活还是在继续 没有尽头</p><p>我不敢把水烧开 那样家里就有两个沸物</p><p>我也不敢把房间打扫的很干净 我怕太干净了 垃圾就只剩下了我</p><p>我就是臭水沟里的老鼠 躲在阴影里面享受无尽的孤独 却又会因为你的一句话破防</p><p>我不渴望陪伴  在一次次怀疑中麻木 以最大的恶意揣测别人</p><p>可每次看到别人被救赎 又会有过一丝丝的希望能发生在自己身上 我也能被救赎吗 或者我真的需要被救赎吗 </p><p>我就是如此虚伪 如此肮脏 如此懦弱 如此不堪一击</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
